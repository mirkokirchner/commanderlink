diff -ruN .github/workflows/ci.yml .github/workflows/ci.yml
--- .github/workflows/ci.yml	1970-01-01 00:00:00.000000000 +0000
+++ .github/workflows/ci.yml	2026-01-20 17:12:09.722384166 +0000
@@ -0,0 +1,22 @@
+name: ci
+
+on:
+  push:
+  pull_request:
+
+jobs:
+  build-contracts:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+
+      - name: Build (contracts-only)
+        run: |
+          make abi clinit cld stubs OS=linux
+
+      - name: ABI fingerprint gate
+        run: |
+          fp=$(./bin/linux/cl_abi_report | sed -n 's/^ABI fingerprint (CT): //p' | head -n 1)
+          exp=$(cat abi/expected_u64.txt | tr -d '\r\n')
+          echo "fingerprint=$fp expected=$exp"
+          test "$fp" = "$exp"
diff -ruN Makefile Makefile
--- Makefile	2026-01-20 16:08:39.000000000 +0000
+++ Makefile	2026-01-20 17:13:55.564734274 +0000
@@ -196,7 +196,7 @@
 cld: $(CLD_BIN)
 
 # Stub services
-$(CORE0_BIN): $(CORE0_OBJ) | dirs
+$(CORE0_BIN): $(CORE0_OBJ) $(RUNTIME_COMMON_OBJ) | dirs
 	$(CC) -o $@ $^ $(LDLIBS) $(LDFLAGS)
 core0: $(CORE0_BIN)
 
diff -ruN abi/expected_u64.txt abi/expected_u64.txt
--- abi/expected_u64.txt	1970-01-01 00:00:00.000000000 +0000
+++ abi/expected_u64.txt	2026-01-20 17:11:54.806032263 +0000
@@ -0,0 +1 @@
+0xff289f48b5a2551c
diff -ruN include/cl_manifest/cl_enums.h include/cl_manifest/cl_enums.h
--- include/cl_manifest/cl_enums.h	2026-01-20 16:08:39.000000000 +0000
+++ include/cl_manifest/cl_enums.h	2026-01-20 17:09:14.891088586 +0000
@@ -125,6 +125,10 @@
     CL_REASON_NONE = 0,
     CL_REASON_P0_IDENTITY_INVALID = 1,
     CL_REASON_P0_IDENTITY_QUARANTINE = 2,
+    /* P0: HAL is missing or non-responsive (producer contract broken) */
+    CL_REASON_P0_HAL_MISSING = 3,
+    /* P0: HAL epochs are stale (commit marker not advancing) */
+    CL_REASON_P0_HAL_STALE = 4,
     CL_REASON_P1_TRUST_BLOCKED = 10,
     CL_REASON_P2_WATCHDOG = 20,
     CL_REASON_P3_BACKEND = 30,
diff -ruN include/cl_runtime/cl_commit.h include/cl_runtime/cl_commit.h
--- include/cl_runtime/cl_commit.h	1970-01-01 00:00:00.000000000 +0000
+++ include/cl_runtime/cl_commit.h	2026-01-20 17:01:57.570965763 +0000
@@ -0,0 +1,36 @@
+#pragma once
+/* ============================================================================
+ * CommanderLink – Commit helpers (SSOT)
+ * Datei: include/cl_runtime/cl_commit.h
+ * ============================================================================
+ * Zweck:
+ *   Zentralisierte Commit-Semantik für SHM-Publisher (Producer) und Reader
+ *   (Consumer). In Stage-1 ist der TOC-entry epoch (u64) der normative
+ *   Commit-Marker pro Segment-Entry.
+ *
+ * Contract (verbindlich):
+ *   Producer:
+ *     1) payload schreiben (normale stores)
+ *     2) epoch publish per Release-Store
+ *   Consumer:
+ *     1) epoch per Acquire-Load lesen
+ *     2) payload lesen
+ *
+ * Hinweis:
+ *   Für Stage-1 vermeiden wir zusätzliche per-Segment seq/CRC Felder, um ABI
+ *   nicht unnötig zu ändern. Sequenzierung erfolgt über epoch.
+ * ============================================================================
+ */
+
+#include <stdint.h>
+#include <stdatomic.h>
+
+#include "cl_toc.h"
+
+static inline uint64_t cl_commit_epoch_load_acquire(const cl_toc_entry_t *e) {
+    return atomic_load_explicit((const _Atomic(uint64_t) *)&e->epoch, memory_order_acquire);
+}
+
+static inline void cl_commit_epoch_store_release(cl_toc_entry_t *e, uint64_t epoch) {
+    atomic_store_explicit((_Atomic(uint64_t) *)&e->epoch, epoch, memory_order_release);
+}
diff -ruN src/core/core0.c src/core/core0.c
--- src/core/core0.c	2026-01-20 16:08:39.000000000 +0000
+++ src/core/core0.c	2026-01-20 17:13:09.378032428 +0000
@@ -25,6 +25,7 @@
 #include <stdint.h>
 #include <stddef.h>
 #include <stdatomic.h>
+#include <inttypes.h>
 #include <string.h>
 #include <errno.h>
 #include <fcntl.h>      /* O_RDWR */
@@ -34,8 +35,10 @@
 #include <time.h>
 
 #include "cl_runtime/cl_runtime.h"
+#include "cl_runtime/cl_abi_fingerprint.h"
 #include "cl_runtime/cl_service_seg_256.h"
 #include "cl_runtime/cl_identity_seg_256.h"
+#include "cl_runtime/cl_commit.h"
 #include "cl_manifest/cl_enums.h"
 
 /* ---------------- Zeit ---------------- */
@@ -84,10 +87,19 @@
     cl_toc_entry_t *e_service;
     cl_toc_entry_t *e_identity;
 
+    cl_toc_entry_t *e_time;
+    cl_toc_entry_t *e_cpu0;
+    cl_toc_entry_t *e_nic0;
+
     cl_service_seg_256_t  *svc;
     cl_identity_seg_256_t *ids;
 
+    cl_time_seg_256_t      *time;
+    cl_cpu_seg_1024_t      *cpu0;
+    cl_nic_seg_512_t       *nic0;
+
     cl_service_slot_32_t  *slot_core;
+    cl_service_slot_32_t  *slot_hal;
 } core_loc_t;
 
 static int core_locate(void *core_base, size_t core_sz, core_loc_t *out) {
@@ -123,6 +135,21 @@
                 out->e_identity = e;
                 out->ids = (cl_identity_seg_256_t*)((uint8_t*)core_base + (size_t)e->offset_bytes);
             }
+        } else if ((uint16_t)e->type == (uint16_t)CL_TIME_SEG_256 && e->stride_bytes == 256u && e->count == 1u) {
+            if ((uint64_t)e->offset_bytes + 256ull <= (uint64_t)core_sz) {
+                out->e_time = e;
+                out->time = (cl_time_seg_256_t*)((uint8_t*)core_base + (size_t)e->offset_bytes);
+            }
+        } else if ((uint16_t)e->type == (uint16_t)CL_CPU_SEG_1024 && e->stride_bytes == 1024u && e->count == 1u) {
+            if ((uint64_t)e->offset_bytes + 1024ull <= (uint64_t)core_sz) {
+                out->e_cpu0 = e;
+                out->cpu0 = (cl_cpu_seg_1024_t*)((uint8_t*)core_base + (size_t)e->offset_bytes);
+            }
+        } else if ((uint16_t)e->type == (uint16_t)CL_NIC_SEG_512 && e->stride_bytes == 512u && e->count == 1u) {
+            if ((uint64_t)e->offset_bytes + 512ull <= (uint64_t)core_sz) {
+                out->e_nic0 = e;
+                out->nic0 = (cl_nic_seg_512_t*)((uint8_t*)core_base + (size_t)e->offset_bytes);
+            }
         }
     }
 
@@ -131,14 +158,10 @@
     out->slot_core = svc_slot(out->svc, CL_SVC_CORE0);
     if (!out->slot_core) return -21;
 
-    return 0;
-}
+    out->slot_hal = svc_slot(out->svc, CL_SVC_HAL0);
+    if (!out->slot_hal) return -22;
 
-/* ---------------- Epoch Publish (u64 Release) ----------------
- * SSOT: epoch ist u64. Wir publizieren via Release-Store als Commit.
- */
-static void toc_epoch_publish_u64(cl_toc_entry_t *e, uint64_t new_epoch) {
-    atomic_store_explicit((_Atomic(uint64_t) *)&e->epoch, new_epoch, memory_order_release);
+    return 0;
 }
 
 /* ---------------- Identity VALID Definition (Stage-1) ---------------- */
@@ -175,9 +198,20 @@
 
     printf("core0: started pid=%d\n", (int)getpid());
 
+    /* Defense-in-depth: ABI muss zum Build passen (cld macht failfast). */
+    const uint64_t want_abi = cl_abi_fingerprint_u64();
+    if (loc.root->abi_layout_checksum != want_abi) {
+        printf("core0: ABI mismatch: shm=0x%016" PRIx64 " build=0x%016" PRIx64 " -> STOP\n",
+               loc.root->abi_layout_checksum, want_abi);
+        return 5;
+    }
+
     uint64_t epoch_ctr = 1;
     int last_valid = -1;
 
+    uint64_t last_e_time = 0, last_e_cpu = 0, last_e_nic = 0;
+    uint64_t last_e_time_ts = 0, last_e_cpu_ts = 0, last_e_nic_ts = 0;
+
     for (;;) {
         /* Heartbeat (Stage-1 Pflicht) */
         uint64_t t = now_ns();
@@ -188,6 +222,36 @@
         }
         atomic_store_explicit(&loc.slot_core->last_heartbeat_ns, t, memory_order_relaxed);
 
+        /* HAL liveness gate (Stage-1): wenn HAL nicht tickt -> P0 Reason setzen. */
+        uint64_t hal_hb = atomic_load_explicit(&loc.slot_hal->last_heartbeat_ns, memory_order_acquire);
+        const uint64_t hal_age_ns = (hal_hb == 0ull) ? UINT64_MAX : (t - hal_hb);
+        const int hal_alive = (hal_hb != 0ull) && (hal_age_ns <= 1000000000ull); /* 1s */
+
+        /* HAL epoch freshness (Stage-1 contract): epochs must advance periodically.
+         * Threshold is intentionally conservative for early bring-up.
+         */
+        int hal_stale = 0;
+        const uint64_t stale_ns = 2000000000ull; /* 2s */
+
+        if (loc.e_time) {
+            const uint64_t e = cl_commit_epoch_load_acquire(loc.e_time);
+            if (e == 0ull) { hal_stale = 1; }
+            else if (e != last_e_time) { last_e_time = e; last_e_time_ts = t; }
+            else if (last_e_time_ts != 0ull && (t - last_e_time_ts) > stale_ns) { hal_stale = 1; }
+        }
+        if (loc.e_cpu0) {
+            const uint64_t e = cl_commit_epoch_load_acquire(loc.e_cpu0);
+            if (e == 0ull) { hal_stale = 1; }
+            else if (e != last_e_cpu) { last_e_cpu = e; last_e_cpu_ts = t; }
+            else if (last_e_cpu_ts != 0ull && (t - last_e_cpu_ts) > stale_ns) { hal_stale = 1; }
+        }
+        if (loc.e_nic0) {
+            const uint64_t e = cl_commit_epoch_load_acquire(loc.e_nic0);
+            if (e == 0ull) { hal_stale = 1; }
+            else if (e != last_e_nic) { last_e_nic = e; last_e_nic_ts = t; }
+            else if (last_e_nic_ts != 0ull && (t - last_e_nic_ts) > stale_ns) { hal_stale = 1; }
+        }
+
         /* Identity check */
         int valid = identity_is_valid(loc.ids);
 
@@ -196,14 +260,15 @@
             last_valid = valid;
         }
 
-        if (!valid) {
+        if (!valid || !hal_alive || hal_stale) {
             /* P0 Gate: CORE setzt redirect_allowed konservativ 0.
              * Identity-State NICHT blind überschreiben (cld ist Producer).
              * Reason kann gesetzt werden, ohne state zu zerstören.
              */
-            atomic_store_explicit(&loc.ids->hot.reason_code,
-                                  (uint32_t)CL_REASON_P0_IDENTITY_INVALID,
-                                  memory_order_relaxed);
+            const uint32_t why = (!valid) ? (uint32_t)CL_REASON_P0_IDENTITY_INVALID
+                              : (!hal_alive) ? (uint32_t)CL_REASON_P0_HAL_MISSING
+                                             : (uint32_t)CL_REASON_P0_HAL_STALE;
+            atomic_store_explicit(&loc.ids->hot.reason_code, why, memory_order_relaxed);
 
             atomic_store_explicit(&loc.svc->g0.redirect_allowed, 0u, memory_order_relaxed);
         } else {
@@ -211,16 +276,18 @@
             atomic_store_explicit(&loc.ids->hot.reason_code, (uint32_t)CL_REASON_NONE, memory_order_relaxed);
 
             /* Publish epochs once (Cut-Point) */
-            uint64_t e_id = atomic_load_explicit((_Atomic(uint64_t) *)&loc.e_identity->epoch, memory_order_acquire);
-            if (e_id == 0u) toc_epoch_publish_u64(loc.e_identity, epoch_ctr++);
+            uint64_t e_id = cl_commit_epoch_load_acquire(loc.e_identity);
+            if (e_id == 0u) cl_commit_epoch_store_release(loc.e_identity, epoch_ctr++);
 
             if (loc.e_service) {
-                uint64_t e_sv = atomic_load_explicit((_Atomic(uint64_t) *)&loc.e_service->epoch, memory_order_acquire);
-                if (e_sv == 0u) toc_epoch_publish_u64(loc.e_service, epoch_ctr++);
+                uint64_t e_sv = cl_commit_epoch_load_acquire(loc.e_service);
+                if (e_sv == 0u) cl_commit_epoch_store_release(loc.e_service, epoch_ctr++);
             }
 
             /* Stage-1 bleibt konservativ: redirect_allowed = 0 (Trust/Failsafe fehlen) */
             atomic_store_explicit(&loc.svc->g0.redirect_allowed, 0u, memory_order_relaxed);
+
+            /* Ingest is validation-only in Stage-1; payload use comes later. */
         }
 
         struct timespec ts = {0};
diff -ruN src/hal/hal0.c src/hal/hal0.c
--- src/hal/hal0.c	2026-01-20 16:08:39.000000000 +0000
+++ src/hal/hal0.c	2026-01-20 17:03:14.174523131 +0000
@@ -39,6 +39,7 @@
 #include "cl_runtime/cl_runtime.h"
 #include "cl_runtime/cl_service_seg_256.h"
 #include "cl_runtime/cl_quality.h"
+#include "cl_runtime/cl_commit.h"
 
 /* ---------------- Zeit ---------------- */
 static uint64_t now_ns(void) {
@@ -73,12 +74,32 @@
     cl_time_seg_256_t    *time;
     cl_cpu_seg_1024_t    *cpu0;
     cl_nic_seg_512_t     *nic0;
+
+    cl_toc_entry_t       *e_time;
+    cl_toc_entry_t       *e_cpu0;
+    cl_toc_entry_t       *e_nic0;
 } hal_loc_t;
 
+/* ---------------- Service slot mapping (driftfest, identisch zu cld/core0) -- */
+static cl_service_slot_32_t* svc_slot(cl_service_seg_256_t *s, cl_service_id_t id) {
+    switch (id) {
+        case CL_SVC_CORE0:   return &s->g1.s0;
+        case CL_SVC_HAL0:    return &s->g1.s1;
+        case CL_SVC_LINK0:   return &s->g2.s2;
+        case CL_SVC_FLOW0:   return &s->g2.s3;
+        case CL_SVC_ORACLE0: return &s->g3.s4;
+        case CL_SVC_MONITOR: return &s->g3.s5;
+        default: return NULL;
+    }
+}
+
 static int hal_locate(void *core_base, size_t core_sz, hal_loc_t *out) {
     memset(out, 0, sizeof(*out));
 
     cl_root_t *r = (cl_root_t*)core_base;
+    if (r->root_magic != CL_ROOT_MAGIC_U32) return -20;
+    if (r->schema_version != CL_SCHEMA_VERSION_U32) return -21;
+    if (r->endian_magic != CL_ENDIAN_MAGIC_U32) return -22;
     if (r->toc_size < sizeof(cl_toc_header_t)) return -1;
     if ((uint64_t)r->toc_offset + (uint64_t)r->toc_size > (uint64_t)core_sz) return -2;
 
@@ -87,15 +108,21 @@
     for (uint32_t i = 0; i < toc->header.entry_count && i < CL_TOC_MAX_ENTRIES; i++) {
         cl_toc_entry_t *e = &toc->entries[i];
 
+        /* Stage-1: HAL0 schreibt nur RESIDENT Core-Segmente; RECLAIMABLE skip */
+        if ((e->flags & CL_TOC_FLAG_RECLAIMABLE) != 0u) continue;
+
         if ((uint16_t)e->type == (uint16_t)CL_SERVICE_SEG_256) {
             out->svc = (cl_service_seg_256_t*)((uint8_t*)core_base + (size_t)e->offset_bytes);
-            out->slot_hal = &out->svc->g1.s1;
+            out->slot_hal = svc_slot(out->svc, CL_SVC_HAL0);
         } else if ((uint16_t)e->type == (uint16_t)CL_TIME_SEG_256) {
             out->time = (cl_time_seg_256_t*)((uint8_t*)core_base + (size_t)e->offset_bytes);
+            out->e_time = e;
         } else if ((uint16_t)e->type == (uint16_t)CL_CPU_SEG_1024) {
             out->cpu0 = (cl_cpu_seg_1024_t*)((uint8_t*)core_base + (size_t)e->offset_bytes);
+            out->e_cpu0 = e;
         } else if ((uint16_t)e->type == (uint16_t)CL_NIC_SEG_512) {
             out->nic0 = (cl_nic_seg_512_t*)((uint8_t*)core_base + (size_t)e->offset_bytes);
+            out->e_nic0 = e;
         }
     }
 
@@ -135,6 +162,8 @@
         return 3;
     }
 
+    uint64_t epoch_ctr = 1;
+
     for (;;) {
         /* Heartbeat */
         atomic_store(&loc.slot_hal->last_heartbeat_ns, now_ns());
@@ -155,6 +184,9 @@
             /* src/qual liegen in deinem TIME Layout im cold */
             loc.time->cold.src  = (uint8_t)CL_QUAL_BEST_EFFORT;
             loc.time->cold.qual = (uint8_t)CL_QUAL_BEST_EFFORT;
+
+            /* Commit (SSOT): TOC epoch publish ist der Segment-Commit-Marker */
+            if (loc.e_time) cl_commit_epoch_store_release(loc.e_time, epoch_ctr++);
         }
 
         /* ---------------- CPU0 ---------------- */
@@ -191,6 +223,8 @@
             loc.cpu0->cold_a.src  = (uint8_t)CL_QUAL_UNSUPPORTED;
             loc.cpu0->cold_a.qual = (uint8_t)CL_QUAL_UNSUPPORTED;
 #endif
+
+            if (loc.e_cpu0) cl_commit_epoch_store_release(loc.e_cpu0, epoch_ctr++);
         }
 
         /* ---------------- NIC0 ---------------- */
@@ -200,6 +234,8 @@
             /* src/qual liegen in deinem NIC Layout im cold_a */
             loc.nic0->cold_a.src  = (uint8_t)CL_QUAL_BEST_EFFORT;
             loc.nic0->cold_a.qual = (uint8_t)CL_QUAL_BEST_EFFORT;
+
+            if (loc.e_nic0) cl_commit_epoch_store_release(loc.e_nic0, epoch_ctr++);
         }
 
         struct timespec ts = {0};
diff -ruN src/oracle/oracle0.c src/oracle/oracle0.c
--- src/oracle/oracle0.c	2026-01-20 16:08:39.000000000 +0000
+++ src/oracle/oracle0.c	2026-01-20 17:14:32.095615382 +0000
@@ -19,8 +19,12 @@
 static int map_core_rw(void **out_base, size_t *out_sz){
     int fd=shm_open(CL_CORE_SHM_NAME,O_RDWR,0); if(fd<0) return -1;
     struct stat st; if(fstat(fd,&st)!=0){close(fd);return -2;} if(st.st_size<=0){close(fd);return -3;}
-    void *p=mmap(NULL,(size_t)st.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); close(fd);
-    if(p==MAP_FAILED) return -4; *out_base=p; *out_sz=(size_t)st.st_size; return 0;
+    void *p=mmap(NULL,(size_t)st.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
+    close(fd);
+    if(p==MAP_FAILED) return -4;
+    *out_base=p;
+    *out_sz=(size_t)st.st_size;
+    return 0;
 }
 
 static cl_service_seg_256_t* find_service_seg(void *core_base){
diff -ruN tools/cl_abi_report/cl_abi_report.c tools/cl_abi_report/cl_abi_report.c
--- tools/cl_abi_report/cl_abi_report.c	2026-01-20 16:08:39.000000000 +0000
+++ tools/cl_abi_report/cl_abi_report.c	2026-01-20 17:11:38.871831226 +0000
@@ -49,7 +49,12 @@
 static uint64_t fnv1a64_u32(uint64_t h, uint32_t v) { return fnv1a64_u64(h, (uint64_t)v); }
 static uint64_t fnv1a64_sz(uint64_t h, size_t v) { return fnv1a64_u64(h, (uint64_t)v); }
 
-/* ABI-Fingerprint: compile-time Wahrheiten */
+/* ABI-Fingerprint: compile-time Wahrheiten
+ * NOTE: kept for forensic cross-checks; not used in Stage-1 default flow.
+ */
+#if defined(__GNUC__) || defined(__clang__)
+__attribute__((unused))
+#endif
 static uint64_t cl_compute_abi_fingerprint(void) {
     uint64_t h = fnv1a64_init();
 
