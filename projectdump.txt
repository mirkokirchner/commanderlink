
>>> START FILE: ./.nfs.7ffe91f3.09684.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.7ffe91f3.09684.4

>>> START FILE: ./.nfs.800e85df.0c9b4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.800e85df.0c9b4.4

>>> START FILE: ./.nfs.800eb7f6.0c9b4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.800eb7f6.0c9b4.4

>>> START FILE: ./.nfs.80574f08.1d974.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.80574f08.1d974.4

>>> START FILE: ./.nfs.807390a5.23d94.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.807390a5.23d94.4

>>> START FILE: ./.nfs.807dad42.25eb4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI: ncurses)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Monitor (ncurses/curses)
# ---------------------------------------------------------------------------
# OS-spezifische curses lib:
#   Linux:   -lncurses
#   BSD:     -lncurses (typisch) — override möglich
#   OmniOS:  -lcurses  (illumos)
MONITOR_LDLIBS ?=
ifeq ($(OS),linux)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS ?= -lcurses
endif

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

# --- Monitor sources (SSOT UI) ---
MONITOR_SRC := \
  src/monitor/monitor_main.c \
  src/monitor/monitor_shm.c \
  src/monitor/monitor_toc.c \
  src/monitor/monitor_draw.c \
  src/monitor/monitor_keymap.c \
  src/monitor/monitor_state.c \
  src/monitor/monitor_fmt.c \
  src/monitor/monitor_help.c \
  src/monitor/monitor_curses.c \
  src/monitor/monitor_draw_helpers.c \
  src/monitor/tabs/tab_dashboard.c \
  src/monitor/tabs/tab_inventory.c \
  src/monitor/tabs/tab_cpu.c \
  src/monitor/tabs/tab_mem.c \
  src/monitor/tabs/tab_nic.c \
  src/monitor/tabs/tab_mesh.c \
  src/monitor/tabs/tab_dma.c \
  src/monitor/tabs/tab_zfs.c \
  src/monitor/tabs/tab_pcie.c \
  src/monitor/tabs/tab_gpu.c \
  src/monitor/tabs/tab_oracle.c \
  src/monitor/tabs/tab_audit.c

# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

# --- Monitor objects ---
MONITOR_OBJ := $(patsubst %.c,$(BUILD_DIR)/%.o,$(MONITOR_SRC))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/monitor

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor
# ---------------------------------------------------------------------------
$(BUILD_DIR)/%.o: %.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS) $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service wrapper): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor (sudo/root): $(MONITOR_BIN)"
	@$(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"
	@echo "  BIN_DIR = $(BIN_DIR)"
	@echo "  BUILD_DIR = $(BUILD_DIR)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make abi-ct     Compile-only ABI gate"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld (destroy->init->boot wrapper)"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0 heartbeats"
	@echo "  make monitor    Build monitor (ncurses/curses)"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-boot     Run clboot"
	@echo "  make run-cld      Run cld (service boot path)"
	@echo "  make run-monitor  Run monitor"


<<< END FILE: ./.nfs.807dad42.25eb4.4

>>> START FILE: ./.nfs.81313032.25eb4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI: ncurses)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Monitor (ncurses/curses)
# ---------------------------------------------------------------------------
# OS-spezifische curses lib:
#   Linux:   -lncurses
#   BSD:     -lncurses (typisch) — override möglich
#   OmniOS:  -lcurses  (illumos)
MONITOR_LDLIBS ?=
ifeq ($(OS),linux)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS ?= -lcurses
endif

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

# --- Monitor sources (SSOT UI) ---
MONITOR_SRC := \
  src/monitor/monitor_main.c \
  src/monitor/monitor_shm.c \
  src/monitor/monitor_toc.c \
  src/monitor/monitor_draw.c \
  src/monitor/monitor_keymap.c \
  src/monitor/monitor_state.c \
  src/monitor/monitor_fmt.c \
  src/monitor/monitor_help.c \
  src/monitor/monitor_curses.c \
  src/monitor/monitor_draw_helpers.c \
  src/monitor/tabs/tab_dashboard.c \
  src/monitor/tabs/tab_inventory.c \
  src/monitor/tabs/tab_cpu.c \
  src/monitor/tabs/tab_mem.c \
  src/monitor/tabs/tab_nic.c \
  src/monitor/tabs/tab_mesh.c \
  src/monitor/tabs/tab_dma.c \
  src/monitor/tabs/tab_zfs.c \
  src/monitor/tabs/tab_pcie.c \
  src/monitor/tabs/tab_gpu.c \
  src/monitor/tabs/tab_oracle.c \
  src/monitor/tabs/tab_audit.c \
  src/monitor/monitor_draw_helpers.c

# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

# --- Monitor objects ---
MONITOR_OBJ := $(patsubst %.c,$(BUILD_DIR)/%.o,$(MONITOR_SRC))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/monitor

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor
# ---------------------------------------------------------------------------
$(BUILD_DIR)/%.o: %.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS) $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service wrapper): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor (sudo/root): $(MONITOR_BIN)"
	@$(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"
	@echo "  BIN_DIR = $(BIN_DIR)"
	@echo "  BUILD_DIR = $(BUILD_DIR)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make abi-ct     Compile-only ABI gate"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld (destroy->init->boot wrapper)"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0 heartbeats"
	@echo "  make monitor    Build monitor (ncurses/curses)"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-boot     Run clboot"
	@echo "  make run-cld      Run cld (service boot path)"
	@echo "  make run-monitor  Run monitor"


<<< END FILE: ./.nfs.81313032.25eb4.4

>>> START FILE: ./.nfs.81626978.533d4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI: ncurses)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Monitor (ncurses/curses)
# ---------------------------------------------------------------------------
# OS-spezifische curses lib:
#   Linux:   -lncurses
#   BSD:     -lncurses (typisch) — override möglich
#   OmniOS:  -lcurses  (illumos)
#
# WICHTIG: MONITOR_LDLIBS darf NICHT per "?=" in den OS-Branches gesetzt werden,
# weil MONITOR_LDLIBS bereits definiert (ggf. leer) ist. Daher: "=" in Branches.
MONITOR_LDLIBS ?=

ifeq ($(OS),linux)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS = -lcurses
endif

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

# --- Monitor sources (SSOT UI) ---
MONITOR_SRC := \
  src/monitor/monitor_main.c \
  src/monitor/monitor_shm.c \
  src/monitor/monitor_toc.c \
  src/monitor/monitor_draw.c \
  src/monitor/monitor_keymap.c \
  src/monitor/monitor_state.c \
  src/monitor/monitor_fmt.c \
  src/monitor/monitor_help.c \
  src/monitor/monitor_curses.c \
  src/monitor/monitor_draw_helpers.c \
  src/monitor/tabs/tab_dashboard.c \
  src/monitor/tabs/tab_inventory.c \
  src/monitor/tabs/tab_cpu.c \
  src/monitor/tabs/tab_mem.c \
  src/monitor/tabs/tab_nic.c \
  src/monitor/tabs/tab_mesh.c \
  src/monitor/tabs/tab_dma.c \
  src/monitor/tabs/tab_zfs.c \
  src/monitor/tabs/tab_pcie.c \
  src/monitor/tabs/tab_gpu.c \
  src/monitor/tabs/tab_oracle.c \
  src/monitor/tabs/tab_audit.c \
  src/monitor/monitor_draw_helpers.c

# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

# --- Monitor objects ---
# sort() entfernt Duplikate (MONITOR_SRC enthält absichtlich/versehentlich doppelte Einträge)
MONITOR_OBJ := $(sort $(patsubst %.c,$(BUILD_DIR)/%.o,$(MONITOR_SRC)))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/monitor

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor
# ---------------------------------------------------------------------------
$(BUILD_DIR)/%.o: %.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS) $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service wrapper): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor (sudo/root): $(MONITOR_BIN)"
	@$(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"
	@echo "  BIN_DIR = $(BIN_DIR)"
	@echo "  BUILD_DIR = $(BUILD_DIR)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make abi-ct     Compile-only ABI gate"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld (destroy->init->boot wrapper)"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0 heartbeats"
	@echo "  make monitor    Build monitor (ncurses/curses)"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-boot     Run clboot"
	@echo "  make run-cld      Run cld (service boot path)"
	@echo "  make run-monitor  Run monitor"


<<< END FILE: ./.nfs.81626978.533d4.4

>>> START FILE: ./.nfs.81626f5f.533d4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI: ncurses)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Monitor (ncurses/curses)
# ---------------------------------------------------------------------------
# OS-spezifische curses lib:
#   Linux:   -lncurses
#   BSD:     -lncurses (typisch) — override möglich
#   OmniOS:  -lcurses  (illumos)
#
# WICHTIG: MONITOR_LDLIBS darf NICHT per "?=" in den OS-Branches gesetzt werden,
# weil MONITOR_LDLIBS bereits definiert (ggf. leer) ist. Daher: "=" in Branches.
MONITOR_LDLIBS ?=

ifeq ($(OS),linux)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS = -lcurses
endif

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

# --- Monitor sources (SSOT UI) ---
MONITOR_SRC := \
  src/monitor/monitor.c \
  src/monitor/mon_curses.c \
  src/monitor/mon_layout.c \
  src/monitor/mon_ui.c \
  src/monitor/mon_input.c \
  src/monitor/tabs/tab_dash.c
# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

# --- Monitor objects ---
# sort() entfernt Duplikate (MONITOR_SRC enthält absichtlich/versehentlich doppelte Einträge)
MONITOR_OBJ := $(sort $(patsubst %.c,$(BUILD_DIR)/%.o,$(MONITOR_SRC)))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/monitor

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor
# ---------------------------------------------------------------------------
$(BUILD_DIR)/%.o: %.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS) $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service wrapper): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor (sudo/root): $(MONITOR_BIN)"
	@$(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"
	@echo "  BIN_DIR = $(BIN_DIR)"
	@echo "  BUILD_DIR = $(BUILD_DIR)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make abi-ct     Compile-only ABI gate"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld (destroy->init->boot wrapper)"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0 heartbeats"
	@echo "  make monitor    Build monitor (ncurses/curses)"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-boot     Run clboot"
	@echo "  make run-cld      Run cld (service boot path)"
	@echo "  make run-monitor  Run monitor"


<<< END FILE: ./.nfs.81626f5f.533d4.4

>>> START FILE: ./.nfs.817dcc22.081d4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI: ncurses)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude -Isrc/monitor

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Monitor (ncurses/curses)
# ---------------------------------------------------------------------------
# OS-spezifische curses lib:
#   Linux:   -lncurses
#   BSD:     -lncurses (typisch) — override möglich
#   OmniOS:  -lcurses  (illumos)
#
# WICHTIG: MONITOR_LDLIBS darf NICHT per "?=" in den OS-Branches gesetzt werden,
# weil MONITOR_LDLIBS bereits definiert (ggf. leer) ist. Daher: "=" in Branches.
MONITOR_LDLIBS ?=

ifeq ($(OS),linux)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS = -lcurses
endif

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

# --- Monitor sources (SSOT UI – bring-up, minimal) ---
# Wichtig: Nur die neuen Minimal-Dateien linken (kein Legacy-Monitor-Stack).
MONITOR_SRC := \
  src/monitor/monitor_main.c \
  src/monitor/monitor_curses.c \
  src/monitor/monitor_state.c \
  src/monitor/monitor_keymap.c \
  src/monitor/monitor_draw.c \
  src/monitor/monitor_draw_helpers.c \
  src/monitor/tabs/tab_dashboard.c

# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

# --- Monitor objects ---
# sort() entfernt Duplikate (MONITOR_SRC enthält absichtlich/versehentlich doppelte Einträge)
MONITOR_OBJ := $(sort $(patsubst %.c,$(BUILD_DIR)/%.o,$(MONITOR_SRC)))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/monitor

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor
# ---------------------------------------------------------------------------
$(BUILD_DIR)/%.o: %.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS) $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service wrapper): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor (sudo/root): $(MONITOR_BIN)"
	@$(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"
	@echo "  BIN_DIR = $(BIN_DIR)"
	@echo "  BUILD_DIR = $(BUILD_DIR)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make abi-ct     Compile-only ABI gate"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld (destroy->init->boot wrapper)"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0 heartbeats"
	@echo "  make monitor    Build monitor (ncurses/curses)"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-boot     Run clboot"
	@echo "  make run-cld      Run cld (service boot path)"
	@echo "  make run-monitor  Run monitor"


<<< END FILE: ./.nfs.817dcc22.081d4.4

>>> START FILE: ./.nfs.817ddd81.081d4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI: ncurses)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Monitor (ncurses/curses)
# ---------------------------------------------------------------------------
# OS-spezifische curses lib:
#   Linux:   -lncurses
#   BSD:     -lncurses (typisch) — override möglich
#   OmniOS:  -lcurses  (illumos)
#
# WICHTIG: MONITOR_LDLIBS darf NICHT per "?=" in den OS-Branches gesetzt werden,
# weil MONITOR_LDLIBS bereits definiert (ggf. leer) ist. Daher: "=" in Branches.
MONITOR_LDLIBS ?=

ifeq ($(OS),linux)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS = -lcurses
endif

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

# --- Monitor sources (SSOT UI) ---
MONITOR_SRC := \
  src/monitor/monitor.c \
  src/monitor/mon_curses.c \
  src/monitor/mon_layout.c \
  src/monitor/mon_ui.c \
  src/monitor/mon_input.c \
  src/monitor/tabs/tab_dash.c
  
# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

# --- Monitor objects ---
# sort() entfernt Duplikate (MONITOR_SRC enthält absichtlich/versehentlich doppelte Einträge)
MONITOR_OBJ := $(sort $(patsubst %.c,$(BUILD_DIR)/%.o,$(MONITOR_SRC)))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/monitor

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor
# ---------------------------------------------------------------------------
$(BUILD_DIR)/%.o: %.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS) $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service wrapper): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor (sudo/root): $(MONITOR_BIN)"
	@$(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"
	@echo "  BIN_DIR = $(BIN_DIR)"
	@echo "  BUILD_DIR = $(BUILD_DIR)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make abi-ct     Compile-only ABI gate"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld (destroy->init->boot wrapper)"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0 heartbeats"
	@echo "  make monitor    Build monitor (ncurses/curses)"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-boot     Run clboot"
	@echo "  make run-cld      Run cld (service boot path)"
	@echo "  make run-monitor  Run monitor"


<<< END FILE: ./.nfs.817ddd81.081d4.4

>>> START FILE: ./.nfs.818494ad.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.818494ad.5aaa4.4

>>> START FILE: ./.nfs.818e88d5.5aaa4.4
# ============================================================================
# CommanderLink – Master Makefile (SSOT)
# ============================================================================
# Targets:
#   make all        -> Baut Tools, Monitor und Stubs
#   make monitor    -> Baut nur den Monitor (ncurses)
#   make abi        -> Baut den ABI Report (Truth Meter)
#   make clean      -> Räumt auf
# ============================================================================

# --- 1. OS Detection ---
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  # Auf OmniOS/illumos oft -lcurses oder -lncurses, Pfade beachten
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
endif

# --- 2. Toolchain Config ---
CC      ?= cc
OPT     ?= -O2
CSTD    ?= -std=c11
WARN    ?= -Wall -Wextra -Wpedantic
DEFS    ?= -D_POSIX_C_SOURCE=200809L
INCS    ?= -Iinclude

CFLAGS  := $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS := $(LDFLAGS_OS)

# Output Paths
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# --- 3. Sources & Objects Definition ---

# A) TOOLS: ABI Report
ABI_SRC   := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ   := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN   := $(BIN_DIR)/cl_abi_report

# B) TOOLS: Dummy SHM (für Monitor-Test ohne Kernel)
DUMMY_SRC := tools/cl_dummy_shm/cl_dummy_shm.c
DUMMY_OBJ := $(BUILD_DIR)/tools/cl_dummy_shm/cl_dummy_shm.o
DUMMY_BIN := $(BIN_DIR)/cl_dummy_shm

# C) MONITOR (Die Exekutive)
MONITOR_SRC := src/monitor/monitor.c \
               src/monitor/monitor_ui.c \
               src/monitor/tabs/tab_dashboard.c
# Automatische Umwandlung .c -> .o im Build-Dir
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/cl_monitor

# D) SYSTEM (Core/Hal/Link/Flow Stubs) - Optional für Full Build
CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

# --- 4. Main Targets ---

.PHONY: all clean vars monitor abi dummy help

all: abi dummy monitor
	@echo "Basic toolset ready."

monitor: $(MONITOR_BIN)
abi:     $(ABI_BIN)
dummy:   $(DUMMY_BIN)

# --- 5. Build Rules ---

# --- MONITOR LINKING ---
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# --- TOOLS LINKING ---
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(DUMMY_BIN): $(DUMMY_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ -lrt $(LDFLAGS)

# --- GENERIC COMPILATION RULES ---

# Rule für src/monitor/*.c
$(BUILD_DIR)/src/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Rule für tools/*.c
$(BUILD_DIR)/tools/%.o: tools/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# --- 6. Helper ---

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf build bin

vars:
	@echo "OS:       $(OS)"
	@echo "CC:       $(CC)"
	@echo "CFLAGS:   $(CFLAGS)"
	@echo "CURSES:   $(LIBCURSES)"
	@echo "MONITOR:  $(MONITOR_BIN)"

help:
	@echo "CommanderLink Build System"
	@echo "  make monitor   -> Build visual monitor"
	@echo "  make dummy     -> Build dummy SHM generator"
	@echo "  make abi       -> Build ABI validator"
	@echo "  make all       -> Build everything"

<<< END FILE: ./.nfs.818e88d5.5aaa4.4

>>> START FILE: ./.nfs.818ea65e.5aaa4.4
# ============================================================================
# CommanderLink – Master Makefile (SSOT)
# ============================================================================
# Targets:
#   make all        -> Baut Tools, Monitor und Stubs
#   make monitor    -> Baut nur den Monitor (ncurses)
#   make abi        -> Baut den ABI Report (Truth Meter)
#   make clean      -> Räumt auf
# ============================================================================

# --- 1. OS Detection ---
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  # Auf OmniOS/illumos oft -lcurses oder -lncurses, Pfade beachten
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
endif

# --- 2. Toolchain Config ---
CC      ?= cc
OPT     ?= -O2
CSTD    ?= -std=c11
WARN    ?= -Wall -Wextra -Wpedantic
DEFS    ?= -D_POSIX_C_SOURCE=200809L
INCS    ?= -Iinclude

CFLAGS  := $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS := $(LDFLAGS_OS)

# Output Paths
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# --- 3. Sources & Objects Definition ---

# A) TOOLS: ABI Report
ABI_SRC   := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ   := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN   := $(BIN_DIR)/cl_abi_report

# B) TOOLS: Dummy SHM (für Monitor-Test ohne Kernel)
DUMMY_SRC := tools/cl_dummy_shm/cl_dummy_shm.c
DUMMY_OBJ := $(BUILD_DIR)/tools/cl_dummy_shm/cl_dummy_shm.o
DUMMY_BIN := $(BIN_DIR)/cl_dummy_shm

# C) MONITOR (Die Exekutive)
MONITOR_SRC = src/monitor/monitor.c \
              src/monitor/monitor_ui.c \
              src/monitor/monitor_state.c \
              src/monitor/monitor_input.c \
              src/monitor/tabs/tab_dashboard.c
              
# Automatische Umwandlung .c -> .o im Build-Dir
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/cl_monitor

# D) SYSTEM (Core/Hal/Link/Flow Stubs) - Optional für Full Build
CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

# --- 4. Main Targets ---

.PHONY: all clean vars monitor abi dummy help

all: abi dummy monitor
	@echo "Basic toolset ready."

monitor: $(MONITOR_BIN)
abi:     $(ABI_BIN)
dummy:   $(DUMMY_BIN)

# --- 5. Build Rules ---

# --- MONITOR LINKING ---
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# --- TOOLS LINKING ---
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(DUMMY_BIN): $(DUMMY_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ -lrt $(LDFLAGS)

# --- GENERIC COMPILATION RULES ---

# Rule für src/monitor/*.c
$(BUILD_DIR)/src/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Rule für tools/*.c
$(BUILD_DIR)/tools/%.o: tools/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# --- 6. Helper ---

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf build bin

vars:
	@echo "OS:       $(OS)"
	@echo "CC:       $(CC)"
	@echo "CFLAGS:   $(CFLAGS)"
	@echo "CURSES:   $(LIBCURSES)"
	@echo "MONITOR:  $(MONITOR_BIN)"

help:
	@echo "CommanderLink Build System"
	@echo "  make monitor   -> Build visual monitor"
	@echo "  make dummy     -> Build dummy SHM generator"
	@echo "  make abi       -> Build ABI validator"
	@echo "  make all       -> Build everything"

<<< END FILE: ./.nfs.818ea65e.5aaa4.4

>>> START FILE: ./.nfs.819ee2b4.5aaa4.4
# ============================================================================
# CommanderLink – Master Makefile (SSOT)
# ============================================================================
# Targets:
#   make all        -> Baut Tools, Monitor und Stubs
#   make monitor    -> Baut nur den Monitor (ncurses)
#   make abi        -> Baut den ABI Report (Truth Meter)
#   make clean      -> Räumt auf
# ============================================================================

# --- 1. OS Detection ---
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  # Auf OmniOS/illumos oft -lcurses oder -lncurses, Pfade beachten
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
endif

# --- 2. Toolchain Config ---
CC      ?= cc
OPT     ?= -O2
CSTD    ?= -std=c11
WARN    ?= -Wall -Wextra -Wpedantic
DEFS    ?= -D_POSIX_C_SOURCE=200809L
INCS    ?= -Iinclude

CFLAGS  := $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS := $(LDFLAGS_OS)

# Output Paths
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# --- 3. Sources & Objects Definition ---

# A) TOOLS: ABI Report
ABI_SRC   := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ   := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN   := $(BIN_DIR)/cl_abi_report

# B) TOOLS: Dummy SHM (für Monitor-Test ohne Kernel)
DUMMY_SRC := tools/cl_dummy_shm/cl_dummy_shm.c
DUMMY_OBJ := $(BUILD_DIR)/tools/cl_dummy_shm/cl_dummy_shm.o
DUMMY_BIN := $(BIN_DIR)/cl_dummy_shm

# C) MONITOR (Die Exekutive)
MONITOR_SRC = src/monitor/monitor.c \
              src/monitor/monitor_ui.c \
              src/monitor/monitor_state.c \
              src/monitor/monitor_input.c \
              src/monitor/tabs/tab_dashboard.c
              
# Automatische Umwandlung .c -> .o im Build-Dir
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/monitor

# D) SYSTEM (Core/Hal/Link/Flow Stubs) - Optional für Full Build
CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

# --- 4. Main Targets ---

.PHONY: all clean vars monitor abi dummy help

all: abi dummy monitor
	@echo "Basic toolset ready."

monitor: $(MONITOR_BIN)
abi:     $(ABI_BIN)
dummy:   $(DUMMY_BIN)

# --- 5. Build Rules ---

# --- MONITOR LINKING ---
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# --- TOOLS LINKING ---
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(DUMMY_BIN): $(DUMMY_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ -lrt $(LDFLAGS)

# --- GENERIC COMPILATION RULES ---

# Rule für src/monitor/*.c
$(BUILD_DIR)/src/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Rule für tools/*.c
$(BUILD_DIR)/tools/%.o: tools/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# --- 6. Helper ---

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf build bin

vars:
	@echo "OS:       $(OS)"
	@echo "CC:       $(CC)"
	@echo "CFLAGS:   $(CFLAGS)"
	@echo "CURSES:   $(LIBCURSES)"
	@echo "MONITOR:  $(MONITOR_BIN)"

help:
	@echo "CommanderLink Build System"
	@echo "  make monitor   -> Build visual monitor"
	@echo "  make dummy     -> Build dummy SHM generator"
	@echo "  make abi       -> Build ABI validator"
	@echo "  make all       -> Build everything"

<<< END FILE: ./.nfs.819ee2b4.5aaa4.4

>>> START FILE: ./.nfs.819ef8e4.5aaa4.4
# ============================================================================
# CommanderLink – Master Makefile (SSOT)
# ============================================================================
# Targets:
#   make all        -> Baut Tools, Monitor und Stubs
#   make monitor    -> Baut nur den Monitor (ncurses)
#   make abi        -> Baut den ABI Report (Truth Meter)
#   make clean      -> Räumt auf
# ============================================================================

# --- 1. OS Detection ---
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  # Auf OmniOS/illumos oft -lcurses oder -lncurses, Pfade beachten
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
endif

# --- 2. Toolchain Config ---
CC      ?= cc
OPT     ?= -O2
CSTD    ?= -std=c11
WARN    ?= -Wall -Wextra -Wpedantic
DEFS    ?= -D_POSIX_C_SOURCE=200809L
INCS    ?= -Iinclude

CFLAGS  := $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS := $(LDFLAGS_OS)

# Output Paths
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# --- 3. Sources & Objects Definition ---

# A) TOOLS: ABI Report
ABI_SRC   := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ   := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN   := $(BIN_DIR)/cl_abi_report

# B) TOOLS: Dummy SHM (für Monitor-Test ohne Kernel)
DUMMY_SRC := tools/cl_dummy_shm/cl_dummy_shm.c
DUMMY_OBJ := $(BUILD_DIR)/tools/cl_dummy_shm/cl_dummy_shm.o
DUMMY_BIN := $(BIN_DIR)/cl_dummy_shm

# C) MONITOR (Die Exekutive)
MONITOR_SRC = src/monitor/monitor.c \
              src/monitor/monitor_ui.c \
              src/monitor/monitor_state.c \
              src/monitor/monitor_input.c \
              src/monitor/tabs/tab_dashboard.c
              
# Automatische Umwandlung .c -> .o im Build-Dir
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/monitor

# D) SYSTEM (Core/Hal/Link/Flow Stubs) - Optional für Full Build
CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

# --- 4. Main Targets ---

.PHONY: all clean vars monitor abi help

all: abi dummy monitor
	@echo "Basic toolset ready."

monitor: $(MONITOR_BIN)
abi:     $(ABI_BIN)
dummy:   $(DUMMY_BIN)

# --- 5. Build Rules ---

# --- MONITOR LINKING ---
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# --- TOOLS LINKING ---
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(DUMMY_BIN): $(DUMMY_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ -lrt $(LDFLAGS)

# --- GENERIC COMPILATION RULES ---

# Rule für src/monitor/*.c
$(BUILD_DIR)/src/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Rule für tools/*.c
$(BUILD_DIR)/tools/%.o: tools/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# --- 6. Helper ---

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf build bin

vars:
	@echo "OS:       $(OS)"
	@echo "CC:       $(CC)"
	@echo "CFLAGS:   $(CFLAGS)"
	@echo "CURSES:   $(LIBCURSES)"
	@echo "MONITOR:  $(MONITOR_BIN)"

help:
	@echo "CommanderLink Build System"
	@echo "  make monitor   -> Build visual monitor"
	@echo "  make dummy     -> Build dummy SHM generator"
	@echo "  make abi       -> Build ABI validator"
	@echo "  make all       -> Build everything"

<<< END FILE: ./.nfs.819ef8e4.5aaa4.4

>>> START FILE: ./.nfs.819f1274.5aaa4.4
# ============================================================================
# CommanderLink – Master Makefile (SSOT)
# ============================================================================
# Targets:
#   make all        -> Baut Tools, Monitor und Stubs
#   make monitor    -> Baut nur den Monitor (ncurses)
#   make abi        -> Baut den ABI Report (Truth Meter)
#   make clean      -> Räumt auf
# ============================================================================

# --- 1. OS Detection ---
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  # Auf OmniOS/illumos oft -lcurses oder -lncurses, Pfade beachten
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
endif

# --- 2. Toolchain Config ---
CC      ?= cc
OPT     ?= -O2
CSTD    ?= -std=c11
WARN    ?= -Wall -Wextra -Wpedantic
DEFS    ?= -D_POSIX_C_SOURCE=200809L
INCS    ?= -Iinclude

CFLAGS  := $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS := $(LDFLAGS_OS)

# Output Paths
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# --- 3. Sources & Objects Definition ---

# A) TOOLS: ABI Report
ABI_SRC   := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ   := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN   := $(BIN_DIR)/cl_abi_report

# B) TOOLS: Dummy SHM (für Monitor-Test ohne Kernel)
DUMMY_SRC := tools/cl_dummy_shm/cl_dummy_shm.c
DUMMY_OBJ := $(BUILD_DIR)/tools/cl_dummy_shm/cl_dummy_shm.o
DUMMY_BIN := $(BIN_DIR)/cl_dummy_shm

# C) MONITOR (Die Exekutive)
MONITOR_SRC = src/monitor/monitor.c \
              src/monitor/monitor_ui.c \
              src/monitor/monitor_state.c \
              src/monitor/monitor_input.c \
              src/monitor/tabs/tab_dashboard.c
              
# Automatische Umwandlung .c -> .o im Build-Dir
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/monitor

# D) SYSTEM (Core/Hal/Link/Flow Stubs) - Optional für Full Build
CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

# --- 4. Main Targets ---

.PHONY: all clean vars monitor abi help

all: abi monitor
	@echo "Basic toolset ready."

monitor: $(MONITOR_BIN)
abi:     $(ABI_BIN)
dummy:   $(DUMMY_BIN)

# --- 5. Build Rules ---

# --- MONITOR LINKING ---
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# --- TOOLS LINKING ---
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(DUMMY_BIN): $(DUMMY_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ -lrt $(LDFLAGS)

# --- GENERIC COMPILATION RULES ---

# Rule für src/monitor/*.c
$(BUILD_DIR)/src/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Rule für tools/*.c
$(BUILD_DIR)/tools/%.o: tools/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# --- 6. Helper ---

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf build bin

vars:
	@echo "OS:       $(OS)"
	@echo "CC:       $(CC)"
	@echo "CFLAGS:   $(CFLAGS)"
	@echo "CURSES:   $(LIBCURSES)"
	@echo "MONITOR:  $(MONITOR_BIN)"

help:
	@echo "CommanderLink Build System"
	@echo "  make monitor   -> Build visual monitor"
	@echo "  make dummy     -> Build dummy SHM generator"
	@echo "  make abi       -> Build ABI validator"
	@echo "  make all       -> Build everything"

<<< END FILE: ./.nfs.819f1274.5aaa4.4

>>> START FILE: ./.nfs.81a0a8d7.61884.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81a0a8d7.61884.4

>>> START FILE: ./.nfs.81a0eb27.61884.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81a0eb27.61884.4

>>> START FILE: ./.nfs.81a49dab.61884.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81a49dab.61884.4

>>> START FILE: ./.nfs.81b2cd1c.66e54.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette + Monitor)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/monitor/cl_monitor   (TUI Dashboard)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
# ============================================================================

UNAME_S := $(shell uname -s)

# --- OS Detection & Libraries ---
ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lrt
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS :=
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
  LDFLAGS_OS :=
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?= $(LDFLAGS_OS)

# --- Directories ---
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# ---------------------------------------------------------------------------
# DEFINITIONS: Sources & Objects
# ---------------------------------------------------------------------------

# 1) ABI Report
ABI_SRC := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN := $(BIN_DIR)/cl_abi_report

# 2) CLINIT
CLINIT_SRC := src/clinit/clinit.c
CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLINIT_BIN := $(BIN_DIR)/clinit

# 3) CLBOOT
CLBOOT_SRC := src/clboot/clboot.c
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLBOOT_BIN := $(BIN_DIR)/clboot

# 4) CLD
CLD_SRC := src/cld/cld.c
CLD_OBJ := $(BUILD_DIR)/src/cld/cld.o
CLD_BIN := $(BIN_DIR)/cld

# 5) MONITOR (NEU)
MONITOR_SRC := src/monitor/monitor.c \
               src/monitor/monitor_ui.c \
               src/monitor/monitor_state.c \
               src/monitor/monitor_input.c \
               src/monitor/tabs/tab_dashboard.c

# Generische Umwandlung src/monitor/*.c -> build/.../src/monitor/*.o
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/cl_monitor

# 6) STUBS
CORE_SRC   := src/core/core0.c
CORE_OBJ   := $(BUILD_DIR)/src/core/core0.o
CORE_BIN   := $(BIN_DIR)/core0

HAL_SRC    := src/hal/hal0.c
HAL_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
HAL_BIN    := $(BIN_DIR)/hal0

LINK_SRC   := src/link/link0.c
LINK_OBJ   := $(BUILD_DIR)/src/link/link0.o
LINK_BIN   := $(BIN_DIR)/link0

FLOW_SRC   := src/flow/flow0.c
FLOW_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
FLOW_BIN   := $(BIN_DIR)/flow0

ORACLE_SRC := src/oracle/oracle0.c
ORACLE_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o
ORACLE_BIN := $(BIN_DIR)/oracle0


# ---------------------------------------------------------------------------
# TARGETS
# ---------------------------------------------------------------------------

.PHONY: all clean print-vars help abi clinit clboot cld stubs monitor

all: abi clinit clboot cld stubs monitor

abi:     $(ABI_BIN)
clinit:  $(CLINIT_BIN)
clboot:  $(CLBOOT_BIN)
cld:     $(CLD_BIN)
monitor: $(MONITOR_BIN)
stubs:   $(CORE_BIN) $(HAL_BIN) $(LINK_BIN) $(FLOW_BIN) $(ORACLE_BIN)

abi-ct: $(ABI_OBJ)
	@echo "ABI Check tool compiled only."

# ---------------------------------------------------------------------------
# RULES: Linking
# ---------------------------------------------------------------------------

# ABI
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# CLINIT
$(CLINIT_BIN): $(CLINIT_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# CLBOOT
$(CLBOOT_BIN): $(CLBOOT_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# CLD
$(CLD_BIN): $(CLD_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# MONITOR (Braucht ncurses)
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# STUBS
$(CORE_BIN): $(CORE_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(HAL_BIN): $(HAL_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(LINK_BIN): $(LINK_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(FLOW_BIN): $(FLOW_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(ORACLE_BIN): $(ORACLE_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# ---------------------------------------------------------------------------
# RULES: Compiling
# ---------------------------------------------------------------------------

# Tools
$(BUILD_DIR)/tools/cl_abi_report/%.o: tools/cl_abi_report/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Clinit
$(BUILD_DIR)/src/clinit/%.o: src/clinit/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Clboot
$(BUILD_DIR)/src/clboot/%.o: src/clboot/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Cld
$(BUILD_DIR)/src/cld/%.o: src/cld/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Monitor (Base)
$(BUILD_DIR)/src/monitor/%.o: src/monitor/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Monitor (Tabs)
$(BUILD_DIR)/src/monitor/tabs/%.o: src/monitor/tabs/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Stubs
$(BUILD_DIR)/src/core/%.o: src/core/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/hal/%.o: src/hal/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/link/%.o: src/link/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/flow/%.o: src/flow/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/oracle/%.o: src/oracle/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  LIBCURSES = $(LIBCURSES)"
	@echo "  BIN_DIR = $(BIN_DIR)"

<<< END FILE: ./.nfs.81b2cd1c.66e54.4

>>> START FILE: ./.nfs.81daded4.6f534.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81daded4.6f534.4

>>> START FILE: ./.nfs.81dbb6a4.6f534.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81dbb6a4.6f534.4

>>> START FILE: ./.nfs.81dbfbec.6f534.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81dbfbec.6f534.4

>>> START FILE: ./.nfs.81de4be0.6f534.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81de4be0.6f534.4

>>> START FILE: ./.nfs.81e67082.6f534.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81e67082.6f534.4

>>> START FILE: ./.nfs.81eb6f66.6f534.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81eb6f66.6f534.4

>>> START FILE: ./.nfs.81f60fa2.081d4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette + Monitor)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/monitor/cl_monitor   (TUI Dashboard)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
# ============================================================================

UNAME_S := $(shell uname -s)

# --- OS Detection & Libraries ---
ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lrt
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS :=
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
  LDFLAGS_OS :=
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?= $(LDFLAGS_OS)

# --- Directories ---
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# ---------------------------------------------------------------------------
# DEFINITIONS: Sources & Objects
# ---------------------------------------------------------------------------

# 1) ABI Report
ABI_SRC := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN := $(BIN_DIR)/cl_abi_report

# 2) CLINIT
CLINIT_SRC := src/clinit/clinit.c
CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLINIT_BIN := $(BIN_DIR)/clinit

# 3) CLBOOT
CLBOOT_SRC := src/clboot/clboot.c
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLBOOT_BIN := $(BIN_DIR)/clboot

# 4) CLD
CLD_SRC := src/cld/cld.c
CLD_OBJ := $(BUILD_DIR)/src/cld/cld.o
CLD_BIN := $(BIN_DIR)/cld

# 5) MONITOR (NEU)
MONITOR_SRC := src/monitor/monitor.c \
               src/monitor/monitor_ui.c \
               src/monitor/monitor_state.c \
               src/monitor/monitor_input.c \
               src/monitor/tabs/tab_dashboard.c

# Generische Umwandlung src/monitor/*.c -> build/.../src/monitor/*.o
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/monitor

# 6) STUBS
CORE_SRC   := src/core/core0.c
CORE_OBJ   := $(BUILD_DIR)/src/core/core0.o
CORE_BIN   := $(BIN_DIR)/core0

HAL_SRC    := src/hal/hal0.c
HAL_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
HAL_BIN    := $(BIN_DIR)/hal0

LINK_SRC   := src/link/link0.c
LINK_OBJ   := $(BUILD_DIR)/src/link/link0.o
LINK_BIN   := $(BIN_DIR)/link0

FLOW_SRC   := src/flow/flow0.c
FLOW_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
FLOW_BIN   := $(BIN_DIR)/flow0

ORACLE_SRC := src/oracle/oracle0.c
ORACLE_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o
ORACLE_BIN := $(BIN_DIR)/oracle0


# ---------------------------------------------------------------------------
# TARGETS
# ---------------------------------------------------------------------------

.PHONY: all clean print-vars help abi clinit clboot cld stubs monitor

all: abi clinit clboot cld stubs monitor

abi:     $(ABI_BIN)
clinit:  $(CLINIT_BIN)
clboot:  $(CLBOOT_BIN)
cld:     $(CLD_BIN)
monitor: $(MONITOR_BIN)
stubs:   $(CORE_BIN) $(HAL_BIN) $(LINK_BIN) $(FLOW_BIN) $(ORACLE_BIN)

abi-ct: $(ABI_OBJ)
	@echo "ABI Check tool compiled only."

# ---------------------------------------------------------------------------
# RULES: Linking
# ---------------------------------------------------------------------------

# ABI
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# CLINIT
$(CLINIT_BIN): $(CLINIT_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# CLBOOT
$(CLBOOT_BIN): $(CLBOOT_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# CLD
$(CLD_BIN): $(CLD_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# MONITOR (Braucht ncurses)
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# STUBS
$(CORE_BIN): $(CORE_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(HAL_BIN): $(HAL_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(LINK_BIN): $(LINK_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(FLOW_BIN): $(FLOW_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(ORACLE_BIN): $(ORACLE_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# ---------------------------------------------------------------------------
# RULES: Compiling
# ---------------------------------------------------------------------------

# Tools
$(BUILD_DIR)/tools/cl_abi_report/%.o: tools/cl_abi_report/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Clinit
$(BUILD_DIR)/src/clinit/%.o: src/clinit/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Clboot
$(BUILD_DIR)/src/clboot/%.o: src/clboot/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Cld
$(BUILD_DIR)/src/cld/%.o: src/cld/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Monitor (Base)
$(BUILD_DIR)/src/monitor/%.o: src/monitor/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Monitor (Tabs)
$(BUILD_DIR)/src/monitor/tabs/%.o: src/monitor/tabs/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Stubs
$(BUILD_DIR)/src/core/%.o: src/core/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/hal/%.o: src/hal/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/link/%.o: src/link/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/flow/%.o: src/flow/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/oracle/%.o: src/oracle/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  LIBCURSES = $(LIBCURSES)"
	@echo "  BIN_DIR = $(BIN_DIR)"

<<< END FILE: ./.nfs.81f60fa2.081d4.4

>>> START FILE: ./.nfs.81f62280.081d4.4
# ============================================================================
# CommanderLink – Master Makefile (SSOT)
# ============================================================================
# Targets:
#   make all        -> Baut Tools, Monitor und Stubs
#   make monitor    -> Baut nur den Monitor (ncurses)
#   make abi        -> Baut den ABI Report (Truth Meter)
#   make clean      -> Räumt auf
# ============================================================================

# --- 1. OS Detection ---
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  # Auf OmniOS/illumos oft -lcurses oder -lncurses, Pfade beachten
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
endif

# --- 2. Toolchain Config ---
CC      ?= cc
OPT     ?= -O2
CSTD    ?= -std=c11
WARN    ?= -Wall -Wextra -Wpedantic
DEFS    ?= -D_POSIX_C_SOURCE=200809L
INCS    ?= -Iinclude

CFLAGS  := $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS := $(LDFLAGS_OS)

# Output Paths
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# --- 3. Sources & Objects Definition ---

# A) TOOLS: ABI Report
ABI_SRC   := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ   := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN   := $(BIN_DIR)/cl_abi_report

# B) TOOLS: Dummy SHM (für Monitor-Test ohne Kernel)
DUMMY_SRC := tools/cl_dummy_shm/cl_dummy_shm.c
DUMMY_OBJ := $(BUILD_DIR)/tools/cl_dummy_shm/cl_dummy_shm.o
DUMMY_BIN := $(BIN_DIR)/cl_dummy_shm

# C) MONITOR (Die Exekutive)
MONITOR_SRC = src/monitor/monitor.c \
              src/monitor/monitor_ui.c \
              src/monitor/monitor_state.c \
              src/monitor/monitor_input.c \
              src/monitor/tabs/tab_dashboard.c
              
# Automatische Umwandlung .c -> .o im Build-Dir
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/monitor

# D) SYSTEM (Core/Hal/Link/Flow Stubs) - Optional für Full Build
CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

# --- 4. Main Targets ---

.PHONY: all clean vars monitor abi help

all: abi monitor cld
	@echo "Basic toolset ready."

monitor: $(MONITOR_BIN)
abi:     $(ABI_BIN)
dummy:   $(DUMMY_BIN)

# --- 5. Build Rules ---

# --- MONITOR LINKING ---
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# --- TOOLS LINKING ---
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(DUMMY_BIN): $(DUMMY_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ -lrt $(LDFLAGS)

# --- GENERIC COMPILATION RULES ---

# Rule für src/monitor/*.c
$(BUILD_DIR)/src/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Rule für tools/*.c
$(BUILD_DIR)/tools/%.o: tools/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# --- 6. Helper ---

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf build bin

vars:
	@echo "OS:       $(OS)"
	@echo "CC:       $(CC)"
	@echo "CFLAGS:   $(CFLAGS)"
	@echo "CURSES:   $(LIBCURSES)"
	@echo "MONITOR:  $(MONITOR_BIN)"

help:
	@echo "CommanderLink Build System"
	@echo "  make monitor   -> Build visual monitor"
	@echo "  make dummy     -> Build dummy SHM generator"
	@echo "  make abi       -> Build ABI validator"
	@echo "  make all       -> Build everything"

<<< END FILE: ./.nfs.81f62280.081d4.4

>>> START FILE: ./.nfs.81f79b50.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81f79b50.75fb4.4

>>> START FILE: ./.nfs.81faa63c.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81faa63c.75fb4.4

>>> START FILE: ./.nfs.81fb0cd4.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81fb0cd4.75fb4.4

>>> START FILE: ./.nfs.81fdbb28.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81fdbb28.75fb4.4

>>> START FILE: ./.nfs.81fe21c7.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81fe21c7.75fb4.4

>>> START FILE: ./.nfs.823f1438.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.823f1438.75fb4.4

>>> START FILE: ./.nfs.823f6169.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.823f6169.75fb4.4

>>> START FILE: ./.nfs.823f9c3c.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.823f9c3c.75fb4.4

>>> START FILE: ./.nfs.8241688c.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8241688c.75fb4.4

>>> START FILE: ./.nfs.8241a1fc.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8241a1fc.75fb4.4

>>> START FILE: ./.nfs.8241bfa8.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8241bfa8.75fb4.4

>>> START FILE: ./.nfs.8242c97a.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8242c97a.75fb4.4

>>> START FILE: ./.nfs.8243fc24.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8243fc24.75fb4.4

>>> START FILE: ./.nfs.824400c7.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.824400c7.75fb4.4

>>> START FILE: ./.nfs.8255d539.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8255d539.75fb4.4

>>> START FILE: ./.nfs.82560a18.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.82560a18.75fb4.4

>>> START FILE: ./.nfs.82562c91.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.82562c91.75fb4.4

>>> START FILE: ./.nfs.82563421.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.82563421.75fb4.4

>>> START FILE: ./.nfs.8256f306.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8256f306.75fb4.4

>>> START FILE: ./.nfs.82582300.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.82582300.75fb4.4

>>> START FILE: ./.nfs.825830ec.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.825830ec.75fb4.4

>>> START FILE: ./.nfs.82bd2602.081d4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI, read-only; run with sudo in dev)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

MONITOR_SRC := src/monitor/monitor.c \
               src/monitor/monitor_ui.c \
               src/monitor/monitor_state.c \
               src/monitor/monitor_input.c \
               src/monitor/tabs/tab_dashboard.c
# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

MONITOR_OBJ := $(BUILD_DIR)/src/monitor/monitor.o

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/cl_monitor

# ---------------------------------------------------------------------------
# Monitor link libs (OS-spezifisch, override möglich)
# ---------------------------------------------------------------------------
MONITOR_LDLIBS ?=
ifeq ($(OS),linux)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS ?= -lcurses
endif

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor (SSOT UI)
# ---------------------------------------------------------------------------
$(MONITOR_OBJ): $(MONITOR_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service boot path): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor with sudo: $(MONITOR_BIN)"
	@sudo $(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S    = $(UNAME_S)"
	@echo "  OS         = $(OS)"
	@echo "  CC         = $(CC)"
	@echo "  CFLAGS     = $(CFLAGS)"
	@echo "  BIN_DIR    = $(BIN_DIR)"
	@echo "  BUILD_DIR  = $(BUILD_DIR)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0"
	@echo "  make monitor    Build cl_monitor"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-cld      Boot via cld (destroy->init->clboot)"
	@echo "  make run-monitor  Run monitor via sudo"
	@echo ""
	@echo "Monitor libs:"
	@echo "  Override with: gmake MONITOR_LDLIBS=-lncursesw monitor"


<<< END FILE: ./.nfs.82bd2602.081d4.4

>>> START FILE: ./.nfs.82bdb153.081d4.4

>>> START FILE: ./.nfs.7ffe91f3.09684.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.7ffe91f3.09684.4

>>> START FILE: ./.nfs.800e85df.0c9b4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.800e85df.0c9b4.4

>>> START FILE: ./.nfs.800eb7f6.0c9b4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.800eb7f6.0c9b4.4

>>> START FILE: ./.nfs.80574f08.1d974.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.80574f08.1d974.4

>>> START FILE: ./.nfs.807390a5.23d94.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.807390a5.23d94.4

>>> START FILE: ./.nfs.807dad42.25eb4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI: ncurses)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Monitor (ncurses/curses)
# ---------------------------------------------------------------------------
# OS-spezifische curses lib:
#   Linux:   -lncurses
#   BSD:     -lncurses (typisch) — override möglich
#   OmniOS:  -lcurses  (illumos)
MONITOR_LDLIBS ?=
ifeq ($(OS),linux)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS ?= -lcurses
endif

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

# --- Monitor sources (SSOT UI) ---
MONITOR_SRC := \
  src/monitor/monitor_main.c \
  src/monitor/monitor_shm.c \
  src/monitor/monitor_toc.c \
  src/monitor/monitor_draw.c \
  src/monitor/monitor_keymap.c \
  src/monitor/monitor_state.c \
  src/monitor/monitor_fmt.c \
  src/monitor/monitor_help.c \
  src/monitor/monitor_curses.c \
  src/monitor/monitor_draw_helpers.c \
  src/monitor/tabs/tab_dashboard.c \
  src/monitor/tabs/tab_inventory.c \
  src/monitor/tabs/tab_cpu.c \
  src/monitor/tabs/tab_mem.c \
  src/monitor/tabs/tab_nic.c \
  src/monitor/tabs/tab_mesh.c \
  src/monitor/tabs/tab_dma.c \
  src/monitor/tabs/tab_zfs.c \
  src/monitor/tabs/tab_pcie.c \
  src/monitor/tabs/tab_gpu.c \
  src/monitor/tabs/tab_oracle.c \
  src/monitor/tabs/tab_audit.c

# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

# --- Monitor objects ---
MONITOR_OBJ := $(patsubst %.c,$(BUILD_DIR)/%.o,$(MONITOR_SRC))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/monitor

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor
# ---------------------------------------------------------------------------
$(BUILD_DIR)/%.o: %.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS) $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service wrapper): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor (sudo/root): $(MONITOR_BIN)"
	@$(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"
	@echo "  BIN_DIR = $(BIN_DIR)"
	@echo "  BUILD_DIR = $(BUILD_DIR)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make abi-ct     Compile-only ABI gate"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld (destroy->init->boot wrapper)"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0 heartbeats"
	@echo "  make monitor    Build monitor (ncurses/curses)"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-boot     Run clboot"
	@echo "  make run-cld      Run cld (service boot path)"
	@echo "  make run-monitor  Run monitor"


<<< END FILE: ./.nfs.807dad42.25eb4.4

>>> START FILE: ./.nfs.81313032.25eb4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI: ncurses)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Monitor (ncurses/curses)
# ---------------------------------------------------------------------------
# OS-spezifische curses lib:
#   Linux:   -lncurses
#   BSD:     -lncurses (typisch) — override möglich
#   OmniOS:  -lcurses  (illumos)
MONITOR_LDLIBS ?=
ifeq ($(OS),linux)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS ?= -lcurses
endif

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

# --- Monitor sources (SSOT UI) ---
MONITOR_SRC := \
  src/monitor/monitor_main.c \
  src/monitor/monitor_shm.c \
  src/monitor/monitor_toc.c \
  src/monitor/monitor_draw.c \
  src/monitor/monitor_keymap.c \
  src/monitor/monitor_state.c \
  src/monitor/monitor_fmt.c \
  src/monitor/monitor_help.c \
  src/monitor/monitor_curses.c \
  src/monitor/monitor_draw_helpers.c \
  src/monitor/tabs/tab_dashboard.c \
  src/monitor/tabs/tab_inventory.c \
  src/monitor/tabs/tab_cpu.c \
  src/monitor/tabs/tab_mem.c \
  src/monitor/tabs/tab_nic.c \
  src/monitor/tabs/tab_mesh.c \
  src/monitor/tabs/tab_dma.c \
  src/monitor/tabs/tab_zfs.c \
  src/monitor/tabs/tab_pcie.c \
  src/monitor/tabs/tab_gpu.c \
  src/monitor/tabs/tab_oracle.c \
  src/monitor/tabs/tab_audit.c \
  src/monitor/monitor_draw_helpers.c

# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

# --- Monitor objects ---
MONITOR_OBJ := $(patsubst %.c,$(BUILD_DIR)/%.o,$(MONITOR_SRC))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/monitor

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor
# ---------------------------------------------------------------------------
$(BUILD_DIR)/%.o: %.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS) $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service wrapper): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor (sudo/root): $(MONITOR_BIN)"
	@$(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"
	@echo "  BIN_DIR = $(BIN_DIR)"
	@echo "  BUILD_DIR = $(BUILD_DIR)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make abi-ct     Compile-only ABI gate"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld (destroy->init->boot wrapper)"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0 heartbeats"
	@echo "  make monitor    Build monitor (ncurses/curses)"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-boot     Run clboot"
	@echo "  make run-cld      Run cld (service boot path)"
	@echo "  make run-monitor  Run monitor"


<<< END FILE: ./.nfs.81313032.25eb4.4

>>> START FILE: ./.nfs.81626978.533d4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI: ncurses)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Monitor (ncurses/curses)
# ---------------------------------------------------------------------------
# OS-spezifische curses lib:
#   Linux:   -lncurses
#   BSD:     -lncurses (typisch) — override möglich
#   OmniOS:  -lcurses  (illumos)
#
# WICHTIG: MONITOR_LDLIBS darf NICHT per "?=" in den OS-Branches gesetzt werden,
# weil MONITOR_LDLIBS bereits definiert (ggf. leer) ist. Daher: "=" in Branches.
MONITOR_LDLIBS ?=

ifeq ($(OS),linux)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS = -lcurses
endif

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

# --- Monitor sources (SSOT UI) ---
MONITOR_SRC := \
  src/monitor/monitor_main.c \
  src/monitor/monitor_shm.c \
  src/monitor/monitor_toc.c \
  src/monitor/monitor_draw.c \
  src/monitor/monitor_keymap.c \
  src/monitor/monitor_state.c \
  src/monitor/monitor_fmt.c \
  src/monitor/monitor_help.c \
  src/monitor/monitor_curses.c \
  src/monitor/monitor_draw_helpers.c \
  src/monitor/tabs/tab_dashboard.c \
  src/monitor/tabs/tab_inventory.c \
  src/monitor/tabs/tab_cpu.c \
  src/monitor/tabs/tab_mem.c \
  src/monitor/tabs/tab_nic.c \
  src/monitor/tabs/tab_mesh.c \
  src/monitor/tabs/tab_dma.c \
  src/monitor/tabs/tab_zfs.c \
  src/monitor/tabs/tab_pcie.c \
  src/monitor/tabs/tab_gpu.c \
  src/monitor/tabs/tab_oracle.c \
  src/monitor/tabs/tab_audit.c \
  src/monitor/monitor_draw_helpers.c

# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

# --- Monitor objects ---
# sort() entfernt Duplikate (MONITOR_SRC enthält absichtlich/versehentlich doppelte Einträge)
MONITOR_OBJ := $(sort $(patsubst %.c,$(BUILD_DIR)/%.o,$(MONITOR_SRC)))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/monitor

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor
# ---------------------------------------------------------------------------
$(BUILD_DIR)/%.o: %.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS) $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service wrapper): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor (sudo/root): $(MONITOR_BIN)"
	@$(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"
	@echo "  BIN_DIR = $(BIN_DIR)"
	@echo "  BUILD_DIR = $(BUILD_DIR)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make abi-ct     Compile-only ABI gate"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld (destroy->init->boot wrapper)"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0 heartbeats"
	@echo "  make monitor    Build monitor (ncurses/curses)"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-boot     Run clboot"
	@echo "  make run-cld      Run cld (service boot path)"
	@echo "  make run-monitor  Run monitor"


<<< END FILE: ./.nfs.81626978.533d4.4

>>> START FILE: ./.nfs.81626f5f.533d4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI: ncurses)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Monitor (ncurses/curses)
# ---------------------------------------------------------------------------
# OS-spezifische curses lib:
#   Linux:   -lncurses
#   BSD:     -lncurses (typisch) — override möglich
#   OmniOS:  -lcurses  (illumos)
#
# WICHTIG: MONITOR_LDLIBS darf NICHT per "?=" in den OS-Branches gesetzt werden,
# weil MONITOR_LDLIBS bereits definiert (ggf. leer) ist. Daher: "=" in Branches.
MONITOR_LDLIBS ?=

ifeq ($(OS),linux)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS = -lcurses
endif

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

# --- Monitor sources (SSOT UI) ---
MONITOR_SRC := \
  src/monitor/monitor.c \
  src/monitor/mon_curses.c \
  src/monitor/mon_layout.c \
  src/monitor/mon_ui.c \
  src/monitor/mon_input.c \
  src/monitor/tabs/tab_dash.c
# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

# --- Monitor objects ---
# sort() entfernt Duplikate (MONITOR_SRC enthält absichtlich/versehentlich doppelte Einträge)
MONITOR_OBJ := $(sort $(patsubst %.c,$(BUILD_DIR)/%.o,$(MONITOR_SRC)))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/monitor

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor
# ---------------------------------------------------------------------------
$(BUILD_DIR)/%.o: %.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS) $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service wrapper): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor (sudo/root): $(MONITOR_BIN)"
	@$(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"
	@echo "  BIN_DIR = $(BIN_DIR)"
	@echo "  BUILD_DIR = $(BUILD_DIR)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make abi-ct     Compile-only ABI gate"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld (destroy->init->boot wrapper)"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0 heartbeats"
	@echo "  make monitor    Build monitor (ncurses/curses)"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-boot     Run clboot"
	@echo "  make run-cld      Run cld (service boot path)"
	@echo "  make run-monitor  Run monitor"


<<< END FILE: ./.nfs.81626f5f.533d4.4

>>> START FILE: ./.nfs.817dcc22.081d4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI: ncurses)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude -Isrc/monitor

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Monitor (ncurses/curses)
# ---------------------------------------------------------------------------
# OS-spezifische curses lib:
#   Linux:   -lncurses
#   BSD:     -lncurses (typisch) — override möglich
#   OmniOS:  -lcurses  (illumos)
#
# WICHTIG: MONITOR_LDLIBS darf NICHT per "?=" in den OS-Branches gesetzt werden,
# weil MONITOR_LDLIBS bereits definiert (ggf. leer) ist. Daher: "=" in Branches.
MONITOR_LDLIBS ?=

ifeq ($(OS),linux)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS = -lcurses
endif

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

# --- Monitor sources (SSOT UI – bring-up, minimal) ---
# Wichtig: Nur die neuen Minimal-Dateien linken (kein Legacy-Monitor-Stack).
MONITOR_SRC := \
  src/monitor/monitor_main.c \
  src/monitor/monitor_curses.c \
  src/monitor/monitor_state.c \
  src/monitor/monitor_keymap.c \
  src/monitor/monitor_draw.c \
  src/monitor/monitor_draw_helpers.c \
  src/monitor/tabs/tab_dashboard.c

# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

# --- Monitor objects ---
# sort() entfernt Duplikate (MONITOR_SRC enthält absichtlich/versehentlich doppelte Einträge)
MONITOR_OBJ := $(sort $(patsubst %.c,$(BUILD_DIR)/%.o,$(MONITOR_SRC)))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/monitor

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor
# ---------------------------------------------------------------------------
$(BUILD_DIR)/%.o: %.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS) $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service wrapper): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor (sudo/root): $(MONITOR_BIN)"
	@$(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"
	@echo "  BIN_DIR = $(BIN_DIR)"
	@echo "  BUILD_DIR = $(BUILD_DIR)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make abi-ct     Compile-only ABI gate"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld (destroy->init->boot wrapper)"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0 heartbeats"
	@echo "  make monitor    Build monitor (ncurses/curses)"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-boot     Run clboot"
	@echo "  make run-cld      Run cld (service boot path)"
	@echo "  make run-monitor  Run monitor"


<<< END FILE: ./.nfs.817dcc22.081d4.4

>>> START FILE: ./.nfs.817ddd81.081d4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI: ncurses)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Monitor (ncurses/curses)
# ---------------------------------------------------------------------------
# OS-spezifische curses lib:
#   Linux:   -lncurses
#   BSD:     -lncurses (typisch) — override möglich
#   OmniOS:  -lcurses  (illumos)
#
# WICHTIG: MONITOR_LDLIBS darf NICHT per "?=" in den OS-Branches gesetzt werden,
# weil MONITOR_LDLIBS bereits definiert (ggf. leer) ist. Daher: "=" in Branches.
MONITOR_LDLIBS ?=

ifeq ($(OS),linux)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS = -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS = -lcurses
endif

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

# --- Monitor sources (SSOT UI) ---
MONITOR_SRC := \
  src/monitor/monitor.c \
  src/monitor/mon_curses.c \
  src/monitor/mon_layout.c \
  src/monitor/mon_ui.c \
  src/monitor/mon_input.c \
  src/monitor/tabs/tab_dash.c
  
# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

# --- Monitor objects ---
# sort() entfernt Duplikate (MONITOR_SRC enthält absichtlich/versehentlich doppelte Einträge)
MONITOR_OBJ := $(sort $(patsubst %.c,$(BUILD_DIR)/%.o,$(MONITOR_SRC)))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/monitor

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor
# ---------------------------------------------------------------------------
$(BUILD_DIR)/%.o: %.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS) $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service wrapper): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor (sudo/root): $(MONITOR_BIN)"
	@$(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"
	@echo "  BIN_DIR = $(BIN_DIR)"
	@echo "  BUILD_DIR = $(BUILD_DIR)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make abi-ct     Compile-only ABI gate"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld (destroy->init->boot wrapper)"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0 heartbeats"
	@echo "  make monitor    Build monitor (ncurses/curses)"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-boot     Run clboot"
	@echo "  make run-cld      Run cld (service boot path)"
	@echo "  make run-monitor  Run monitor"


<<< END FILE: ./.nfs.817ddd81.081d4.4

>>> START FILE: ./.nfs.818494ad.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.818494ad.5aaa4.4

>>> START FILE: ./.nfs.818e88d5.5aaa4.4
# ============================================================================
# CommanderLink – Master Makefile (SSOT)
# ============================================================================
# Targets:
#   make all        -> Baut Tools, Monitor und Stubs
#   make monitor    -> Baut nur den Monitor (ncurses)
#   make abi        -> Baut den ABI Report (Truth Meter)
#   make clean      -> Räumt auf
# ============================================================================

# --- 1. OS Detection ---
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  # Auf OmniOS/illumos oft -lcurses oder -lncurses, Pfade beachten
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
endif

# --- 2. Toolchain Config ---
CC      ?= cc
OPT     ?= -O2
CSTD    ?= -std=c11
WARN    ?= -Wall -Wextra -Wpedantic
DEFS    ?= -D_POSIX_C_SOURCE=200809L
INCS    ?= -Iinclude

CFLAGS  := $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS := $(LDFLAGS_OS)

# Output Paths
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# --- 3. Sources & Objects Definition ---

# A) TOOLS: ABI Report
ABI_SRC   := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ   := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN   := $(BIN_DIR)/cl_abi_report

# B) TOOLS: Dummy SHM (für Monitor-Test ohne Kernel)
DUMMY_SRC := tools/cl_dummy_shm/cl_dummy_shm.c
DUMMY_OBJ := $(BUILD_DIR)/tools/cl_dummy_shm/cl_dummy_shm.o
DUMMY_BIN := $(BIN_DIR)/cl_dummy_shm

# C) MONITOR (Die Exekutive)
MONITOR_SRC := src/monitor/monitor.c \
               src/monitor/monitor_ui.c \
               src/monitor/tabs/tab_dashboard.c
# Automatische Umwandlung .c -> .o im Build-Dir
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/cl_monitor

# D) SYSTEM (Core/Hal/Link/Flow Stubs) - Optional für Full Build
CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

# --- 4. Main Targets ---

.PHONY: all clean vars monitor abi dummy help

all: abi dummy monitor
	@echo "Basic toolset ready."

monitor: $(MONITOR_BIN)
abi:     $(ABI_BIN)
dummy:   $(DUMMY_BIN)

# --- 5. Build Rules ---

# --- MONITOR LINKING ---
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# --- TOOLS LINKING ---
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(DUMMY_BIN): $(DUMMY_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ -lrt $(LDFLAGS)

# --- GENERIC COMPILATION RULES ---

# Rule für src/monitor/*.c
$(BUILD_DIR)/src/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Rule für tools/*.c
$(BUILD_DIR)/tools/%.o: tools/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# --- 6. Helper ---

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf build bin

vars:
	@echo "OS:       $(OS)"
	@echo "CC:       $(CC)"
	@echo "CFLAGS:   $(CFLAGS)"
	@echo "CURSES:   $(LIBCURSES)"
	@echo "MONITOR:  $(MONITOR_BIN)"

help:
	@echo "CommanderLink Build System"
	@echo "  make monitor   -> Build visual monitor"
	@echo "  make dummy     -> Build dummy SHM generator"
	@echo "  make abi       -> Build ABI validator"
	@echo "  make all       -> Build everything"

<<< END FILE: ./.nfs.818e88d5.5aaa4.4

>>> START FILE: ./.nfs.818ea65e.5aaa4.4
# ============================================================================
# CommanderLink – Master Makefile (SSOT)
# ============================================================================
# Targets:
#   make all        -> Baut Tools, Monitor und Stubs
#   make monitor    -> Baut nur den Monitor (ncurses)
#   make abi        -> Baut den ABI Report (Truth Meter)
#   make clean      -> Räumt auf
# ============================================================================

# --- 1. OS Detection ---
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  # Auf OmniOS/illumos oft -lcurses oder -lncurses, Pfade beachten
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
endif

# --- 2. Toolchain Config ---
CC      ?= cc
OPT     ?= -O2
CSTD    ?= -std=c11
WARN    ?= -Wall -Wextra -Wpedantic
DEFS    ?= -D_POSIX_C_SOURCE=200809L
INCS    ?= -Iinclude

CFLAGS  := $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS := $(LDFLAGS_OS)

# Output Paths
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# --- 3. Sources & Objects Definition ---

# A) TOOLS: ABI Report
ABI_SRC   := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ   := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN   := $(BIN_DIR)/cl_abi_report

# B) TOOLS: Dummy SHM (für Monitor-Test ohne Kernel)
DUMMY_SRC := tools/cl_dummy_shm/cl_dummy_shm.c
DUMMY_OBJ := $(BUILD_DIR)/tools/cl_dummy_shm/cl_dummy_shm.o
DUMMY_BIN := $(BIN_DIR)/cl_dummy_shm

# C) MONITOR (Die Exekutive)
MONITOR_SRC = src/monitor/monitor.c \
              src/monitor/monitor_ui.c \
              src/monitor/monitor_state.c \
              src/monitor/monitor_input.c \
              src/monitor/tabs/tab_dashboard.c
              
# Automatische Umwandlung .c -> .o im Build-Dir
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/cl_monitor

# D) SYSTEM (Core/Hal/Link/Flow Stubs) - Optional für Full Build
CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

# --- 4. Main Targets ---

.PHONY: all clean vars monitor abi dummy help

all: abi dummy monitor
	@echo "Basic toolset ready."

monitor: $(MONITOR_BIN)
abi:     $(ABI_BIN)
dummy:   $(DUMMY_BIN)

# --- 5. Build Rules ---

# --- MONITOR LINKING ---
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# --- TOOLS LINKING ---
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(DUMMY_BIN): $(DUMMY_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ -lrt $(LDFLAGS)

# --- GENERIC COMPILATION RULES ---

# Rule für src/monitor/*.c
$(BUILD_DIR)/src/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Rule für tools/*.c
$(BUILD_DIR)/tools/%.o: tools/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# --- 6. Helper ---

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf build bin

vars:
	@echo "OS:       $(OS)"
	@echo "CC:       $(CC)"
	@echo "CFLAGS:   $(CFLAGS)"
	@echo "CURSES:   $(LIBCURSES)"
	@echo "MONITOR:  $(MONITOR_BIN)"

help:
	@echo "CommanderLink Build System"
	@echo "  make monitor   -> Build visual monitor"
	@echo "  make dummy     -> Build dummy SHM generator"
	@echo "  make abi       -> Build ABI validator"
	@echo "  make all       -> Build everything"

<<< END FILE: ./.nfs.818ea65e.5aaa4.4

>>> START FILE: ./.nfs.819ee2b4.5aaa4.4
# ============================================================================
# CommanderLink – Master Makefile (SSOT)
# ============================================================================
# Targets:
#   make all        -> Baut Tools, Monitor und Stubs
#   make monitor    -> Baut nur den Monitor (ncurses)
#   make abi        -> Baut den ABI Report (Truth Meter)
#   make clean      -> Räumt auf
# ============================================================================

# --- 1. OS Detection ---
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  # Auf OmniOS/illumos oft -lcurses oder -lncurses, Pfade beachten
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
endif

# --- 2. Toolchain Config ---
CC      ?= cc
OPT     ?= -O2
CSTD    ?= -std=c11
WARN    ?= -Wall -Wextra -Wpedantic
DEFS    ?= -D_POSIX_C_SOURCE=200809L
INCS    ?= -Iinclude

CFLAGS  := $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS := $(LDFLAGS_OS)

# Output Paths
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# --- 3. Sources & Objects Definition ---

# A) TOOLS: ABI Report
ABI_SRC   := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ   := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN   := $(BIN_DIR)/cl_abi_report

# B) TOOLS: Dummy SHM (für Monitor-Test ohne Kernel)
DUMMY_SRC := tools/cl_dummy_shm/cl_dummy_shm.c
DUMMY_OBJ := $(BUILD_DIR)/tools/cl_dummy_shm/cl_dummy_shm.o
DUMMY_BIN := $(BIN_DIR)/cl_dummy_shm

# C) MONITOR (Die Exekutive)
MONITOR_SRC = src/monitor/monitor.c \
              src/monitor/monitor_ui.c \
              src/monitor/monitor_state.c \
              src/monitor/monitor_input.c \
              src/monitor/tabs/tab_dashboard.c
              
# Automatische Umwandlung .c -> .o im Build-Dir
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/monitor

# D) SYSTEM (Core/Hal/Link/Flow Stubs) - Optional für Full Build
CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

# --- 4. Main Targets ---

.PHONY: all clean vars monitor abi dummy help

all: abi dummy monitor
	@echo "Basic toolset ready."

monitor: $(MONITOR_BIN)
abi:     $(ABI_BIN)
dummy:   $(DUMMY_BIN)

# --- 5. Build Rules ---

# --- MONITOR LINKING ---
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# --- TOOLS LINKING ---
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(DUMMY_BIN): $(DUMMY_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ -lrt $(LDFLAGS)

# --- GENERIC COMPILATION RULES ---

# Rule für src/monitor/*.c
$(BUILD_DIR)/src/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Rule für tools/*.c
$(BUILD_DIR)/tools/%.o: tools/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# --- 6. Helper ---

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf build bin

vars:
	@echo "OS:       $(OS)"
	@echo "CC:       $(CC)"
	@echo "CFLAGS:   $(CFLAGS)"
	@echo "CURSES:   $(LIBCURSES)"
	@echo "MONITOR:  $(MONITOR_BIN)"

help:
	@echo "CommanderLink Build System"
	@echo "  make monitor   -> Build visual monitor"
	@echo "  make dummy     -> Build dummy SHM generator"
	@echo "  make abi       -> Build ABI validator"
	@echo "  make all       -> Build everything"

<<< END FILE: ./.nfs.819ee2b4.5aaa4.4

>>> START FILE: ./.nfs.819ef8e4.5aaa4.4
# ============================================================================
# CommanderLink – Master Makefile (SSOT)
# ============================================================================
# Targets:
#   make all        -> Baut Tools, Monitor und Stubs
#   make monitor    -> Baut nur den Monitor (ncurses)
#   make abi        -> Baut den ABI Report (Truth Meter)
#   make clean      -> Räumt auf
# ============================================================================

# --- 1. OS Detection ---
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  # Auf OmniOS/illumos oft -lcurses oder -lncurses, Pfade beachten
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
endif

# --- 2. Toolchain Config ---
CC      ?= cc
OPT     ?= -O2
CSTD    ?= -std=c11
WARN    ?= -Wall -Wextra -Wpedantic
DEFS    ?= -D_POSIX_C_SOURCE=200809L
INCS    ?= -Iinclude

CFLAGS  := $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS := $(LDFLAGS_OS)

# Output Paths
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# --- 3. Sources & Objects Definition ---

# A) TOOLS: ABI Report
ABI_SRC   := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ   := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN   := $(BIN_DIR)/cl_abi_report

# B) TOOLS: Dummy SHM (für Monitor-Test ohne Kernel)
DUMMY_SRC := tools/cl_dummy_shm/cl_dummy_shm.c
DUMMY_OBJ := $(BUILD_DIR)/tools/cl_dummy_shm/cl_dummy_shm.o
DUMMY_BIN := $(BIN_DIR)/cl_dummy_shm

# C) MONITOR (Die Exekutive)
MONITOR_SRC = src/monitor/monitor.c \
              src/monitor/monitor_ui.c \
              src/monitor/monitor_state.c \
              src/monitor/monitor_input.c \
              src/monitor/tabs/tab_dashboard.c
              
# Automatische Umwandlung .c -> .o im Build-Dir
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/monitor

# D) SYSTEM (Core/Hal/Link/Flow Stubs) - Optional für Full Build
CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

# --- 4. Main Targets ---

.PHONY: all clean vars monitor abi help

all: abi dummy monitor
	@echo "Basic toolset ready."

monitor: $(MONITOR_BIN)
abi:     $(ABI_BIN)
dummy:   $(DUMMY_BIN)

# --- 5. Build Rules ---

# --- MONITOR LINKING ---
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# --- TOOLS LINKING ---
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(DUMMY_BIN): $(DUMMY_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ -lrt $(LDFLAGS)

# --- GENERIC COMPILATION RULES ---

# Rule für src/monitor/*.c
$(BUILD_DIR)/src/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Rule für tools/*.c
$(BUILD_DIR)/tools/%.o: tools/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# --- 6. Helper ---

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf build bin

vars:
	@echo "OS:       $(OS)"
	@echo "CC:       $(CC)"
	@echo "CFLAGS:   $(CFLAGS)"
	@echo "CURSES:   $(LIBCURSES)"
	@echo "MONITOR:  $(MONITOR_BIN)"

help:
	@echo "CommanderLink Build System"
	@echo "  make monitor   -> Build visual monitor"
	@echo "  make dummy     -> Build dummy SHM generator"
	@echo "  make abi       -> Build ABI validator"
	@echo "  make all       -> Build everything"

<<< END FILE: ./.nfs.819ef8e4.5aaa4.4

>>> START FILE: ./.nfs.819f1274.5aaa4.4
# ============================================================================
# CommanderLink – Master Makefile (SSOT)
# ============================================================================
# Targets:
#   make all        -> Baut Tools, Monitor und Stubs
#   make monitor    -> Baut nur den Monitor (ncurses)
#   make abi        -> Baut den ABI Report (Truth Meter)
#   make clean      -> Räumt auf
# ============================================================================

# --- 1. OS Detection ---
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  # Auf OmniOS/illumos oft -lcurses oder -lncurses, Pfade beachten
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
endif

# --- 2. Toolchain Config ---
CC      ?= cc
OPT     ?= -O2
CSTD    ?= -std=c11
WARN    ?= -Wall -Wextra -Wpedantic
DEFS    ?= -D_POSIX_C_SOURCE=200809L
INCS    ?= -Iinclude

CFLAGS  := $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS := $(LDFLAGS_OS)

# Output Paths
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# --- 3. Sources & Objects Definition ---

# A) TOOLS: ABI Report
ABI_SRC   := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ   := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN   := $(BIN_DIR)/cl_abi_report

# B) TOOLS: Dummy SHM (für Monitor-Test ohne Kernel)
DUMMY_SRC := tools/cl_dummy_shm/cl_dummy_shm.c
DUMMY_OBJ := $(BUILD_DIR)/tools/cl_dummy_shm/cl_dummy_shm.o
DUMMY_BIN := $(BIN_DIR)/cl_dummy_shm

# C) MONITOR (Die Exekutive)
MONITOR_SRC = src/monitor/monitor.c \
              src/monitor/monitor_ui.c \
              src/monitor/monitor_state.c \
              src/monitor/monitor_input.c \
              src/monitor/tabs/tab_dashboard.c
              
# Automatische Umwandlung .c -> .o im Build-Dir
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/monitor

# D) SYSTEM (Core/Hal/Link/Flow Stubs) - Optional für Full Build
CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

# --- 4. Main Targets ---

.PHONY: all clean vars monitor abi help

all: abi monitor
	@echo "Basic toolset ready."

monitor: $(MONITOR_BIN)
abi:     $(ABI_BIN)
dummy:   $(DUMMY_BIN)

# --- 5. Build Rules ---

# --- MONITOR LINKING ---
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# --- TOOLS LINKING ---
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(DUMMY_BIN): $(DUMMY_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ -lrt $(LDFLAGS)

# --- GENERIC COMPILATION RULES ---

# Rule für src/monitor/*.c
$(BUILD_DIR)/src/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Rule für tools/*.c
$(BUILD_DIR)/tools/%.o: tools/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# --- 6. Helper ---

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf build bin

vars:
	@echo "OS:       $(OS)"
	@echo "CC:       $(CC)"
	@echo "CFLAGS:   $(CFLAGS)"
	@echo "CURSES:   $(LIBCURSES)"
	@echo "MONITOR:  $(MONITOR_BIN)"

help:
	@echo "CommanderLink Build System"
	@echo "  make monitor   -> Build visual monitor"
	@echo "  make dummy     -> Build dummy SHM generator"
	@echo "  make abi       -> Build ABI validator"
	@echo "  make all       -> Build everything"

<<< END FILE: ./.nfs.819f1274.5aaa4.4

>>> START FILE: ./.nfs.81a0a8d7.61884.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81a0a8d7.61884.4

>>> START FILE: ./.nfs.81a0eb27.61884.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81a0eb27.61884.4

>>> START FILE: ./.nfs.81a49dab.61884.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81a49dab.61884.4

>>> START FILE: ./.nfs.81b2cd1c.66e54.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette + Monitor)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/monitor/cl_monitor   (TUI Dashboard)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
# ============================================================================

UNAME_S := $(shell uname -s)

# --- OS Detection & Libraries ---
ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lrt
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS :=
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
  LDFLAGS_OS :=
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?= $(LDFLAGS_OS)

# --- Directories ---
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# ---------------------------------------------------------------------------
# DEFINITIONS: Sources & Objects
# ---------------------------------------------------------------------------

# 1) ABI Report
ABI_SRC := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN := $(BIN_DIR)/cl_abi_report

# 2) CLINIT
CLINIT_SRC := src/clinit/clinit.c
CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLINIT_BIN := $(BIN_DIR)/clinit

# 3) CLBOOT
CLBOOT_SRC := src/clboot/clboot.c
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLBOOT_BIN := $(BIN_DIR)/clboot

# 4) CLD
CLD_SRC := src/cld/cld.c
CLD_OBJ := $(BUILD_DIR)/src/cld/cld.o
CLD_BIN := $(BIN_DIR)/cld

# 5) MONITOR (NEU)
MONITOR_SRC := src/monitor/monitor.c \
               src/monitor/monitor_ui.c \
               src/monitor/monitor_state.c \
               src/monitor/monitor_input.c \
               src/monitor/tabs/tab_dashboard.c

# Generische Umwandlung src/monitor/*.c -> build/.../src/monitor/*.o
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/cl_monitor

# 6) STUBS
CORE_SRC   := src/core/core0.c
CORE_OBJ   := $(BUILD_DIR)/src/core/core0.o
CORE_BIN   := $(BIN_DIR)/core0

HAL_SRC    := src/hal/hal0.c
HAL_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
HAL_BIN    := $(BIN_DIR)/hal0

LINK_SRC   := src/link/link0.c
LINK_OBJ   := $(BUILD_DIR)/src/link/link0.o
LINK_BIN   := $(BIN_DIR)/link0

FLOW_SRC   := src/flow/flow0.c
FLOW_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
FLOW_BIN   := $(BIN_DIR)/flow0

ORACLE_SRC := src/oracle/oracle0.c
ORACLE_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o
ORACLE_BIN := $(BIN_DIR)/oracle0


# ---------------------------------------------------------------------------
# TARGETS
# ---------------------------------------------------------------------------

.PHONY: all clean print-vars help abi clinit clboot cld stubs monitor

all: abi clinit clboot cld stubs monitor

abi:     $(ABI_BIN)
clinit:  $(CLINIT_BIN)
clboot:  $(CLBOOT_BIN)
cld:     $(CLD_BIN)
monitor: $(MONITOR_BIN)
stubs:   $(CORE_BIN) $(HAL_BIN) $(LINK_BIN) $(FLOW_BIN) $(ORACLE_BIN)

abi-ct: $(ABI_OBJ)
	@echo "ABI Check tool compiled only."

# ---------------------------------------------------------------------------
# RULES: Linking
# ---------------------------------------------------------------------------

# ABI
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# CLINIT
$(CLINIT_BIN): $(CLINIT_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# CLBOOT
$(CLBOOT_BIN): $(CLBOOT_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# CLD
$(CLD_BIN): $(CLD_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# MONITOR (Braucht ncurses)
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# STUBS
$(CORE_BIN): $(CORE_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(HAL_BIN): $(HAL_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(LINK_BIN): $(LINK_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(FLOW_BIN): $(FLOW_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(ORACLE_BIN): $(ORACLE_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# ---------------------------------------------------------------------------
# RULES: Compiling
# ---------------------------------------------------------------------------

# Tools
$(BUILD_DIR)/tools/cl_abi_report/%.o: tools/cl_abi_report/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Clinit
$(BUILD_DIR)/src/clinit/%.o: src/clinit/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Clboot
$(BUILD_DIR)/src/clboot/%.o: src/clboot/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Cld
$(BUILD_DIR)/src/cld/%.o: src/cld/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Monitor (Base)
$(BUILD_DIR)/src/monitor/%.o: src/monitor/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Monitor (Tabs)
$(BUILD_DIR)/src/monitor/tabs/%.o: src/monitor/tabs/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Stubs
$(BUILD_DIR)/src/core/%.o: src/core/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/hal/%.o: src/hal/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/link/%.o: src/link/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/flow/%.o: src/flow/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/oracle/%.o: src/oracle/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  LIBCURSES = $(LIBCURSES)"
	@echo "  BIN_DIR = $(BIN_DIR)"

<<< END FILE: ./.nfs.81b2cd1c.66e54.4

>>> START FILE: ./.nfs.81daded4.6f534.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81daded4.6f534.4

>>> START FILE: ./.nfs.81dbb6a4.6f534.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81dbb6a4.6f534.4

>>> START FILE: ./.nfs.81dbfbec.6f534.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81dbfbec.6f534.4

>>> START FILE: ./.nfs.81de4be0.6f534.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81de4be0.6f534.4

>>> START FILE: ./.nfs.81e67082.6f534.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81e67082.6f534.4

>>> START FILE: ./.nfs.81eb6f66.6f534.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81eb6f66.6f534.4

>>> START FILE: ./.nfs.81f60fa2.081d4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette + Monitor)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/monitor/cl_monitor   (TUI Dashboard)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
# ============================================================================

UNAME_S := $(shell uname -s)

# --- OS Detection & Libraries ---
ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lrt
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS :=
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
  LDFLAGS_OS :=
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?= $(LDFLAGS_OS)

# --- Directories ---
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# ---------------------------------------------------------------------------
# DEFINITIONS: Sources & Objects
# ---------------------------------------------------------------------------

# 1) ABI Report
ABI_SRC := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN := $(BIN_DIR)/cl_abi_report

# 2) CLINIT
CLINIT_SRC := src/clinit/clinit.c
CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLINIT_BIN := $(BIN_DIR)/clinit

# 3) CLBOOT
CLBOOT_SRC := src/clboot/clboot.c
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLBOOT_BIN := $(BIN_DIR)/clboot

# 4) CLD
CLD_SRC := src/cld/cld.c
CLD_OBJ := $(BUILD_DIR)/src/cld/cld.o
CLD_BIN := $(BIN_DIR)/cld

# 5) MONITOR (NEU)
MONITOR_SRC := src/monitor/monitor.c \
               src/monitor/monitor_ui.c \
               src/monitor/monitor_state.c \
               src/monitor/monitor_input.c \
               src/monitor/tabs/tab_dashboard.c

# Generische Umwandlung src/monitor/*.c -> build/.../src/monitor/*.o
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/monitor

# 6) STUBS
CORE_SRC   := src/core/core0.c
CORE_OBJ   := $(BUILD_DIR)/src/core/core0.o
CORE_BIN   := $(BIN_DIR)/core0

HAL_SRC    := src/hal/hal0.c
HAL_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
HAL_BIN    := $(BIN_DIR)/hal0

LINK_SRC   := src/link/link0.c
LINK_OBJ   := $(BUILD_DIR)/src/link/link0.o
LINK_BIN   := $(BIN_DIR)/link0

FLOW_SRC   := src/flow/flow0.c
FLOW_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
FLOW_BIN   := $(BIN_DIR)/flow0

ORACLE_SRC := src/oracle/oracle0.c
ORACLE_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o
ORACLE_BIN := $(BIN_DIR)/oracle0


# ---------------------------------------------------------------------------
# TARGETS
# ---------------------------------------------------------------------------

.PHONY: all clean print-vars help abi clinit clboot cld stubs monitor

all: abi clinit clboot cld stubs monitor

abi:     $(ABI_BIN)
clinit:  $(CLINIT_BIN)
clboot:  $(CLBOOT_BIN)
cld:     $(CLD_BIN)
monitor: $(MONITOR_BIN)
stubs:   $(CORE_BIN) $(HAL_BIN) $(LINK_BIN) $(FLOW_BIN) $(ORACLE_BIN)

abi-ct: $(ABI_OBJ)
	@echo "ABI Check tool compiled only."

# ---------------------------------------------------------------------------
# RULES: Linking
# ---------------------------------------------------------------------------

# ABI
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# CLINIT
$(CLINIT_BIN): $(CLINIT_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# CLBOOT
$(CLBOOT_BIN): $(CLBOOT_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# CLD
$(CLD_BIN): $(CLD_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# MONITOR (Braucht ncurses)
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# STUBS
$(CORE_BIN): $(CORE_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(HAL_BIN): $(HAL_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(LINK_BIN): $(LINK_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(FLOW_BIN): $(FLOW_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(ORACLE_BIN): $(ORACLE_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# ---------------------------------------------------------------------------
# RULES: Compiling
# ---------------------------------------------------------------------------

# Tools
$(BUILD_DIR)/tools/cl_abi_report/%.o: tools/cl_abi_report/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Clinit
$(BUILD_DIR)/src/clinit/%.o: src/clinit/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Clboot
$(BUILD_DIR)/src/clboot/%.o: src/clboot/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Cld
$(BUILD_DIR)/src/cld/%.o: src/cld/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Monitor (Base)
$(BUILD_DIR)/src/monitor/%.o: src/monitor/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Monitor (Tabs)
$(BUILD_DIR)/src/monitor/tabs/%.o: src/monitor/tabs/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Src - Stubs
$(BUILD_DIR)/src/core/%.o: src/core/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/hal/%.o: src/hal/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/link/%.o: src/link/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/flow/%.o: src/flow/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/src/oracle/%.o: src/oracle/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S = $(UNAME_S)"
	@echo "  OS      = $(OS)"
	@echo "  CC      = $(CC)"
	@echo "  CFLAGS  = $(CFLAGS)"
	@echo "  LIBCURSES = $(LIBCURSES)"
	@echo "  BIN_DIR = $(BIN_DIR)"

<<< END FILE: ./.nfs.81f60fa2.081d4.4

>>> START FILE: ./.nfs.81f62280.081d4.4
# ============================================================================
# CommanderLink – Master Makefile (SSOT)
# ============================================================================
# Targets:
#   make all        -> Baut Tools, Monitor und Stubs
#   make monitor    -> Baut nur den Monitor (ncurses)
#   make abi        -> Baut den ABI Report (Truth Meter)
#   make clean      -> Räumt auf
# ============================================================================

# --- 1. OS Detection ---
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncurses
  LDFLAGS_OS := 
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  # Auf OmniOS/illumos oft -lcurses oder -lncurses, Pfade beachten
  LIBCURSES := -lncurses
  LDFLAGS_OS := -lsocket -lnsl
else
  OS := unknown
  LIBCURSES := -lncurses
endif

# --- 2. Toolchain Config ---
CC      ?= cc
OPT     ?= -O2
CSTD    ?= -std=c11
WARN    ?= -Wall -Wextra -Wpedantic
DEFS    ?= -D_POSIX_C_SOURCE=200809L
INCS    ?= -Iinclude

CFLAGS  := $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS := $(LDFLAGS_OS)

# Output Paths
BIN_DIR   := bin/$(OS)
BUILD_DIR := build/$(OS)

# --- 3. Sources & Objects Definition ---

# A) TOOLS: ABI Report
ABI_SRC   := tools/cl_abi_report/cl_abi_report.c
ABI_OBJ   := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o
ABI_BIN   := $(BIN_DIR)/cl_abi_report

# B) TOOLS: Dummy SHM (für Monitor-Test ohne Kernel)
DUMMY_SRC := tools/cl_dummy_shm/cl_dummy_shm.c
DUMMY_OBJ := $(BUILD_DIR)/tools/cl_dummy_shm/cl_dummy_shm.o
DUMMY_BIN := $(BIN_DIR)/cl_dummy_shm

# C) MONITOR (Die Exekutive)
MONITOR_SRC = src/monitor/monitor.c \
              src/monitor/monitor_ui.c \
              src/monitor/monitor_state.c \
              src/monitor/monitor_input.c \
              src/monitor/tabs/tab_dashboard.c
              
# Automatische Umwandlung .c -> .o im Build-Dir
MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))
MONITOR_BIN := $(BIN_DIR)/monitor

# D) SYSTEM (Core/Hal/Link/Flow Stubs) - Optional für Full Build
CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

# --- 4. Main Targets ---

.PHONY: all clean vars monitor abi help

all: abi monitor cld
	@echo "Basic toolset ready."

monitor: $(MONITOR_BIN)
abi:     $(ABI_BIN)
dummy:   $(DUMMY_BIN)

# --- 5. Build Rules ---

# --- MONITOR LINKING ---
$(MONITOR_BIN): $(MONITOR_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LIBCURSES) $(LDFLAGS)

# --- TOOLS LINKING ---
$(ABI_BIN): $(ABI_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(DUMMY_BIN): $(DUMMY_OBJ)
	@mkdir -p $(dir $@)
	@echo "LINK    $@"
	@$(CC) $(CFLAGS) -o $@ $^ -lrt $(LDFLAGS)

# --- GENERIC COMPILATION RULES ---

# Rule für src/monitor/*.c
$(BUILD_DIR)/src/%.o: src/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Rule für tools/*.c
$(BUILD_DIR)/tools/%.o: tools/%.c
	@mkdir -p $(dir $@)
	@echo "CC      $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# --- 6. Helper ---

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf build bin

vars:
	@echo "OS:       $(OS)"
	@echo "CC:       $(CC)"
	@echo "CFLAGS:   $(CFLAGS)"
	@echo "CURSES:   $(LIBCURSES)"
	@echo "MONITOR:  $(MONITOR_BIN)"

help:
	@echo "CommanderLink Build System"
	@echo "  make monitor   -> Build visual monitor"
	@echo "  make dummy     -> Build dummy SHM generator"
	@echo "  make abi       -> Build ABI validator"
	@echo "  make all       -> Build everything"

<<< END FILE: ./.nfs.81f62280.081d4.4

>>> START FILE: ./.nfs.81f79b50.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81f79b50.75fb4.4

>>> START FILE: ./.nfs.81faa63c.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81faa63c.75fb4.4

>>> START FILE: ./.nfs.81fb0cd4.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81fb0cd4.75fb4.4

>>> START FILE: ./.nfs.81fdbb28.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81fdbb28.75fb4.4

>>> START FILE: ./.nfs.81fe21c7.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.81fe21c7.75fb4.4

>>> START FILE: ./.nfs.823f1438.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.823f1438.75fb4.4

>>> START FILE: ./.nfs.823f6169.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.823f6169.75fb4.4

>>> START FILE: ./.nfs.823f9c3c.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.823f9c3c.75fb4.4

>>> START FILE: ./.nfs.8241688c.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8241688c.75fb4.4

>>> START FILE: ./.nfs.8241a1fc.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8241a1fc.75fb4.4

>>> START FILE: ./.nfs.8241bfa8.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8241bfa8.75fb4.4

>>> START FILE: ./.nfs.8242c97a.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8242c97a.75fb4.4

>>> START FILE: ./.nfs.8243fc24.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8243fc24.75fb4.4

>>> START FILE: ./.nfs.824400c7.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.824400c7.75fb4.4

>>> START FILE: ./.nfs.8255d539.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8255d539.75fb4.4

>>> START FILE: ./.nfs.82560a18.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.82560a18.75fb4.4

>>> START FILE: ./.nfs.82562c91.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.82562c91.75fb4.4

>>> START FILE: ./.nfs.82563421.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.82563421.75fb4.4

>>> START FILE: ./.nfs.8256f306.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.8256f306.75fb4.4

>>> START FILE: ./.nfs.82582300.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.82582300.75fb4.4

>>> START FILE: ./.nfs.825830ec.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./.nfs.825830ec.75fb4.4

>>> START FILE: ./.nfs.82bd2602.081d4.4
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI, read-only; run with sudo in dev)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

MONITOR_SRC := src/monitor/monitor.c \
               src/monitor/monitor_ui.c \
               src/monitor/monitor_state.c \
               src/monitor/monitor_input.c \
               src/monitor/tabs/tab_dashboard.c
# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

MONITOR_OBJ := $(BUILD_DIR)/src/monitor/monitor.o

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/cl_monitor

# ---------------------------------------------------------------------------
# Monitor link libs (OS-spezifisch, override möglich)
# ---------------------------------------------------------------------------
MONITOR_LDLIBS ?=
ifeq ($(OS),linux)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS ?= -lcurses
endif

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor

# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor (SSOT UI)
# ---------------------------------------------------------------------------
$(MONITOR_OBJ): $(MONITOR_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(MONITOR_LDLIBS)

monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service boot path): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor with sudo: $(MONITOR_BIN)"
	@sudo $(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S    = $(UNAME_S)"
	@echo "  OS         = $(OS)"
	@echo "  CC         = $(CC)"
	@echo "  CFLAGS     = $(CFLAGS)"
	@echo "  BIN_DIR    = $(BIN_DIR)"
	@echo "  BUILD_DIR  = $(BUILD_DIR)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)"

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0"
	@echo "  make monitor    Build cl_monitor"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-cld      Boot via cld (destroy->init->clboot)"
	@echo "  make run-monitor  Run monitor via sudo"
	@echo ""
	@echo "Monitor libs:"
	@echo "  Override with: gmake MONITOR_LDLIBS=-lncursesw monitor"


<<< END FILE: ./.nfs.82bd2602.081d4.4

>>> START FILE: ./bin/bsd/cl_abi_report (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./bin/bsd/cl_abi_report

>>> START FILE: ./bin/bsd/clboot (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./bin/bsd/clboot

>>> START FILE: ./bin/bsd/cld (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./bin/bsd/cld

>>> START FILE: ./bin/bsd/clinit (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./bin/bsd/clinit

>>> START FILE: ./BUILD REQUIREMENTS.md
BUILD_REQUIREMENTS.md
Zweck

Diese Datei definiert die Build- und Laufzeit-Voraussetzungen für CommanderLink (CL) auf den Zielplattformen:

Linux (openSUSE Tumbleweed / Arch)

GhostBSD (FreeBSD-Basis)

OmniOS (illumos)

Grundsatz:
CL wird als Binary ausgeliefert. Externe Libraries werden nur verlangt, wenn sie Host-Requirement sind (z. B. OpenSSL). Kompressionsbibliotheken wie LZ4 werden mitgeliefert/vendored, sofern wir sie verwenden.

1) Gemeinsame Anforderungen (alle Plattformen)
1.1 Toolchain

C-Compiler: GCC oder Clang (C11)

Make: GNU make empfohlen (auf illumos zwingend als gmake)

Standard-Header und libc

1.2 Curses UI (Monitor)

ncurses/curses Development Header + Library

Wegen OS-Unterschieden (Headerpfad / Libraryname) wird ein Wrapper genutzt (z. B. monitor_curses.h), der auf die richtige Include-Variante mappt. ncurses/curses Header-Varianten sind historisch unterschiedlich. 
FreeBSD Handbuchseiten
+1

1.3 Security (Join/Trust paranoid)

OpenSSL ist Host-Requirement für OOB-Auth/Join/Trust.

CL verweigert Join (Default-deny), wenn OpenSSL fehlt oder zu alt ist.

OpenSSL wird nicht vendored (Security-Patch-Pflege bleibt Host-Aufgabe).

2) Linux (openSUSE Tumbleweed / Arch)
2.1 Pflicht (Build)

gcc oder clang

make

pkg-config (optional, aber praktisch)

ncurses dev headers + lib (für Monitor)

libpthread/librt sind Teil der glibc Umgebung (typisch)

Beispiel: openSUSE Tumbleweed
sudo zypper install -t pattern devel_basis
sudo zypper install ncurses-devel

Beispiel: Arch
sudo pacman -S --needed base-devel ncurses

2.2 Optional (Performance Backends)
AF_XDP (BYPASS)

Kernel muss AF_XDP unterstützen; CL nutzt den Kernel-Mechanismus UMEM + XSK rings (SPSC rings) wie in Kernel-Doku beschrieben. 
Kernel-Dokumentation
+2
kernel.org
+2

Optional: libbpf/bpftool nur, wenn ihr XDP-Programme laden wollt (v0.1 kann BYPASS capability-gated sein).

Wichtig: UMEM „chunk size“ beeinflusst Kapazität/Max-Packet-Size; Kernel-Doku beschreibt Chunk-Beziehung. 
Kernel-Dokumentation
+2
kernel.org
+2

3) GhostBSD / FreeBSD

GhostBSD ist FreeBSD-basiert, daher gelten FreeBSD-Manpages und Base-System-Konventionen.

3.1 Pflicht (Build)

Compiler: cc (Clang in Base) oder GCC

make / gmake (je nach Ports)

ncurses/curses: FreeBSD bringt ncursesw in der Base; Header liegt typischerweise unter /usr/include/ncurses.h. 
The FreeBSD Forums
+1

Optionaler Build-Komfort
pkg install gmake

3.2 Optional (Performance Backends)
netmap (BYPASS)

netmap ist ein Framework für sehr schnelles Packet I/O; FreeBSD manpage ist Primärreferenz. 
FreeBSD Handbuchseiten
+1

Wenn netmap genutzt wird, müssen Kernel/Driver dies unterstützen (capability-gated).

4) OmniOS / illumos
4.1 Pflicht (Build)

GCC (OmniOS liefert verschiedene GCC-Packages; Beispiel: gcc14)

GNU make: Paketname ist developer/build/gnu-make (liefert gmake). 
OmniOS
+2
GitHub
+2

System-Header: system/header (für Build-Header; OmniOS nutzt pkg)

Beispiel (OmniOS)
pfexec pkg refresh
pfexec pkg install developer/build/gnu-make
pfexec pkg install library/ncurses
pfexec pkg install system/header


Hinweis: OmniOS Katalog führt developer/build/gnu-make explizit. 
OmniOS
+2
GitHub
+2

4.2 curses/ncurses Besonderheiten

OmniOS kann curses.h statt ncurses.h bereitstellen bzw. symlink-Strukturen nutzen. Deshalb wird weiterhin ein Wrapper-Header verwendet, der die richtige Include-Variante wählt und die korrekte Library (-lcurses oder -lncurses) linkt. 
FreeBSD Handbuchseiten
+1

4.3 Optional (Performance Backends)

OmniOS ist bei BYPASS-Mechanismen konservativer. Für v0.1 ist die Baseline:

UDP (Tier-0)

TCP fallback

netmap ist primär BSD-Ökosystem; OmniOS benötigt eigene Treiberpfade → wird capability-gated und später konkretisiert, wenn Treiber/Kernel-Support belegt ist.

5) Laufzeit-Anforderungen (alle Plattformen)
5.1 Privilegien

CL Daemon läuft als Systemdienst, i. d. R. mit Root/CAP-Äquivalent, weil:

Overlay-Interface (tun) anlegen

Routes setzen (/32 host routes)

ggf. Bypass-Queues initialisieren (capability-gated)

5.2 Ports / Firewall

OOB: UDP/4343

Baseline Data Plane: UDP (intern) + optional TCP fallback

In paranoid join: ohne gültige Auth-OOB wird kein Datenpfad aktiviert.

5.3 Optional: ZFS Visibility

Auf OmniOS und ggf. FreeBSD (OpenZFS) werden ZFS-Daten über OS-Interfaces/Tools gesammelt (z. B. arcstat/zpool). CL benötigt keine Kernel-Hacks; es zeigt den Zustand an.

6) CI / Verifikation (Empfehlung)

Linux + FreeBSD + OmniOS Builds als Pflichtmatrix (Monitor + Dummy-SHM).

ABI-Assertions müssen in jedem Build grün sein (sizeof/offset).

Sobald stabil: -Werror für Monitor-Build aktivieren (Phase-Gate).

<<< END FILE: ./BUILD REQUIREMENTS.md

>>> START FILE: ./build/bsd/src/clboot/clboot.o (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./build/bsd/src/clboot/clboot.o

>>> START FILE: ./build/bsd/src/cld/cld.o (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./build/bsd/src/cld/cld.o

>>> START FILE: ./build/bsd/src/clinit/clinit.o (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./build/bsd/src/clinit/clinit.o

>>> START FILE: ./build/bsd/tools/cl_abi_report/cl_abi_report.o (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./build/bsd/tools/cl_abi_report/cl_abi_report.o

>>> START FILE: ./docs/.nfs.81897eb6.63604.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./docs/.nfs.81897eb6.63604.4

>>> START FILE: ./docs/.nfs.818a45af.63604.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./docs/.nfs.818a45af.63604.4

>>> START FILE: ./docs/ABI_LAYOUT.md
# CommanderLink ABI/Layout-Vertrag (FINAL)

Dieses Dokument ist die **normative ABI-Verfassung** für CommanderLink.  
Es definiert das Speicherlayout, die Größen, die Feldordnung und die Regeln, nach denen Änderungen zulässig sind.

CommanderLink ist **physikgetrieben**: Cacheline-Geometrie, Register-Breiten, deterministische Speicherbewegung.  
Portabilität ist Mittel zum Zweck, nicht Ziel. **Stabilität + Determinismus** sind Ziel.

---

## 1. Grundgesetze

### 1.1 Maximalmodell-Prinzip
- **Das Maximum ist das Minimum.**
- Abwesenheit ist **ein Zustand**, keine Lücke.
- Jedes Feature ist modelliert als:
  - `possible` (kann Hardware/OS prinzipiell?)
  - `effective` (wird aktuell genutzt?)
  - `state` (UNSUPPORTED/DISABLED/IDLE/ACTIVE/UNKNOWN/FAULT)
  - `reason` + `constraint_flags`
  - `source` + `quality`

### 1.2 Zero-Transformation (Standard)
- Im Hot-Path sind **Transformationen verboten**:
  - kein Shift/Rotate/Pack/Shuffle/Repack
  - kein hot memcpy
  - keine Endian-Konvertierung im Hot-Path
- Erlaubt ist nur:
  - `load → compare → store`
- Geometrie (Headroom/Alignment) wird **einmalig im Setup** festgelegt.

### 1.3 Endianness
- SHM ist **Host-Order** (keine ntohl/htonl-Kaskaden).
- Wire/OOB ist **explizit little-endian** (`*_le`) und wird an der Wire-Grenze konvertiert.
- Root enthält `endian_magic` zur Laufzeitprüfung.

### 1.4 Keine `packed`-Layouts im SHM
- `packed` ist in SHM-Segmenten verboten.
- SHM nutzt Cacheline-Unions (`raw[64]`) bzw. Page-Unions (`raw[4096]`).
- Jede Größe wird über `_Static_assert` hart abgesichert.

### 1.5 Atomics
- Atomics sind Sichtbarkeit, nicht Zähler-Müll:
  - **keine Atomics in inneren Paket-Loops**
  - Commit/Updates **pro Batch** (lokal aggregieren, dann 1 atomic add/store)
- Bei `_Atomic`-Felder ist Memory-Order im Code dokumentiert:
  - Hot: i.d.R. relaxed + Release beim Publish, Acquire beim Read
  - Monitor: Acquire

### 1.6 Alignment-Rounding (wichtiger Compiler-Fakt)
- **Wenn ein struct mit großem Alignment (z. B. 1024/4096) versehen wird, kann der Compiler die Gesamtgröße auf ein Vielfaches runden.**
- Darum: Records müssen exakt die Zielgröße treffen, sonst driftet das Layout (z. B. 1024→2048).
- Jede Zielgröße wird mit `_Static_assert(sizeof(...) == N)` erzwungen.

---

## 2. Runtime Kern: Root & TOC

### 2.1 Root (Core-SHM)
- Typ: `cl_root_4096_t` (alias `cl_root_t`)
- Größe: **4096 Bytes**
- Normfläche: `raw[4096]`
- Enthält:
  - Schema-/Endianness-Check (`schema_version`, `endian_magic`)
  - Identitäten (`mesh_tag64`, `node_tag64`)
  - Truth-States (`path_state`, `backend_active`, `mode_active`, `profile_active`)
  - Gates (`rx_gate`, `tx_gate`)
  - Constraints (`constraint_flags`, `reason_code`)
  - TOC pointer (`toc_offset`, `toc_size`)
  - Bulk presence (`bulk_present`, `bulk_epoch`)
- ABI: append-only innerhalb `raw[4096]`

**Runtime-Invariant:**
- Root ist die „Notfall-Wahrheit“. Kein Modul darf Root „interpretieren“, nur lesen/schreiben gemäß Owner-Regeln.

### 2.2 TOC (Table of Contents)
- Typ: `cl_toc_t`
- `cl_toc_entry_t` Größe: **64 Bytes** (Cacheline)
- `CL_TOC_MAX_SEGMENTS = 128`
- `sizeof(cl_toc_t) = 24 + 128*64 = 8216`

**TOC Entry Felder (host-order):**
- `type`, `flags`
- `offset_bytes`, `stride_bytes`, `count`
- `hot_off/hot_len`, `warm_off/warm_len`, `cold_off/cold_len`
- `upd_class`
- `src_tag`, `qual_tag`

**Invariants:**
- Entry ist exakt 64B.
- `offset_bytes` ist aligned zu `stride_bytes` (mindestens).
- Segmente werden niemals „implizit“ gefunden. TOC ist die Wahrheit.

---

## 3. Segment-Geometrie (Strides)

### 3.1 Fixe Strides (Gesetz)
- 256B, 512B, 1024B, 4096B
- jedes Segmentrecord ist Vielfaches von 64B Cachelines
- `raw[64]` Unions als Normfläche pro Line
- `raw[4096]` als Normfläche pro Page-Segment (Bulk)

### 3.2 Segmentliste (aktueller Stand)
Control/Policy:
- `cl_seg_link_256_t`
- `cl_seg_budget_256_t`
- `cl_seg_time_256_t`
- `cl_seg_overlay_256_t`
- `cl_seg_board_512_t`

Inventory:
- `cl_seg_cpu_1024_t`
- `cl_seg_nic_512_t`
- `cl_seg_mem_256_t`
- `cl_seg_pcie_256_t`

Mesh:
- `cl_seg_mesh_neighbor_256_t`
- `cl_seg_mesh_peer_256_t`

Bulk/Meta:
- `cl_seg_dma_4096_t`
- `cl_seg_history_4096_t`
- `cl_seg_forensics_4096_t`
- `cl_seg_zfs_4096_t`

---

## 4. Source/Quality Pflicht

Jeder Segment-Record enthält (mindestens einmal):
- `src` (cl_source_t) und `qual` (cl_quality_t)

**Regel:**
- Fehlende Daten werden nicht „0“ – sondern:
  - Feature state = UNSUPPORTED/UNKNOWN/DISABLED
  - `src/qual` entsprechend setzen
  - `reason_code/constraint_flags` erklären, warum

---

## 5. String- und Herstellerdaten

### 5.1 Grundsatz
- Hersteller/Name/Serial sind Pflicht zur Transparenz (Monitor-Anforderung).
- Strings gehören in COLD (statisch), niemals in HOT.

### 5.2 64B-Line Disziplin
- Keine 64B Cold-Line darf durch Strings >64B gesprengt werden.
- Längere Labels werden über mehrere Cold-Lines verteilt (z. B. CPU cold_b/cold_c).
- Das ist kein Workaround, sondern Normflächenprinzip.

---

## 6. Build-/ABI-Checks (Pflicht)

### 6.1 Compile-Time
- Jeder Segmenttyp hat `_Static_assert(sizeof(...) == STRIDE)`
- `cl_root_4096_t` hat `_Static_assert(sizeof(...) == 4096)`
- `cl_toc_entry_t` hat `_Static_assert(sizeof(...) == 64)`
- Bei großen Alignments (1024/4096) ist size-assert zwingend.

### 6.2 Laufzeit
- `cl_shm_dump` muss Root + TOC lesen können, ohne UB
- Root `endian_magic` muss passen
- `toc_offset + sizeof(cl_toc_t)` muss im Mapping liegen

---

## 7. Änderungsregeln (Append-only)

### 7.1 Was ist erlaubt
- Neue Felder werden **nur in reservierte Bereiche** gesetzt oder in neue Lines/COLD-Erweiterungen verschoben.
- Segment-Strides bleiben gleich.
- TOC kann neue Segmente hinzufügen (bis 128).
- Schema-Version wird erhöht, wenn Semantik/Interpretation sich ändern.

### 7.2 Was ist verboten
- Reordering von bestehenden Feldern in einer Line
- Entfernen/Umbenennen von Feldern ohne Kompatibilitätsbrücke
- `packed` in SHM
- implizite Padding-Annahmen
- „nur für einen Compiler“ Anpassungen

---

## 8. Performance- und Energie-Regel (aggressiv, aber gated)

- CommanderLink darf **aggressiv** Ressourcen nutzen (CPU bis 100%, SIMD bis Maximum), wenn:
  - Budget nicht SHADOW/RECLAIM
  - Thermal/VRM/Power Gates offen
  - Security/Join Trust ok
- Drosselung ist **sofort** und **lokal** (nur betroffene Ressource/Link).

---

## 9. Tooling

- `cl_dummy_shm` erzeugt Core-SHM + TOC + Segment-Records deterministisch.
- `cl_shm_dump` ist Truth-Viewer zur ABI-Prüfung.
- Monitor2 wird ausschließlich aus TOC/Segmente lesen, nicht aus Legacy-Strukturen.

---

## 10. Checkliste für Review

Vor jeder Layout-Änderung:
1) Betrifft es SHM? → `packed` verboten
2) Bleibt jede Line 64B? → `_Static_assert`
3) Bleibt Segmentstride gleich? → `_Static_assert`
4) Bleibt Root 4096? → `_Static_assert`
5) Wird Source/Quality/State/Reason abgebildet? → Pflicht
6) Ist es append-only? → Pflicht
7) Laufen Dummy + Dump auf Linux/BSD/OmniOS? → Pflicht

---


<<< END FILE: ./docs/ABI_LAYOUT.md

>>> START FILE: ./docs/ENGINEERING_RULES.md
# CommanderLink – ENGINEERING RULES

## Zweck
Dieses Dokument definiert die unverrückbaren technischen Grundregeln
für CommanderLink (CL).

CommanderLink ist kein „Framework“, kein „Netzwerktool“ und kein
Standard-Stack.  
CommanderLink ist eine **physiknahe Datenmaschine**.

Diese Regeln gelten **immer** – unabhängig von Plattform, Version oder
Implementierungsdetails.

---

## 1. Primat der Physik

- Hardware ist kein Abstraktionsdetail.
- Cachelines, Register, Busbreiten und Speicherhierarchien sind reale
  physikalische Objekte.
- Software muss sich **der Hardware anpassen**, nicht umgekehrt.

**Konsequenz:**  
„Best Practice“, wenn sie der Physik widerspricht, wird ignoriert.

---

## 2. Zieldefinition

CommanderLink maximiert **gleichzeitig**:

1. Durchsatz
2. Energieeffizienz pro Bit
3. Determinismus
4. Stabilität
5. Hardware-Schutz

Keiner dieser Punkte darf isoliert optimiert werden.

---

## 3. Stabilität vor Geschwindigkeit

- Ein System, das abstürzt, ist wertlos.
- Jeder aggressive Pfad benötigt:
  - Validity Gates
  - Hysterese
  - Sofortige Fallbacks

**Fail-Open Regel:**  
Wenn CL stirbt, bleibt das Betriebssystem funktionsfähig.

---

## 4. Keine impliziten Annahmen

- Keine impliziten Padding-Regeln
- Keine impliziten Alignments
- Keine impliziten Typgrößen
- Keine impliziten Endianness-Annahmen

Alles ist explizit oder verboten.

---

## 5. Messbarkeit

Jede Entscheidung in CL muss messbar sein:
- im Shared Memory
- im Monitor
- in Forensik-Logs

Was nicht sichtbar ist, existiert nicht.

---

## 6. Menschenlesbarkeit

- Code ist auf Deutsch kommentiert.
- Jede Struktur erklärt **warum**, nicht nur **was**.
- Kommentare sind Teil des Vertrags.

---

## 7. Erweiterbarkeit ohne ABI-Bruch

- Strukturen wachsen nur über reservierte Felder.
- Alte Monitore dürfen neue Felder ignorieren können.
- Schema-Versionierung ist Pflicht.

---

## 8. Energie ist erlaubt

- 100 % CPU-Last ist erlaubt.
- AVX-512 Volllast ist erlaubt.
- Hoher Stromverbrauch ist erlaubt.

**Solange:**
- Thermik-Gates offen sind
- VRM-Safety nicht verletzt wird
- OS-Interaktivität nicht leidet

---

## 9. Schlussformel

CommanderLink ist kein Kompromiss.

CommanderLink ist:
> **Investment Protection durch Maximierung**


<<< END FILE: ./docs/ENGINEERING_RULES.md

>>> START FILE: ./docs/laws/00_PHYSICS.md
# LAW_00_PHYSICS.md
## CommanderLink – Gesetz der Physik (Grundgesetz)

**Status:** ENTWURF (normativ nach Freigabe)  
**Geltungsbereich:** Gesamtsystem (Design, Header, Runtime, Tools, Monitor)  
**Priorität:** Höchste – steht über allen weiteren LAWs

---

## 0. Zweck
Dieses Gesetz definiert die **oberste Wahrheit** für CommanderLink.  
Alle Entscheidungen sind **physikalisch deterministisch** zu treffen.  
Software dient der **Ausnutzung der Hardware**, nicht umgekehrt.

---

## 1. Rangordnung der Wahrheit
Bei Konflikten gilt strikt folgende Priorität (absteigend):

1. **Physikalische Realität**
   - Elektrische, thermische, zeitliche Grenzen
   - Cache-/TLB-/NUMA-Effekte, DMA-Geometrie
2. **Mikroarchitektur**
   - Pipeline, SIMD-Breite, Register, Prefetch, Power-States
3. **ABI-Stabilität**
   - Layout, Alignment, Größenverträge, Offsets
4. **Betriebssystem-Koexistenz**
   - Scheduling, Routing, I/O-Pfade
5. **Externe Standards**
   - POSIX, RFCs, Ethernet, TCP/UDP, API-Konventionen

**Ein Standard darf niemals die Physik überstimmen.**

---

## 2. Plattform-Fixierung
- Zielarchitektur: **x86_64**, little-endian
- Hersteller: **Intel & AMD**
- Annahmen:
  - Cacheline = **64 Byte**
  - Registerbreite ≥ **64 Bit**
- Andere Architekturen sind **nicht normativ**, nur optional adaptierbar.

---

## 3. Zero-Transformation-Prinzip
- Keine impliziten Umrechnungen, kein „Parsing-Overhead“.
- Datengeometrie ist **explizit**:
  - Wire → Execution Context → Register ist definiert.
- Transformation ist **verboten**, außer:
  - explizit genehmigt
  - physikalisch notwendig
  - im LAW referenziert

---

## 4. Cacheline-Souveränität
- **64-Byte-Normfläche** ist das atomare Bauelement.
- Alle ABI-relevanten Strukturen:
  - sind Vielfache von 64 Byte
  - enthalten explizites Padding
  - besitzen `raw[64]`-Union oder äquivalente Normfläche
- **False Sharing ist ein Fehler**, kein Optimierungsfall.

---

## 5. Maximierungsprinzip
- **Maximum ist das Minimum.**
- CL nutzt **immer** die maximal physikalisch mögliche Leistung,
  **sofern** alle GATES offen sind.
- Drosselung erfolgt **nur** bei:
  - Thermal / VRM / Power-Gates
  - Interaktivitäts-Gates
  - Sicherheits-/Trust-Gates

---

## 6. Energie & Thermik
- Energieverbrauch ist **kein Makel**, sondern Messgröße.
- Schutzmechanismen:
  - Hardware-gesteuert (Throttling)
  - softwareseitig sichtbar (Gates)
- Software darf **nicht** künstlich bremsen,
  sondern **reaktiv** auf physikalische Grenzen reagieren.

---

## 7. SIMD-Grundsatz
- SIMD ist **Baseline**, kein Sonderfall.
- Leiter:
  - SSE4 → AVX2 → AVX-512
- Nutzung nur, wenn:
  - Effizienzgewinn real
  - Isolation möglich
  - GATES offen
- Sporadischer SIMD-Einsatz in Latenzpfaden ist **verboten**.

---

## 8. Koexistenz statt Dominanz
- CL ist **Symbiont**, kein Eroberer.
- OS bleibt souverän.
- CL darf:
  - Kerne pinnen
  - Ressourcen reservieren
- CL darf **nicht**:
  - Kernel ersetzen
  - Default-Routen kapern
  - OS destabilisieren

---

## 9. Auditierbarkeit
- Jeder physikalische Zustand ist:
  - sichtbar
  - messbar
  - reproduzierbar
- „Best effort“ ist **markierter Ausnahmezustand**, nie Default.

---

## 10. Ableitungsregel
Jedes weitere LAW muss:
- dieses Gesetz **explizit referenzieren**
- keine Regel einführen, die ihm widerspricht
- physikalisch begründet sein

---

## 11. Schlussformel
CommanderLink folgt **keinen Moden**.  
CommanderLink folgt **keinen Dogmen**.  
CommanderLink folgt **der Physik**.

**PHYSICS FIRST. x86_64 FIRST.**


<<< END FILE: ./docs/laws/00_PHYSICS.md

>>> START FILE: ./docs/laws/ANNEX_36_SHM_ENFORCEMENT.md
# ANNEX_36_SHM_ENFORCEMENT.md
## CommanderLink – SHM‑Erzwingungs‑ & Präzisions‑Annex
### Ergänzung zu LAW_35_ABI, LAW_36_SHM, MEMORY_MODEL

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieser Annex schärft die bestehenden SHM‑ und ABI‑Gesetze
auf **mechanisch erzwingbare Präzision** nach.

Er basiert auf dem aktuellen CommanderLink‑Projektstand
(ABI‑Report, Runtime‑Header, Segmentdefinitionen, Monitor).

Ziel ist:
- Eliminierung impliziter Annahmen
- Erzwingung physikalischer Invarianten
- Eindeutige Maschinenverträge für zukünftige KIs

---

## 1. Cacheline‑Konstante ist ABI‑Teil

### 1.1 Normative Konstante

Für CommanderLink gilt:

CL_CACHELINE_BYTES = 64

Diese Konstante ist:
- ABI‑relevant
- SHM‑relevant
- Tool‑relevant

---

### 1.2 Verifikation

Der ABI‑Report MUSS ausgeben:

- cacheline_bytes
- alignment_basis

Abweichung von 64 Byte führt zu:

RESULT: ABI_INVALID

---

## 2. Segment‑Header müssen Konsistenz explizit machen

### 2.1 Pflichtfelder pro Segment

Jeder SHM‑Segment‑Header MUSS enthalten:

- `schema_version`
- `segment_epoch`
- `segment_state`
- `owner_domain`

Diese Felder sind:
- Hot oder Warm klassifiziert
- ABI‑belegt
- maschinenlesbar

---

### 2.2 Segment‑Epoch

`segment_epoch` ist:

- monoton steigend (`u64`)
- Publish‑Token für das gesamte Segment
- einzig zulässiger Sichtbarkeitsanker

---

## 3. Publish / Consume ist verpflichtend pro Segment

### 3.1 Writer‑Pflicht

Ein Writer MUSS:

1. Segmentdaten schreiben
2. `segment_epoch` mit `store_release` erhöhen

Andere Reihenfolgen sind verboten.

---

### 3.2 Reader‑Pflicht

Ein Reader MUSS:

1. `segment_epoch` mit `load_acquire` lesen
2. Segmentdaten lesen
3. optional erneut `segment_epoch` prüfen

Mismatch → Retry oder Abbruch

---

## 4. Non‑Atomic Felder: explizite Zulässigkeit

### 4.1 Verbot

Non‑atomic Felder ohne zugeordnetes Token
sind **Undefined Behavior**.

---

### 4.2 Erlaubnis

Non‑atomic Felder sind nur erlaubt, wenn:

- sie einer Konsistenzgruppe zugeordnet sind
- diese Gruppe ein Token besitzt
- Zugriff ausschließlich nach Acquire erfolgt

---

## 5. Interference‑Klassen sind ABI‑Eigenschaft

### 5.1 Klassen

CommanderLink kennt exakt zwei Klassen:

| Klasse | Fenster |
|------|--------|
| CACHELINE | 64 Byte |
| DESTRUCTIVE | 128 Byte |

---

### 5.2 DESTRUCTIVE‑Klasse (Pflicht)

Die DESTRUCTIVE‑Klasse ist verpflichtend für:

- Cursor (head/tail)
- Epoch‑Zähler
- Heartbeats
- Rate‑Limiter
- globale Gates

Diese Felder dürfen:
- keine schreibenden Nachbarn
  innerhalb ±64 Byte haben

---

### 5.3 ABI‑Bindung

Die Interference‑Klasse eines Feldes:

- ist Teil des ABI
- darf nicht geändert werden
- ist im ABI‑Report auszuweisen

---

## 6. AVX‑512 ist ein globaler Systemzustand

### 6.1 AVX‑Fenster

AVX‑512‑Ausführung erzeugt den Zustand:

AVX_HEAVY_WINDOW

Dieser Zustand:

- ist nicht thread‑lokal
- beeinflusst Frequenz und Latenz
- besitzt eine Nachlaufzeit

---

### 6.2 Normative Regeln

- AVX‑512 ist nur erlaubt in:
  - dedizierten Worker‑Threads
  - explizit gepinnten Cores
- Control‑Plane, Watchdog, Gates:
  - AVX‑frei
- AVX‑Fenster ist Gate‑relevant

---

## 7. Non‑Temporal Stores

### 7.1 Klassifikation

Non‑Temporal Stores sind:

- kein Default
- kein Ersatz für normale Stores
- ein Spezialpfad

---

### 7.2 Regeln

- Nur in Cold/Bulk‑Segmenten erlaubt
- Nie für:
  - Tokens
  - Epochs
  - Statusfelder
- Sichtbarkeit MUSS explizit hergestellt werden

---

## 8. ABI‑Pflichtangaben pro Feld

Für jedes SHM‑Feld MUSS dokumentiert sein:

- Owner‑Domain
- Konsistenzgruppe
- Token‑Zugehörigkeit
- Memory‑Order
- Interference‑Klasse

Fehlende Angaben machen das Feld ungültig.

---

## 9. Tooling‑Pflicht

### 9.1 ABI‑Report

Der ABI‑Report MUSS enthalten:

- Feldgröße
- Alignment
- Offset
- Interference‑Klasse
- Token‑Referenz

---

### 9.2 Monitor

Der Monitor MUSS:

- Segment‑Epochs anzeigen
- AVX‑Zustand sichtbar machen
- Reclaim‑Zustände anzeigen

---

## 10. Schlussformel

Shared Memory ist kein Datenmodell.

Es ist ein **physikalischer Vertrag**
zwischen CPU, Cache und Beobachter.

Wer diese Regeln verletzt,
verlässt Determinismus.

Mit diesem Annex ist
CommanderLink‑SHM **erzwingbar präzise**.

Perfekt.  
Hier ist **alles als ein einziges, zusammenhängendes Markdown‑Dokument**, **ohne Unterbrechung**, **ohne Kommentare**, **ohne Meta**, **direkt copy‑&‑paste‑fähig**.


# ANNEX_36_SHM_COMPLETE.md
## CommanderLink – SHM‑Erzwingungs‑, Memory‑Order‑ & Segment‑Wahrheits‑Annex
### Ergänzung zu LAW_35_ABI, LAW_36_SHM, MEMORY_MODEL

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieser Annex schärft die bestehenden SHM‑ und ABI‑Gesetze
auf **mechanisch erzwingbare Präzision** nach.

Er basiert auf dem aktuellen CommanderLink‑Projektstand
(ABI‑Report, Runtime‑Header, Segmentdefinitionen, Monitor).

Ziel ist:
- Eliminierung impliziter Annahmen
- Erzwingung physikalischer Invarianten
- Eindeutige Maschinenverträge für zukünftige KIs

---

## 1. Architekturannahmen (bindend)

Dieser Annex gilt ausschließlich für:

- x86_64
- Little‑Endian
- Write‑Back (WB) Cacheable Memory
- Cacheline‑Größe: **64 Byte**

Andere Memory‑Typen (UC, WC, MMIO) sind **nicht** Teil dieses Modells.

---

## 2. Cacheline‑Konstante ist ABI‑Teil

### 2.1 Normative Konstante

CL_CACHELINE_BYTES = 64


Diese Konstante ist:
- ABI‑relevant
- SHM‑relevant
- Tool‑relevant

### 2.2 Verifikation

Der ABI‑Report MUSS ausgeben:

- cacheline_bytes
- alignment_basis

Abweichung von 64 Byte führt zu:


RESULT: ABI_INVALID

---

## 3. Publish / Consume ist das einzige Synchronisationsmodell

### 3.1 Grundsatz

Shared‑Memory‑Konsistenz entsteht **ausschließlich**
durch explizite **Publish / Consume‑Token**.

Implizite Ordnung ist unzulässig.

---

### 3.2 Konsistenzgruppe

Eine Konsistenzgruppe besteht aus:

- beliebigen Datenfeldern (non‑atomic erlaubt)
- **genau einem** Sichtbarkeits‑Token

Das Token ist das **einzige** synchronisierende Element.

---

### 3.3 Publish‑Regel (Writer)

Ein Writer MUSS:

1. alle Datenfelder schreiben  
2. anschließend das Token schreiben mit  
   `store_release`

Andere Reihenfolgen sind verboten.

---

### 3.4 Consume‑Regel (Reader)

Ein Reader MUSS:

1. das Token lesen mit  
   `load_acquire`
2. anschließend die Datenfelder lesen

Lesen vor dem Token ist verboten.

---

### 3.5 Token‑Typen

Zulässige Token:

- `segment_epoch`
- `seq_cnt`
- `state`
- explizit benannte Visibility‑Flags

Token sind:
- immer atomic
- monoton oder zustandskodierend
- niemals Teil von Datenfeldern

---

## 4. Non‑Atomic Reads

### 4.1 Verbot

Non‑atomic Reads ohne Token‑Schutz
sind **Undefined Behavior** und verboten.

---

### 4.2 Erlaubnis

Non‑atomic Reads sind nur erlaubt, wenn:

- sie **nach** einem `load_acquire` erfolgen
- sie zur selben Konsistenzgruppe gehören
- es genau einen Writer gibt

---

## 5. Cacheline‑ und Interference‑Klassen

### 5.1 Klassen

| Klasse | Fenster |
|------|--------|
| CACHELINE | 64 Byte |
| DESTRUCTIVE | 128 Byte |

---

### 5.2 DESTRUCTIVE‑Klasse (Pflicht)

Die DESTRUCTIVE‑Klasse ist verpflichtend für:

- Cursor (head/tail)
- Epoch‑Zähler
- Heartbeats
- Rate‑Limiter
- globale Gates

Diese Felder dürfen keine schreibenden Nachbarn
innerhalb ±64 Byte haben.

---

### 5.3 ABI‑Bindung

Die Interference‑Klasse eines Feldes
ist Teil des ABI und unveränderlich.

---

## 6. AVX‑512 ist ein globaler Systemzustand

### 6.1 AVX‑Fenster

AVX‑512‑Ausführung erzeugt den Zustand:

AVX_HEAVY_WINDOW

Dieser Zustand:
- ist nicht thread‑lokal
- beeinflusst Frequenz und Latenz
- besitzt eine Nachlaufzeit

---

### 6.2 Normative Regeln

- AVX‑512 ist nur erlaubt in:
  - dedizierten Worker‑Threads
  - explizit gepinnten Cores
- Control‑Plane, Watchdog, Gates:
  - AVX‑frei
- AVX‑Fenster ist Gate‑relevant

---

## 7. Non‑Temporal Stores

### 7.1 Klassifikation

Non‑Temporal Stores sind Spezialpfade.

### 7.2 Regeln

- Nur in Cold/Bulk‑Segmenten erlaubt
- Nie für Tokens, Epochs oder Statusfelder
- Sichtbarkeit MUSS explizit hergestellt werden

---

## 8. ABI‑Pflichtangaben pro Feld

Für jedes SHM‑Feld MUSS dokumentiert sein:

- Owner‑Domain
- Konsistenzgruppe
- Token‑Zugehörigkeit
- Memory‑Order
- Interference‑Klasse

Fehlende Angaben machen das Feld ungültig.

---

## 9. Segment‑Wahrheitstabellen

---

### 9.1 Segment: LINK_256

**Writer:** LINK‑Thread  
**Reader:** Monitor, NIC, Watchdog  
**Token:** segment_epoch

| Feld | Größe | Klasse | Order | Interference |
|----|----|----|----|----|
| segment_epoch | u64 | Hot | release/acquire | DESTRUCTIVE |
| link_state | u32 | Hot | non‑atomic | CACHELINE |
| link_flags | u32 | Hot | non‑atomic | CACHELINE |
| tx_gate | u32 | Hot | non‑atomic | DESTRUCTIVE |
| rx_gate | u32 | Hot | non‑atomic | DESTRUCTIVE |
| error_flags | u64 | Warm | non‑atomic | CACHELINE |

---

### 9.2 Segment: CPU_1024

**Writer:** CPU‑Sampler  
**Reader:** Monitor, Oracle  
**Token:** segment_epoch

| Feld | Größe | Klasse | Order | Interference |
|----|----|----|----|----|
| segment_epoch | u64 | Hot | release/acquire | DESTRUCTIVE |
| cpu_freq_khz | u64 | Hot | non‑atomic | CACHELINE |
| cpu_temp_mc | u64 | Warm | non‑atomic | CACHELINE |
| avx_state | u32 | Hot | non‑atomic | DESTRUCTIVE |
| avx_window_epoch | u64 | Hot | non‑atomic | DESTRUCTIVE |

---

### 9.3 Segment: NIC_512

**Writer:** NIC‑Backend  
**Reader:** LINK, Monitor  
**Token:** segment_epoch

| Feld | Größe | Klasse | Order | Interference |
|----|----|----|----|----|
| segment_epoch | u64 | Hot | release/acquire | DESTRUCTIVE |
| tx_credits_bytes | u64 | Hot | non‑atomic | DESTRUCTIVE |
| tx_credits_pkts | u32 | Hot | non‑atomic | DESTRUCTIVE |
| rx_backpressure | u32 | Hot | non‑atomic | DESTRUCTIVE |

---

### 9.4 Segment: WATCHDOG_256

**Writer:** Watchdog  
**Reader:** Monitor  
**Token:** segment_epoch

| Feld | Größe | Klasse | Order | Interference |
|----|----|----|----|----|
| segment_epoch | u64 | Hot | release/acquire | DESTRUCTIVE |
| heartbeat_cnt | u64 | Hot | non‑atomic | DESTRUCTIVE |
| restart_count | u32 | Warm | non‑atomic | CACHELINE |

---

## 10. Globale Invarianten

- Jedes Segment besitzt genau ein Token
- Kein Feld ohne Token‑Zuordnung
- Kein DESTRUCTIVE‑Feld ohne 128B‑Isolation
- Kein AVX‑Code außerhalb Worker‑Domänen
- Monitor ist strikt read‑only

---

## 11. Schlussformel

Shared Memory ist kein Datenmodell.

Es ist ein **physikalischer Vertrag**
zwischen CPU, Cache und Beobachter.

Mit diesem Annex ist CommanderLink
**erzwingbar deterministisch**.



<<< END FILE: ./docs/laws/ANNEX_36_SHM_ENFORCEMENT.md

>>> START FILE: ./docs/laws/LAW_00_PHYSICS.md
# LAW_00_PHYSICS.md
## CommanderLink – Physikalisches Grundgesetz

### Status
VERBINDLICH · NORMATIV · NICHT DISKUTABEL

---

## 0. Präambel

CommanderLink ist ein physikalisches System.  
Alle weiteren Gesetze, Verträge, Header und Implementierungen sind diesem Gesetz untergeordnet.

Physik ist die oberste Autorität.  
Spezifikationen, Konventionen, Standards und „Best Practices“ haben keinerlei Vorrang.

---

## 1. Rangordnung der Wahrheit

Die Gültigkeit von Aussagen, Entscheidungen und Messungen folgt strikt dieser Ordnung:

1. Physikalische Realität (Zeit, Energie, Temperatur, elektrische Grenzen)
2. Mikroarchitektur (Caches, Pipelines, TLBs, SIMD, NUMA)
3. Konkrete Hardware-Implementierung (x86_64, reale CPUs, reale NICs)
4. ABI-Verträge (Binärlayout, Alignment, Atomics)
5. Betriebssystem-Verträge
6. Protokolle und formale Spezifikationen

Bei Konflikt gilt immer die höhere Ebene.  
Ein Verstoß gegen diese Ordnung ist ein Designfehler.

---

## 2. Zeit ist endlich

Zeit ist eine physikalische Ressource.

* Jede Operation verbraucht Zeit.
* Zeit kann nicht parallelisiert werden.
* Zeit kann nicht abstrahiert werden.

Folgerungen:
- Worst-Case-Zeit ist maßgeblich, nicht Durchschnittswerte.
- Jitter ist ein Fehler, kein Statistikproblem.
- Ungebundene Wartezeiten sind verboten.

---

## 3. Energie ist endlich

Energie ist begrenzt und messbar.

* CPU-Zyklen sind Energieverbrauch.
* Speicherzugriffe sind Energieverbrauch.
* Netzwerktransfers sind Energieverbrauch.

Folgerungen:
- Jede Berechnung muss eine energetische Rechtfertigung haben.
- Aggressive Nutzung ist erlaubt, ineffiziente Nutzung nicht.
- Thermische Grenzen sind harte Grenzen, keine Hinweise.

---

## 4. Temperatur ist ein Zwang

Temperatur ist ein nicht verhandelbarer Zustand.

* Drosselung ist physikalisch, nicht logisch.
* Thermische Effekte treten verzögert auf.
* Überschreitung führt zu nichtlinearem Verhalten.

Folgerungen:
- Thermische Gates sind sofort wirksam.
- Kein Mechanismus darf Temperatur ignorieren.
- Performance ohne thermische Stabilität ist ungültig.

---

## 5. Speicher ist physikalisch

Speicher ist kein abstrakter Raum.

* Cache-Lines haben feste Größe.
* Alignment ist real.
* Falsches Layout erzeugt reale Kosten.

Folgerungen:
- Implizites Padding ist verboten.
- Layouts müssen cacheline-exakt sein.
- Speicherzugriffe werden nach physikalischer Nähe bewertet.

---

## 6. Parallelität ist begrenzt

Parallelität existiert nur dort, wo Hardware sie zulässt.

* Kerne sind endlich.
* Ausführungseinheiten sind endlich.
* Bandbreite ist endlich.

Folgerungen:
- Oversubscription ist ein Fehler.
- Software darf keine fiktive Parallelität annehmen.
- Scheduling darf keine physikalischen Konflikte erzeugen.

---

## 7. Latenz ist eine Eigenschaft, kein Parameter

Latenz entsteht aus Physik.

* Entfernung
* Zwischenspeicher
* Synchronisation

Folgerungen:
- Latenz kann gemessen, nicht „konfiguriert“ werden.
- Latenzreduktion hat Vorrang vor Durchsatzsteigerung, sofern stabil.
- Ungebundene Latenzpfade sind verboten.

---

## 8. Bandbreite ist ein Fluss

Bandbreite ist kontinuierlich, nicht paketweise.

* Burst-Verhalten erzeugt Störungen.
* Gleichmäßigkeit ist stabiler als Spitzen.

Folgerungen:
- Pacing ist Pflicht.
- Backpressure ist Pflicht.
- Drops sind ein physikalisches Versagen.

---

## 9. Messung ist Teil des Systems

Ein System ohne Messung ist blind.

* Messung darf das System nicht destabilisieren.
* Messung muss zeitlich korrekt sein.
* Messung ist Wahrheit, nicht Interpretation.

Folgerungen:
- Messpfade sind physikalisch zu budgetieren.
- Heuristiken ersetzen keine Messung.
- Logs sind sekundär gegenüber direkter Telemetrie.

---

## 10. Determinismus ist ein physikalisches Ziel

Determinismus bedeutet:
Gleiche Bedingungen → gleiches Verhalten.

Folgerungen:
- Zufälligkeit ist verboten.
- „Best Effort“ ist verboten.
- Nichtdeterministische APIs sind zu kapseln oder auszuschließen.

---

## 11. Fehler sind Zustände, keine Ausnahmen

Fehler entstehen aus Physik.

* Überlast
* Hitze
* Zeitüberschreitung
* Ressourcenmangel

Folgerungen:
- Fehlerpfade sind gleichwertige Pfade.
- Recovery ist Teil des Normalbetriebs.
- Undefined Behavior ist verboten.

---

## 12. Architekturbindung

CommanderLink ist primär x86_64-gebunden.

* Little-Endian ist gegeben.
* Cache-Line-Größe ist bekannt.
* SIMD-Eigenschaften sind explizit.

Portabilität ist nachrangig gegenüber physikalischer Korrektheit.

---

## 13. Schlussformel

Wenn eine Entscheidung physikalisch falsch ist,
ist sie falsch – unabhängig von Eleganz, Konformität oder Konvention.

Dieses Gesetz ist unveränderlich.  
Alle weiteren Gesetze müssen ihm widerspruchsfrei folgen.


<<< END FILE: ./docs/laws/LAW_00_PHYSICS.md

>>> START FILE: ./docs/laws/LAW_01_CPU.md
# LAW_01_CPU.md
## CommanderLink – CPU-Gesetz (x86_64)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt die Nutzung, Wahrnehmung und Belastung der CPU
für CommanderLink auf **x86_64**-Systemen.

Es beschreibt keine Implementierungen.
Es definiert verbindliche physikalische und architektonische Regeln.

---

## 1. Die CPU ist eine physikalische Maschine

Die CPU ist kein abstrakter Rechenkern.

* Kerne sind physisch.
* Ausführungseinheiten sind endlich.
* Frontend, Backend und Speicherpfade sind getrennt.

Jede Annahme einer „idealen CPU“ ist verboten.

---

## 2. Kerne sind exklusive Ressourcen

Ein CPU-Kern kann nur einen physikalischen Ausführungskontext
ohne Interferenz garantieren.

Folgerungen:
- Exklusive Nutzung ist der Referenzzustand.
- Geteilte Nutzung ist ein degradierter Zustand.
- Überschneidung erzeugt nichtlineare Effekte.

---

## 3. SMT ist kein zusätzlicher Kern

SMT/Hyper-Threading erzeugt keine neuen Ausführungseinheiten.

Folgerungen:
- SMT-Threads konkurrieren um dieselbe Physik.
- SMT darf niemals als Kapazitätserweiterung gerechnet werden.
- SMT ist optional und jederzeit entziehbar.

---

## 4. Pipelines sind endlich und zustandsbehaftet

Instruktionspipelines haben Tiefe, Latenz und Abhängigkeiten.

Folgerungen:
- Pipeline-Flushes sind reale Kosten.
- Fehlvorhersagen sind physikalische Verluste.
- Kontrollfluss ist teurer als Datenfluss.

---

## 5. SIMD ist ein physikalischer Verstärker

SIMD nutzt vorhandene Breite der Recheneinheiten.

Folgerungen:
- SIMD ist der Normalfall, nicht die Optimierung.
- Skalierung erfolgt über Vektorisierung, nicht über Threads.
- Nicht-vektorisierte Pfade gelten als degradiert.

---

## 6. Frequenz ist variabel und instabil

CPU-Frequenz ist kein konstanter Wert.

* Turbo ist opportunistisch.
* Drosselung ist zwingend.
* Übergänge sind nicht linear.

Folgerungen:
- Zeitabschätzungen dürfen keine fixe Frequenz annehmen.
- Thermal- und Power-Limits haben Vorrang.
- Performance ohne Frequenzkontrolle ist ungültig.

---

## 7. Zeitbasis ist lokal

Zeit entsteht auf der CPU.

Folgerungen:
- Lokale Zeitquellen haben Vorrang vor externen.
- Zeitstempel sind kernabhängig.
- Synchronisation kostet Zeit.

---

## 8. Preemption ist ein physikalischer Eingriff

Unterbrechungen reißen Ausführungskontexte auf.

Folgerungen:
- Preemption ist ein Störereignis.
- Latenzpfade müssen preemption-resistent sein.
- Kritische Pfade sind gegen Verdrängung zu schützen.

---

## 9. Pinning ist ein Vertrag mit der Physik

CPU-Pinning ist keine Optimierung, sondern eine Festlegung.

Folgerungen:
- Gepinnte Ausführung übernimmt Verantwortung für den Kern.
- Pinning entzieht dem System Ressourcen.
- Falsches Pinning ist ein Systemfehler.

---

## 10. Kontextwechsel sind Verluste

Jeder Kontextwechsel verursacht:

* Cache-Verlust
* Pipeline-Verlust
* Zeitverlust

Folgerungen:
- Kontextwechsel sind zu minimieren.
- Hohe Wechselraten sind ein Designfehler.
- „Leichtgewichtige“ Threads existieren physikalisch nicht.

---

## 11. Überbuchung ist verboten

Mehr Arbeit als physikalisch ausführbar zu planen ist unzulässig.

Folgerungen:
- Warteschlangen müssen begrenzt sein.
- Rückstau ist vorzuziehen gegenüber Überlast.
- Dropped Work ist besser als instabiles Systemverhalten.

---

## 12. Messung erfolgt am Kern

CPU-Messungen müssen kernnah sein.

Folgerungen:
- Aggregierte Werte sind sekundär.
- Mittelwerte verschleiern Realität.
- Worst-Case-Beobachtung ist verpflichtend.

---

## 13. Architekturbindung

CommanderLink bindet sich explizit an:

- x86_64
- Little-Endian
- bekannte Cacheline-Größen
- bekannte SIMD-Breiten

Abweichungen sind neue Architekturen und erfordern neue Gesetze.

---

## 14. Schlussformel

Die CPU bestimmt das Verhalten des Systems.
Software hat sich anzupassen, nicht umgekehrt.

Dieses Gesetz ist Grundlage aller CPU-nahen Verträge,
Layouts und Laufzeitentscheidungen.


<<< END FILE: ./docs/laws/LAW_01_CPU.md

>>> START FILE: ./docs/laws/LAW_02_MEMORY.md
# LAW_02_MEMORY.md
## CommanderLink – Speicher-Gesetz (x86_64)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Struktur, Nutzung und Bewertung von Speicher
für CommanderLink auf **x86_64**-Systemen.

Es definiert physikalische Wahrheiten.
Es enthält keine Implementierungsanweisungen.

---

## 1. Speicher ist physikalisch lokal

Speicher existiert in Stufen realer Entfernung.

* Register
* L1 / L2 / L3 Cache
* DRAM
* Remote-NUMA

Folgerungen:
- Nähe bestimmt Kosten.
- Entfernung ist nicht abstrahierbar.
- Falsche Lokalität ist ein Fehler.

---

## 2. Cache-Lines sind die atomare Einheit

Die Cache-Line ist die kleinste relevante Transporteinheit.

Folgerungen:
- Alle Hot-Daten müssen cacheline-exakt sein.
- Teilweise Nutzung ist Verschwendung.
- False Sharing ist ein Designfehler.

---

## 3. Alignment ist zwingend

Alignment ist keine Optimierung, sondern Voraussetzung.

Folgerungen:
- Implizites Alignment ist verboten.
- Strukturen müssen explizit ausgerichtet sein.
- Fehlalignment erzeugt reale Zusatzlast.

---

## 4. Layout ist ein Vertrag

Speicherlayout ist Teil der ABI-Wahrheit.

Folgerungen:
- Layouts dürfen sich nicht implizit ändern.
- Compiler-Freiheiten sind einzuschränken.
- Padding muss deterministisch sein.

---

## 5. Speicherzugriff ist teurer als Rechenlogik

Ein Speicherzugriff kostet mehr als eine Rechenoperation.

Folgerungen:
- Rechenintensität ist günstiger als Speicherintensität.
- Wiederverwendung hat Vorrang vor Neuladen.
- Datenbewegung ist zu minimieren.

---

## 6. NUMA ist Realität

NUMA ist kein Sonderfall.

Folgerungen:
- Cross-NUMA-Zugriffe sind degradierte Pfade.
- Speicher gehört zu Rechenknoten.
- Migration erzeugt reale Instabilität.

---

## 7. Atomics sind physikalische Barrieren

Atomare Operationen greifen tief in die Hardware ein.

Folgerungen:
- Atomics sind teuer.
- Globale Atomics skalieren nicht.
- Ordnung ist explizit festzulegen.

---

## 8. Konsistenz kostet Zeit

Speicherkonsistenz ist nicht kostenlos.

Folgerungen:
- Strenge Ordnung ist der teuerste Zustand.
- Lockerung ist erlaubt, Unklarheit nicht.
- Memory-Order muss bewusst gewählt werden.

---

## 9. Speicher ist endlich

Speicher ist eine begrenzte Ressource.

Folgerungen:
- Wachstum ohne Obergrenze ist verboten.
- Reclaim ist Pflicht.
- OOM ist ein Designversagen.

---

## 10. Allokation ist ein Eingriff

Allokation verändert den Systemzustand.

Folgerungen:
- Dynamische Allokation im Hot-Pfad ist verboten.
- Vorab-Reservierung ist der Referenzzustand.
- Fragmentierung ist ein Fehler.

---

## 11. Freigabe ist nicht sofort

Freigabe bedeutet nicht sofortige Wiederverwendbarkeit.

Folgerungen:
- Lebenszeiten müssen klar sein.
- Wiederverwendung ohne Stabilität ist verboten.
- Dangling States sind unzulässig.

---

## 12. Sichtbarkeit ist kontrolliert

Nicht jeder Speicher ist für jeden sichtbar.

Folgerungen:
- Shared Memory ist explizit.
- Private Daten bleiben privat.
- Sichtbarkeitsgrenzen sind Verträge.

---

## 13. Architekturbindung

CommanderLink bindet sich an:

- x86_64 Speicherordnung
- Cache-Line-basierte Kohärenz
- Little-Endian Darstellung

Andere Architekturen erfordern neue Gesetze.

---

## 14. Schlussformel

Speicher bestimmt Geschwindigkeit, Stabilität und Wahrheit.

Ein fehlerhaftes Speicherdesign
kann durch keine Logik kompensiert werden.

Dieses Gesetz ist Grundlage aller Layout-,
ABI- und Runtime-Entscheidungen.

<<< END FILE: ./docs/laws/LAW_02_MEMORY.md

>>> START FILE: ./docs/laws/LAW_03_NETWORK.md
# LAW_03_NETWORK.md
## CommanderLink – Netzwerk-Gesetz (Physik des Drahts)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt alle Formen von Datenübertragung
über physische oder virtuelle Netzwerke
für CommanderLink.

Es beschreibt die physikalische Realität des Transports.
Es ignoriert abstrahierende Protokollmodelle.

---

## 1. Das Netzwerk ist ein physikalisches Medium

Ein Netzwerk ist kein logischer Kanal.

* Signale benötigen Zeit.
* Medien haben Bandbreite.
* Übertragung erzeugt Verluste.

Jede Annahme eines „idealen Links“ ist verboten.

---

## 2. Latenz ist durch Physik bestimmt

Netzwerklatenz entsteht aus:

* Ausbreitung
* Serialisierung
* Puffern
* Verarbeitung

Folgerungen:
- Latenz ist nicht konfigurierbar.
- Latenz ist richtungsabhängig.
- Jitter ist ein Fehlerzustand.

---

## 3. Bandbreite ist endlich

Bandbreite ist ein kontinuierlicher Fluss.

Folgerungen:
- Line-Rate ist ein Grenzzustand.
- Überbuchung erzeugt Instabilität.
- Bursts sind physikalisch schädlich.

---

## 4. Puffer sind Zeitverschiebung

Puffer speichern Zeit, nicht Daten.

Folgerungen:
- Große Puffer erhöhen Latenz.
- Unkontrollierte Puffer sind verboten.
- Bufferbloat ist ein Designfehler.

---

## 5. Drops sind physikalische Ereignisse

Paketverluste entstehen durch Überlast oder Störung.

Folgerungen:
- Drops sind Signale, keine Ausnahme.
- Vermeidung hat Vorrang vor Reparatur.
- Wiederholung ersetzt keine Kontrolle.

---

## 6. Backpressure ist Pflicht

Ein Empfänger bestimmt die Geschwindigkeit.

Folgerungen:
- Sender warten.
- Empfänger geben explizit frei.
- Blindes Senden ist verboten.

---

## 7. Pacing ist zwingend

Daten müssen gleichmäßig eingespeist werden.

Folgerungen:
- Zeitbasierte Steuerung ist Pflicht.
- Burst-getriebene Übertragung ist verboten.
- Gleichmäßigkeit schlägt Spitzenleistung.

---

## 8. Reihenfolge ist teuer

Geordnete Übertragung kostet Zeit und Puffer.

Folgerungen:
- Ordnung ist explizit zu fordern.
- Unordnung ist der Default.
- Erzwungene Ordnung ohne Notwendigkeit ist verboten.

---

## 9. Zuverlässigkeit kostet Bandbreite

Integrität und Wiederherstellung sind nicht kostenlos.

Folgerungen:
- Fehlerkorrektur ist adaptiv.
- Statische Sicherheitsmargen sind verboten.
- Physikalische Qualität bestimmt das Maß.

---

## 10. MTU ist eine physikalische Grenze

MTU bestimmt Effizienz und Stabilität.

Folgerungen:
- MTU ist zu messen, nicht anzunehmen.
- Fragmentierung ist verboten.
- Größer ist nur besser bei Stabilität.

---

## 11. Netzwerk-Hardware ist Teil des Systems

NICs, Switches und Treiber sind aktive Akteure.

Folgerungen:
- Offloads sind physikalische Zustände.
- Interrupts sind Störungen.
- DMA ist kein „kostenloser“ Pfad.

---

## 12. Virtuelle Netzwerke sind reale Last

Virtuelle Links verbrauchen reale Ressourcen.

Folgerungen:
- Virtualisierung ändert Physik nicht.
- Overcommit ist sichtbar.
- Abstraktion reduziert nicht die Kosten.

---

## 13. Messung erfolgt am Draht

Netzwerk-Messung muss drahtnah sein.

Folgerungen:
- End-to-End allein ist unzureichend.
- Sender- und Empfängersicht sind getrennt.
- Worst-Case bestimmt das Verhalten.

---

## 14. Architekturbindung

CommanderLink betrachtet Netzwerke primär als:

- Punkt-zu-Punkt-Flüsse
- Zeitkontinuierliche Medien
- Physikalisch begrenzte Systeme

Protokolle sind untergeordnet.

---

## 15. Schlussformel

Das Netzwerk verzeiht keine Annahmen.

Wer schneller sendet als der Empfänger aufnehmen kann,
zerstört Stabilität.

Dieses Gesetz ist Grundlage aller
Wire-, Transport- und Flow-Entscheidungen.


<<< END FILE: ./docs/laws/LAW_03_NETWORK.md

>>> START FILE: ./docs/laws/LAW_04_TIME.md
# LAW_04_TIME.md
## CommanderLink – Zeit-Gesetz (Determinismus & Ablauf)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt den Umgang mit Zeit,
Abläufen und zeitlichen Abhängigkeiten
für CommanderLink auf **x86_64**.

Zeit ist eine physikalische Größe,
kein Abstraktionsmittel.

---

## 1. Zeit ist irreversibel

Zeit verläuft nur vorwärts.

Folgerungen:
- Rückwärtskorrekturen sind verboten.
- Nachträgliche „Reparaturen“ sind physikalisch unmöglich.
- Entscheidungen müssen zum Entscheidungszeitpunkt korrekt sein.

---

## 2. Zeit ist lokal

Zeit entsteht am Ausführungsort.

Folgerungen:
- Lokale Zeitquellen haben Vorrang.
- Globale Zeit ist ein abgeleiteter Zustand.
- Synchronisation erzeugt Verzögerung.

---

## 3. Zeitmessung ist störend

Jede Zeitmessung greift in das System ein.

Folgerungen:
- Zeitmessung ist zu budgetieren.
- Übermäßige Messung verfälscht Ergebnisse.
- Messpfade dürfen Hot-Pfade nicht destabilisieren.

---

## 4. Worst-Case dominiert

Zeitliche Planung richtet sich nach dem Worst-Case.

Folgerungen:
- Durchschnittswerte sind informativ, nicht bindend.
- P99/P999 sind Mindestanforderungen.
- Ungebundene Latenzen sind verboten.

---

## 5. Jitter ist ein Fehler

Zeitliche Schwankung ist Instabilität.

Folgerungen:
- Jitter ist zu minimieren, nicht zu akzeptieren.
- Glättung ist Pflicht.
- Burst-Verhalten erzeugt Jitter.

---

## 6. Deadlines sind physikalische Grenzen

Eine Deadline ist eine reale Grenze.

Folgerungen:
- Verpasste Deadlines sind Fehlerzustände.
- Spätes Ergebnis ist kein Ergebnis.
- Deadline-Überschreitungen sind sichtbar zu machen.

---

## 7. Blockierung ist Zeitvernichtung

Blockierende Operationen vernichten Zeit.

Folgerungen:
- Ungebundene Blockierung ist verboten.
- Warten ohne obere Grenze ist verboten.
- Fortschritt muss messbar sein.

---

## 8. Planung ersetzt Hoffnung

Zeitplanung ist verpflichtend.

Folgerungen:
- Jeder Ablauf benötigt ein Zeitbudget.
- Überziehung ist ein Vertragsbruch.
- Elastizität ist explizit zu definieren.

---

## 9. Asynchronität ist nicht kostenlos

Asynchronität verlagert Zeit, sie eliminiert sie nicht.

Folgerungen:
- Asynchrone Pfade benötigen Kontrolle.
- Entkopplung ohne Rückmeldung ist verboten.
- Jeder asynchrone Pfad braucht Backpressure.

---

## 10. Zeitdomänen sind getrennt

Unterschiedliche Zeitdomänen dürfen nicht vermischt werden.

Folgerungen:
- CPU-Zeit ≠ Netzwerkzeit ≠ IO-Zeit.
- Übersetzung kostet Zeit.
- Domänenwechsel sind explizit zu markieren.

---

## 11. Zeitbasierte Steuerung schlägt Ereignisreaktion

Zeitsteuerung ist stabiler als reine Ereignissteuerung.

Folgerungen:
- Periodische Kontrolle ist Pflicht.
- Ereignisstürme sind instabil.
- Reaktion ohne Zeitkontext ist verboten.

---

## 12. Messfehler sind Zeitfehler

Unpräzise Zeitmessung erzeugt falsche Entscheidungen.

Folgerungen:
- Zeitauflösung muss bekannt sein.
- Drift ist zu erkennen.
- Ungenaue Zeit ist ein Risiko.

---

## 13. Architekturbindung

CommanderLink bindet sich an:

- x86_64 Zeitquellen
- deterministische Zeitpfade
- bekannte Takt- und Drift-Eigenschaften

Andere Architekturen benötigen eigene Zeitgesetze.

---

## 14. Schlussformel

Zeit ist der härteste Zwang im System.

Ein System, das Zeit nicht kontrolliert,
wird von ihr kontrolliert.

Dieses Gesetz ist Grundlage aller
Scheduler-, Pacing- und Ablaufverträge.

<<< END FILE: ./docs/laws/LAW_04_TIME.md

>>> START FILE: ./docs/laws/LAW_05_POWER.md
# LAW_05_POWER.md
## CommanderLink – Energie- & Leistungs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Energieaufnahme, Leistungszustände
und deren Auswirkungen auf das Systemverhalten
für CommanderLink.

Energie ist eine physikalische Zwangsgröße.

---

## 1. Leistung ist Energie pro Zeit

Leistung entsteht ausschließlich durch Energieverbrauch.

Folgerungen:
- Rechenleistung ist kein abstrakter Wert.
- Jede Operation kostet messbare Energie.
- Unbudgetierter Verbrauch ist verboten.

---

## 2. Energiequellen sind begrenzt

Energiezufuhr ist endlich.

Folgerungen:
- Power-Limits sind harte Grenzen.
- Überschreitung erzwingt Korrektur.
- Ignorieren von Limits ist ein Systemfehler.

---

## 3. Leistungszustände sind diskret

Power-States sind endlich und hardwaredefiniert.

Folgerungen:
- Übergänge kosten Zeit.
- Häufige Wechsel erzeugen Instabilität.
- Unkontrollierte Zustandswechsel sind verboten.

---

## 4. Thermik folgt Energie

Temperatur ist eine Folge von Energie.

Folgerungen:
- Thermische Effekte sind verzögert.
- Prävention ist Pflicht.
- Reaktion allein ist zu spät.

---

## 5. Turbo ist opportunistisch

Leistungsreserven sind nicht garantiert.

Folgerungen:
- Turbo darf nicht eingeplant werden.
- Planung erfolgt auf Basis garantierter Zustände.
- Turbo ist ein Bonus, kein Vertrag.

---

## 6. Drosselung ist korrektes Verhalten

Drosselung schützt das System.

Folgerungen:
- Drosselung ist kein Fehler.
- Verdrängung von Arbeit ist erlaubt.
- Instabilität ist schlimmer als Langsamkeit.

---

## 7. Energieeffizienz ist Pflicht

Maximaler Verbrauch ohne Nutzen ist verboten.

Folgerungen:
- Energie pro Arbeitseinheit ist maßgeblich.
- Ineffiziente Pfade sind zu eliminieren.
- Idle-Verbrauch ist zu minimieren.

---

## 8. Leistungsspitzen sind schädlich

Spitzenbelastung destabilisiert.

Folgerungen:
- Glättung ist Pflicht.
- Burst-Leistung ohne Budget ist verboten.
- Gleichmäßigkeit erhöht Stabilität.

---

## 9. Energie ist messpflichtig

Ohne Messung keine Kontrolle.

Folgerungen:
- Energie- und Power-Messungen sind verpflichtend.
- Schätzungen ersetzen keine Messung.
- Messqualität ist offenzulegen.

---

## 10. Energie bestimmt Scheduling

Arbeit wird nach Energiezustand geplant.

Folgerungen:
- Hohe Last erfordert niedrige Energieintensität.
- Scheduling ohne Power-Kontext ist ungültig.
- Energetische Rückkopplung ist Pflicht.

---

## 11. Energie dominiert Performance

Mehr Energie ist nicht automatisch mehr Leistung.

Folgerungen:
- Effizienz schlägt rohe Leistung.
- Überhitzung zerstört Durchsatz.
- Stabilität hat Vorrang.

---

## 12. Architekturbindung

CommanderLink bindet sich an:

- reale Power-Limits der Hardware
- bekannte Power-States
- messbare Energiepfade

Abweichungen erfordern neue Gesetze.

---

## 13. Schlussformel

Energie ist der stille Regulator aller Systeme.

Wer Energie ignoriert,
verliert Kontrolle über Zeit und Stabilität.

Dieses Gesetz ist Grundlage aller
Budget-, Gate- und Fallback-Mechanismen.


<<< END FILE: ./docs/laws/LAW_05_POWER.md

>>> START FILE: ./docs/laws/LAW_06_SCHEDULING.md
# LAW_06_SCHEDULING.md
## CommanderLink – Ausführungs- & Scheduling-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Planung, Reihenfolge und Ausführung von Arbeit
in CommanderLink.

Scheduling ist eine physikalische Disziplin,
keine abstrakte Verwaltungsaufgabe.

---

## 1. Arbeit ist endlich

Arbeit existiert nur, wenn sie ausführbar ist.

Folgerungen:
- Unausführbare Arbeit ist Last.
- Geplante Arbeit ohne Ressourcen ist verboten.
- Warteschlangen ersetzen keine Kapazität.

---

## 2. Scheduling ist Ressourcenbindung

Scheduling bindet reale Ressourcen.

Folgerungen:
- Jede geplante Einheit reserviert Zeit, Energie und Speicher.
- Planung ohne Ressourcenbindung ist ungültig.
- Überplanung ist ein Designfehler.

---

## 3. Priorität ist physikalisch

Priorität entsteht aus Notwendigkeit, nicht aus Wunsch.

Folgerungen:
- Zeitkritische Arbeit dominiert.
- Interaktive Pfade haben Vorrang.
- Hintergrundarbeit ist verdrängbar.

---

## 4. Fairness ist sekundär

Stabilität schlägt Fairness.

Folgerungen:
- Gleichbehandlung ist kein Ziel.
- Kritische Pfade dürfen bevorzugt werden.
- Starvation ist erlaubt, Instabilität nicht.

---

## 5. Preemption ist Verlust

Verdrängung zerstört Fortschritt.

Folgerungen:
- Preemption ist zu minimieren.
- Kurze, abgeschlossene Einheiten sind vorzuziehen.
- Lange, nicht unterbrechbare Arbeit ist verboten.

---

## 6. Arbeitseinheiten sind endlich

Jede Arbeitseinheit benötigt klare Grenzen.

Folgerungen:
- Unbegrenzte Tasks sind verboten.
- Fortschritt muss messbar sein.
- Abbruchpfade sind Pflicht.

---

## 7. Rückstau ist korrektes Verhalten

Backlog signalisiert physikalische Grenzen.

Folgerungen:
- Rückstau ist sichtbar zu machen.
- Ablehnung ist besser als Überlast.
- Drop vor Chaos.

---

## 8. Zeitbudget ist verbindlich

Jede Arbeit erhält ein Zeitbudget.

Folgerungen:
- Budgetüberschreitung ist ein Fehler.
- Arbeit darf gestoppt werden.
- Elastizität ist explizit zu definieren.

---

## 9. Koordination kostet Zeit

Abstimmung zwischen Einheiten erzeugt Overhead.

Folgerungen:
- Zentrale Koordination ist teuer.
- Lokale Entscheidungen sind stabiler.
- Globale Locks sind verboten.

---

## 10. Reihenfolge ist ein Vertrag

Ausführungsreihenfolge beeinflusst Ergebnis.

Folgerungen:
- Ordnung ist explizit festzulegen.
- Implizite Reihenfolgen sind verboten.
- Nebenläufigkeit ohne Ordnung ist instabil.

---

## 11. Stillstand ist ein Zustand

Idle ist kein Fehler.

Folgerungen:
- Leerlauf ist energetisch korrekt.
- Künstliche Auslastung ist verboten.
- Ruhe stabilisiert Systeme.

---

## 12. Messung steuert Scheduling

Ohne Messung keine Planung.

Folgerungen:
- Laufzeiten sind zu erfassen.
- Abweichungen sind zu reagieren.
- Planung ohne Rückkopplung ist blind.

---

## 13. Architekturbindung

CommanderLink Scheduling bindet sich an:

- reale CPU-Kerne
- bekannte Preemption-Mechanismen
- messbare Laufzeiten

Andere Modelle erfordern eigene Gesetze.

---

## 14. Schlussformel

Scheduling entscheidet über Stabilität.

Wer mehr plant als ausführen kann,
verliert Kontrolle über das System.

Dieses Gesetz ist Grundlage aller
Executor-, Loop- und Ablaufmodelle.


<<< END FILE: ./docs/laws/LAW_06_SCHEDULING.md

>>> START FILE: ./docs/laws/LAW_07_IO.md
# LAW_07_IO.md
## CommanderLink – Ein-/Ausgabe-Gesetz (I/O & Gerätepfade)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt alle Formen von Ein- und Ausgabe
zwischen CPU, Speicher und externen Geräten
für CommanderLink.

I/O ist physikalische Interaktion, keine Abstraktion.

---

## 1. I/O ist langsamer als Rechenlogik

Jeder I/O-Vorgang ist teurer als lokale Berechnung.

Folgerungen:
- I/O ist zu minimieren.
- Berechnung vor Transfer.
- Vermeidung schlägt Beschleunigung.

---

## 2. Geräte sind eigenständige Akteure

Geräte besitzen eigene Zustände und Latenzen.

Folgerungen:
- Geräteverhalten ist nicht deterministisch steuerbar.
- Wartezeiten sind real.
- Gerätefehler sind physikalische Zustände.

---

## 3. Pfade bestimmen Kosten

Der I/O-Pfad definiert Latenz und Stabilität.

Folgerungen:
- Direkte Pfade sind vorzuziehen.
- Umwege erhöhen Jitter.
- Verborgene Pfade sind verboten.

---

## 4. DMA ist kein kostenloser Transport

DMA verlagert Arbeit, eliminiert sie nicht.

Folgerungen:
- Cache-Kohärenz kostet Zeit.
- Synchronisation ist verpflichtend.
- Blindes DMA ist verboten.

---

## 5. Blockierende I/O ist Zeitvernichtung

Blockierung hält Ressourcen fest.

Folgerungen:
- Blockierende I/O im Hot-Pfad ist verboten.
- Zeitlich gebundene Operationen sind Pflicht.
- Fortschritt muss beobachtbar sein.

---

## 6. Asynchrone I/O erfordert Kontrolle

Asynchronität erzeugt Nebenläufigkeit.

Folgerungen:
- Rückmeldung ist Pflicht.
- Backpressure ist zwingend.
- Unkontrollierte Parallel-I/O ist verboten.

---

## 7. Puffer sind Zustandsverschiebung

I/O-Puffer verschieben Zeit und Verantwortung.

Folgerungen:
- Puffergrößen sind zu begrenzen.
- Implizite Puffer sind verboten.
- Große Puffer erhöhen Latenz.

---

## 8. Reihenfolge ist geräteabhängig

Geräte können Reihenfolgen ändern.

Folgerungen:
- Ordnung darf nicht angenommen werden.
- Explizite Ordnung kostet Zeit.
- Ordnung nur bei Notwendigkeit.

---

## 9. Fehler sind normal

I/O-Fehler entstehen aus Physik.

Folgerungen:
- Fehlerpfade sind gleichwertig.
- Wiederholung ist begrenzt.
- Endlose Retries sind verboten.

---

## 10. Bandbreite ist geteilt

Geräte teilen sich Busse und Controller.

Folgerungen:
- Konkurrenz ist einzukalkulieren.
- Exklusive Annahmen sind verboten.
- Überlast ist sichtbar zu machen.

---

## 11. Initialisierung ist I/O

Geräteinitialisierung kostet Zeit und Energie.

Folgerungen:
- Initialisierung ist zu budgetieren.
- Späte Initialisierung ist riskant.
- On-Demand ohne Grenze ist verboten.

---

## 12. Messung erfolgt am Gerät

I/O-Messung muss gerätenah sein.

Folgerungen:
- Host-Sicht allein ist unzureichend.
- Wartezeiten sind zu messen.
- Worst-Case dominiert.

---

## 13. Architekturbindung

CommanderLink bindet sich an:

- reale Busse und Controller
- bekannte DMA- und Interrupt-Modelle
- messbare Gerätepfade

Abweichungen erfordern neue Gesetze.

---

## 14. Schlussformel

I/O ist die langsamste Wahrheit im System.

Wer I/O unterschätzt,
zerstört Zeit, Energie und Stabilität.

Dieses Gesetz ist Grundlage aller
Geräte-, DMA- und Transferverträge.


<<< END FILE: ./docs/laws/LAW_07_IO.md

>>> START FILE: ./docs/laws/LAW_08_SECURITY.md
# LAW_08_SECURITY.md
## CommanderLink – Sicherheits- & Vertrauens-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Sicherheit, Vertrauen und Integrität
aller Komponenten, Pfade und Interaktionen
in CommanderLink.

Sicherheit ist ein physikalischer und systemischer Zustand,
kein Zusatzmerkmal.

---

## 1. Vertrauen ist nicht implizit

Kein Bestandteil ist per Existenz vertrauenswürdig.

Folgerungen:
- Initialer Zustand ist **nicht vertrauenswürdig**.
- Vertrauen muss explizit entstehen.
- Implizites Vertrauen ist verboten.

---

## 2. Integrität ist physikalisch

Integrität bedeutet Unverändertheit unter realen Bedingungen.

Folgerungen:
- Daten können beschädigt werden.
- Übertragung ist fehleranfällig.
- Speicher ist nicht perfekt.

---

## 3. Sicherheit kostet Ressourcen

Sicherheitsmechanismen verbrauchen Zeit, Energie und Speicher.

Folgerungen:
- Sicherheit ist zu budgetieren.
- Unbudgetierte Sicherheit ist verboten.
- Unsichtbare Kosten sind ein Fehler.

---

## 4. Sichtbarkeit ist Voraussetzung für Sicherheit

Was nicht sichtbar ist, kann nicht geschützt werden.

Folgerungen:
- Sicherheitszustände müssen messbar sein.
- Verdeckte Entscheidungen sind verboten.
- Blindes Vertrauen ist unzulässig.

---

## 5. Authentizität ist eindeutig

Identitäten müssen eindeutig bestimmbar sein.

Folgerungen:
- Mehrdeutige Identitäten sind verboten.
- Identitätswechsel ist ein Zustand.
- Identitätsverlust ist ein Fehler.

---

## 6. Autorisierung ist zustandsabhängig

Berechtigung hängt vom aktuellen Zustand ab.

Folgerungen:
- Statische Berechtigungen sind unzureichend.
- Kontext bestimmt Zugriff.
- Überprivilegierung ist verboten.

---

## 7. Geheimnisse sind Last

Geheime Daten erzeugen dauerhafte Verantwortung.

Folgerungen:
- Geheimnisse sind zu minimieren.
- Lebensdauer ist zu begrenzen.
- Persistenz ohne Notwendigkeit ist verboten.

---

## 8. Kryptographie ist Physik

Kryptographie unterliegt Zeit, Energie und Implementierung.

Folgerungen:
- Kryptographie ist kein Allheilmittel.
- Falsche Nutzung erzeugt Scheinsicherheit.
- Implementierungsfehler sind Sicherheitsfehler.

---

## 9. Fehler sind Angriffsflächen

Fehlerzustände erhöhen Angriffsrisiken.

Folgerungen:
- Fehlerpfade sind abzusichern.
- Undefined Behavior ist verboten.
- Recovery darf keine Lücken öffnen.

---

## 10. Isolation ist relativ

Isolation ist niemals absolut.

Folgerungen:
- Grenzen sind zu definieren.
- Seiteneffekte sind einzukalkulieren.
- Vertrauen endet an der Grenze.

---

## 11. Reduktion schlägt Komplexität

Komplexität ist ein Sicherheitsrisiko.

Folgerungen:
- Minimalismus erhöht Sicherheit.
- Überflüssige Mechanismen sind zu entfernen.
- Vielfalt ohne Kontrolle ist verboten.

---

## 12. Sicherheit ist dynamisch

Sicherheitszustände ändern sich über Zeit.

Folgerungen:
- Vertrauen kann entzogen werden.
- Re-Evaluierung ist Pflicht.
- Dauerhafte Annahmen sind verboten.

---

## 13. Architekturbindung

CommanderLink Sicherheit bindet sich an:

- reale Hardware-Eigenschaften
- messbare Zustände
- explizite Vertrauensübergänge

Abweichungen erfordern neue Gesetze.

---

## 14. Schlussformel

Sicherheit ist kein Zustand, den man erreicht,
sondern ein Zustand, den man aufrechterhält.

Wer Sicherheit voraussetzt,
hat sie bereits verloren.

Dieses Gesetz ist Grundlage aller
Trust-, Join- und Integritätsverträge.


<<< END FILE: ./docs/laws/LAW_08_SECURITY.md

>>> START FILE: ./docs/laws/LAW_09_MEASUREMENT.md
# LAW_09_MEASUREMENT.md
## CommanderLink – Mess- & Wahrheits-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Messung, Beobachtung und Ableitung von Wahrheit
in CommanderLink.

Messung ist Teil des Systems,
nicht ein externes Werkzeug.

---

## 1. Ohne Messung keine Wahrheit

Nicht gemessene Zustände sind unbekannt.

Folgerungen:
- Annahmen ohne Messung sind verboten.
- Schätzung ersetzt keine Messung.
- Unsichtbarkeit ist ein Fehlerzustand.

---

## 2. Messung ist invasiv

Jede Messung verändert das System.

Folgerungen:
- Messkosten sind zu budgetieren.
- Messung darf Stabilität nicht gefährden.
- Unkontrollierte Messung ist verboten.

---

## 3. Messung ist zeitgebunden

Messwerte sind nur zum Messzeitpunkt gültig.

Folgerungen:
- Veraltete Messwerte sind zu kennzeichnen.
- Zeitstempel sind Pflicht.
- Kontextlose Messungen sind wertlos.

---

## 4. Nähe bestimmt Qualität

Je näher die Messung an der Physik,
desto höher ihre Qualität.

Folgerungen:
- Hardware-nahe Messung hat Vorrang.
- Abgeleitete Werte sind sekundär.
- Fernbeobachtung ist degradiert.

---

## 5. Qualität ist explizit

Jeder Messwert besitzt eine Qualitätsstufe.

Folgerungen:
- Direkt gemessen schlägt geschätzt.
- Fehlende Qualität ist ein Fehler.
- Vergleich ohne Qualitätsangabe ist verboten.

---

## 6. Worst-Case ist maßgeblich

Extremwerte bestimmen das Systemverhalten.

Folgerungen:
- Mittelwerte sind informativ, nicht bindend.
- P99/P999 sind Mindestanforderung.
- Ausreißer sind relevante Signale.

---

## 7. Kontinuität schlägt Ereignis

Stetige Messung ist stabiler als punktuelle.

Folgerungen:
- Periodische Erfassung ist Pflicht.
- Ereignisstürme verzerren Realität.
- Lücken sind sichtbar zu machen.

---

## 8. Interpretation ist getrennt von Messung

Messung liefert Daten, nicht Bedeutung.

Folgerungen:
- Rohdaten sind unverfälscht zu erhalten.
- Interpretation ist nachgelagert.
- Vermischung ist verboten.

---

## 9. Aggregation verschleiert Wahrheit

Aggregation verliert Information.

Folgerungen:
- Aggregation ist explizit zu kennzeichnen.
- Rohwerte bleiben zugänglich.
- Überaggregation ist ein Fehler.

---

## 10. Messpfade sind passiv

Messung darf keine Steuerung ausüben.

Folgerungen:
- Beobachter sind lesend.
- Aktive Eingriffe sind getrennt.
- Rückkopplung erfolgt nur über definierte Pfade.

---

## 11. Vollständigkeit ist relativ

Nicht alles ist messbar.

Folgerungen:
- Unmessbares ist zu deklarieren.
- Falsche Genauigkeit ist verboten.
- Unsicherheit ist offen zu legen.

---

## 12. Wahrheit ist konsistent

Widersprüchliche Messungen sind Fehler.

Folgerungen:
- Quellenkonflikte sind sichtbar zu machen.
- Prioritäten sind festzulegen.
- Inkonsistenz erfordert Klärung.

---

## 13. Architekturbindung

CommanderLink Messung bindet sich an:

- hardware-nahe Sensorik
- zeitlich determinierte Erfassung
- explizite Qualitätskennzeichnung

Andere Messmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Was nicht korrekt gemessen wird,
kann nicht kontrolliert werden.

Messung ist die einzige Quelle von Wahrheit.

Dieses Gesetz ist Grundlage aller
Monitoring-, Telemetrie- und Audit-Verträge.


<<< END FILE: ./docs/laws/LAW_09_MEASUREMENT.md

>>> START FILE: ./docs/laws/LAW_10_FAILURE.md
# LAW_10_FAILURE.md
## CommanderLink – Fehler-, Ausfall- & Degradations-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt den Umgang mit Fehlern, Ausfällen,
Degradation und Wiederherstellung
in CommanderLink.

Fehler sind unvermeidliche physikalische Zustände,
keine Sonderfälle.

---

## 1. Fehler sind normal

Fehler entstehen aus Physik, Last und Zeit.

Folgerungen:
- Fehlerfreiheit ist keine Annahme.
- Fehlerzustände sind einplanbar.
- Überraschungsfehler sind Designfehler.

---

## 2. Fehler sind Zustände, keine Ereignisse

Ein Fehler ist ein anhaltender Zustand.

Folgerungen:
- Fehler haben Dauer.
- Übergänge sind explizit.
- Kurzzeitige Maskierung ersetzt keine Behandlung.

---

## 3. Degradation ist korrektes Verhalten

Leistungsreduktion erhält Stabilität.

Folgerungen:
- Degradation ist erlaubt.
- Instabilität ist verboten.
- Volle Leistung ist kein Anspruch.

---

## 4. Fail-Stop schlägt Fail-Chaos

Stillstand ist besser als unkontrolliertes Verhalten.

Folgerungen:
- Kontrollierter Abbruch ist zulässig.
- Ungebremste Weiterverarbeitung ist verboten.
- Schutz geht vor Fortschritt.

---

## 5. Recovery kostet Zeit

Wiederherstellung ist kein Nullkostenpfad.

Folgerungen:
- Recovery ist zu budgetieren.
- Häufiges Recovery ist ein Fehlerindikator.
- Endloses Recovery ist verboten.

---

## 6. Zustand vor Neustart ist relevant

Neustart löscht keine Realität.

Folgerungen:
- Vorzustände sind zu berücksichtigen.
- Blindes Reset ist verboten.
- Persistente Fehler müssen erkannt werden.

---

## 7. Isolation begrenzt Schaden

Fehler dürfen sich nicht unkontrolliert ausbreiten.

Folgerungen:
- Fehlerdomänen sind zu definieren.
- Kaskadierung ist zu verhindern.
- Isolation ist Pflicht.

---

## 8. Zeit bestimmt Fehlerwirkung

Je länger ein Fehler andauert,
desto größer der Schaden.

Folgerungen:
- Früherkennung ist entscheidend.
- Verzögerte Reaktion verschärft Schäden.
- Ignorieren ist verboten.

---

## 9. Teilfunktion schlägt Totalausfall

Reduzierte Funktion ist besser als keine.

Folgerungen:
- Graceful Degradation ist Pflicht.
- Kernfunktionen haben Vorrang.
- Komfortfunktionen sind verzichtbar.

---

## 10. Fehler müssen sichtbar sein

Unsichtbare Fehler sind gefährlich.

Folgerungen:
- Fehlerzustände sind zu messen.
- Maskierung ohne Kennzeichnung ist verboten.
- Beobachtbarkeit ist Pflicht.

---

## 11. Automatik schlägt manuelle Intervention

Automatische Reaktion ist schneller als Mensch.

Folgerungen:
- Automatische Schutzmechanismen sind Pflicht.
- Manuelle Eingriffe sind sekundär.
- Mensch ist nicht im Hot-Pfad.

---

## 12. Fehlerhistorie ist relevant

Vergangene Fehler beeinflussen Zukunft.

Folgerungen:
- Fehlerverläufe sind zu speichern.
- Wiederholungen sind zu erkennen.
- Lernen ist verpflichtend.

---

## 13. Architekturbindung

CommanderLink Fehlerbehandlung bindet sich an:

- reale Ausfallmodi der Hardware
- messbare Zustandsübergänge
- zeitabhängige Wirkung

Andere Modelle erfordern neue Gesetze.

---

## 14. Schlussformel

Ein System ohne Fehlerstrategie
ist bereits gescheitert.

Stabilität entsteht nicht durch Vermeidung von Fehlern,
sondern durch kontrollierten Umgang mit ihnen.

Dieses Gesetz ist Grundlage aller
Fallback-, Gate- und Recovery-Verträge.


<<< END FILE: ./docs/laws/LAW_10_FAILURE.md

>>> START FILE: ./docs/laws/LAW_11_CONTROL.md
# LAW_11_CONTROL.md
## CommanderLink – Steuerungs- & Interlock-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Steuerung, Rückkopplung,
Interlocks und Eingriffsmechanismen
in CommanderLink.

Steuerung ist ein physikalischer Regelkreis,
kein abstraktes Kommandomodell.

---

## 1. Steuerung setzt Messung voraus

Ohne Messung keine Kontrolle.

Folgerungen:
- Unbeobachtete Steuerung ist verboten.
- Steuerentscheidungen ohne aktuelle Daten sind ungültig.
- Verzögerte Messung reduziert Wirksamkeit.

---

## 2. Regelkreise sind zeitabhängig

Jeder Regelkreis besitzt eine Reaktionszeit.

Folgerungen:
- Zu schnelle Regelung erzeugt Instabilität.
- Zu langsame Regelung ist wirkungslos.
- Regelperioden sind explizit festzulegen.

---

## 3. Rückkopplung ist zwingend

Steuerung ohne Rückmeldung ist Blindflug.

Folgerungen:
- Jede Aktion benötigt Feedback.
- Fehlendes Feedback erzwingt Degradation.
- Positive Rückkopplung ist zu begrenzen.

---

## 4. Interlocks haben Vorrang

Interlocks schützen vor physikalischem Schaden.

Folgerungen:
- Interlocks übersteuern Logik.
- Interlocks sind nicht abschaltbar.
- Umgehung ist verboten.

---

## 5. Hysterese ist Pflicht

Sofortige Umschaltung erzeugt Flattern.

Folgerungen:
- Zustandswechsel benötigen Hysterese.
- Grenzwerte sind nicht punktuell.
- Flatterzustände sind Fehler.

---

## 6. Steuerung ist minimal-invasiv

Eingriffe verändern das System.

Folgerungen:
- Kleinster wirksamer Eingriff ist vorzuziehen.
- Übersteuerung ist Ausnahme.
- Dauerhafte Eingriffe sind zu vermeiden.

---

## 7. Lokale Kontrolle schlägt globale

Lokale Regelung ist stabiler als zentrale.

Folgerungen:
- Dezentralität reduziert Latenz.
- Zentrale Steuerung ist teuer.
- Globale Entscheidungen sind begrenzt einzusetzen.

---

## 8. Priorität schützt Kernfunktionen

Nicht alle Funktionen sind gleichwertig.

Folgerungen:
- Schutz kritischer Pfade hat Vorrang.
- Komfortfunktionen sind abschaltbar.
- Steuerung folgt Funktionshierarchie.

---

## 9. Automatik ist der Default

Maschinelle Reaktion ist schneller als Mensch.

Folgerungen:
- Automatische Steuerung ist Pflicht.
- Manuelle Eingriffe sind nachrangig.
- Menschliche Reaktion ist außerhalb des Regelkreises.

---

## 10. Eskalation ist gestuft

Nicht jeder Zustand erfordert Maximalreaktion.

Folgerungen:
- Mehrstufige Reaktion ist Pflicht.
- Sofortiger Hard-Stop nur bei Gefahr.
- Eskalationspfade sind definiert.

---

## 11. Kontrolle ist reversibel

Steuermaßnahmen dürfen rückgängig gemacht werden.

Folgerungen:
- Dauerhafte Sperren sind zu vermeiden.
- Rückkehr in stabilen Zustand ist Ziel.
- Irreversible Eingriffe sind Ausnahmefälle.

---

## 12. Steuerung ist sichtbar

Kontrollzustände müssen beobachtbar sein.

Folgerungen:
- Aktive Interlocks sind sichtbar zu machen.
- Eingriffe sind zu kennzeichnen.
- Unsichtbare Kontrolle ist verboten.

---

## 13. Architekturbindung

CommanderLink Steuerung bindet sich an:

- messbare Zustände
- zeitgebundene Regelkreise
- physikalisch begründete Interlocks

Andere Modelle erfordern neue Gesetze.

---

## 14. Schlussformel

Steuerung entscheidet über Überleben.

Ein System ohne Interlocks
verwechselt Freiheit mit Instabilität.

Dieses Gesetz ist Grundlage aller
Gate-, Budget- und Schutzmechanismen.


<<< END FILE: ./docs/laws/LAW_11_CONTROL.md

>>> START FILE: ./docs/laws/LAW_12_IDENTITY.md
# LAW_12_IDENTITY.md
## CommanderLink – Identitäts- & Existenz-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Identität, Existenz und Zuordnung
aller Einheiten in CommanderLink.

Identität ist eine physikalisch und systemisch
verankerte Eigenschaft, kein symbolischer Name.

---

## 1. Existenz geht Identität voraus

Eine Einheit muss existieren, bevor sie identifiziert werden kann.

Folgerungen:
- Nicht existierende Einheiten sind ungültig.
- Phantom-Identitäten sind verboten.
- Existenz ist messbar.

---

## 2. Identität ist eindeutig

Jede Einheit besitzt genau eine Identität.

Folgerungen:
- Mehrdeutigkeit ist verboten.
- Kollisionen sind Fehlerzustände.
- Identitätswechsel ist ein Ereignis.

---

## 3. Identität ist stabil

Identität ändert sich nicht spontan.

Folgerungen:
- Identitätsänderung ist explizit.
- Implizite Neuzuweisung ist verboten.
- Stabilität schlägt Komfort.

---

## 4. Identität ist lokal verankert

Identität entsteht aus realen Eigenschaften.

Folgerungen:
- Physikalische Merkmale haben Vorrang.
- Abgeleitete Identitäten sind sekundär.
- Rein symbolische Identitäten sind degradiert.

---

## 5. Identität ist überprüfbar

Identität muss validierbar sein.

Folgerungen:
- Nicht prüfbare Identitäten sind unzulässig.
- Validierung ist wiederholbar.
- Einmalige Prüfung ist unzureichend.

---

## 6. Identität ist zustandsabhängig

Identität kann aktiv, passiv oder entzogen sein.

Folgerungen:
- Zustand ist Teil der Identität.
- Ungültige Zustände sind sichtbar zu machen.
- Nutzung ohne gültigen Zustand ist verboten.

---

## 7. Zugehörigkeit ist nicht transitiv

Vertrauen überträgt sich nicht automatisch.

Folgerungen:
- Jede Beziehung ist separat zu bewerten.
- Implizite Gruppenzugehörigkeit ist verboten.
- Kettenvertrauen ist degradiert.

---

## 8. Identität hat Lebenszeit

Identitäten entstehen und enden.

Folgerungen:
- Lebensdauer ist zu definieren.
- Verwaiste Identitäten sind Fehler.
- Wiederverwendung ohne Reset ist verboten.

---

## 9. Mehrfachidentitäten sind explizit

Eine Einheit kann mehrere Rollen haben,
aber keine impliziten Identitäten.

Folgerungen:
- Rollen sind explizit zu deklarieren.
- Überlagerung ohne Trennung ist verboten.
- Konflikte sind sichtbar zu machen.

---

## 10. Identität bestimmt Zugriff

Zugriff ist an Identität gebunden.

Folgerungen:
- Zugriff ohne Identität ist verboten.
- Identitätsverlust entzieht Zugriff.
- Minimaler Zugriff ist Pflicht.

---

## 11. Identität ist beobachtbar

Identitätszustände müssen sichtbar sein.

Folgerungen:
- Aktive Identitäten sind erkennbar.
- Entzogene Identitäten sind markiert.
- Unsichtbare Existenz ist verboten.

---

## 12. Identität ist nicht anonym

Anonymität existiert nicht auf Systemebene.

Folgerungen:
- Jede Aktion ist zuordenbar.
- Unklare Urheberschaft ist ein Fehler.
- Verschleierung ist unzulässig.

---

## 13. Architekturbindung

CommanderLink Identität bindet sich an:

- reale Hardware- oder Systemmerkmale
- deterministische Ableitung
- überprüfbare Zustände

Andere Identitätsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Ohne Identität keine Kontrolle.

Ein System, das nicht weiß, wer handelt,
kann nicht sicher, stabil oder deterministisch sein.

Dieses Gesetz ist Grundlage aller
Join-, Trust- und Zugriffskontrollverträge.


<<< END FILE: ./docs/laws/LAW_12_IDENTITY.md

>>> START FILE: ./docs/laws/LAW_13_STATE.md
# LAW_13_STATE.md
## CommanderLink – Zustands- & Kontinuitäts-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Zustände, Zustandsübergänge
und Kontinuität aller Komponenten in CommanderLink.

Zustand ist eine physikalisch reale Tatsache,
keine logische Abstraktion.

---

## 1. Zustand ist vollständig

Ein Zustand beschreibt die gesamte relevante Realität
einer Einheit zu einem Zeitpunkt.

Folgerungen:
- Teilzustände sind unzulässig.
- Implizite Annahmen sind verboten.
- Unvollständige Zustände sind Fehler.

---

## 2. Zustand ist eindeutig

Zu jedem Zeitpunkt existiert genau ein gültiger Zustand.

Folgerungen:
- Überlagerte Zustände sind verboten.
- Ambivalenz ist ein Fehlerzustand.
- Gleichzeitige Mehrzustände sind unzulässig.

---

## 3. Zustandsübergänge sind diskret

Ein Übergang trennt zwei Zustände eindeutig.

Folgerungen:
- Übergänge sind explizit.
- Implizite Übergänge sind verboten.
- Übergangsdauer ist ein messbarer Zeitraum.

---

## 4. Übergänge kosten Zeit

Jeder Zustandswechsel verbraucht Zeit und Ressourcen.

Folgerungen:
- Übergänge sind zu budgetieren.
- Häufige Wechsel erzeugen Instabilität.
- Flattern ist ein Fehler.

---

## 5. Vorheriger Zustand ist relevant

Der vorherige Zustand beeinflusst den nächsten.

Folgerungen:
- Zustandslosigkeit ist verboten.
- Reset ohne Kontext ist unzulässig.
- Historie beeinflusst Verhalten.

---

## 6. Initialzustand ist definiert

Jede Einheit besitzt einen klaren Anfangszustand.

Folgerungen:
- Implizite Initialisierung ist verboten.
- Unbekannter Startzustand ist ein Fehler.
- Initialzustand ist überprüfbar.

---

## 7. Endzustand ist definiert

Auch Beendigung ist ein Zustand.

Folgerungen:
- Unsauberes Ende ist unzulässig.
- Ressourcenfreigabe ist Teil des Zustands.
- Zombie-Zustände sind verboten.

---

## 8. Zustand ist beobachtbar

Aktuelle Zustände müssen sichtbar sein.

Folgerungen:
- Verborgene Zustände sind verboten.
- Beobachtbarkeit ist Pflicht.
- Verzögerte Sichtbarkeit ist zu kennzeichnen.

---

## 9. Zustand ist konsistent

Zustand darf sich nicht selbst widersprechen.

Folgerungen:
- Inkonsistenz ist ein Fehlerzustand.
- Widersprüche erfordern sofortige Klärung.
- Teilreparaturen sind unzulässig.

---

## 10. Persistenz ist explizit

Nicht jeder Zustand ist persistent.

Folgerungen:
- Persistenz ist zu deklarieren.
- Implizite Persistenz ist verboten.
- Flüchtige Zustände sind kenntlich zu machen.

---

## 11. Zustandskopien sind Momentaufnahmen

Kopierte Zustände altern sofort.

Folgerungen:
- Kopien sind zeitlich gebunden.
- Nutzung ohne Zeitkontext ist verboten.
- Snapshots ersetzen keine Live-Sicht.

---

## 12. Zustand steuert Verhalten

Logik folgt Zustand, nicht umgekehrt.

Folgerungen:
- Verhalten ohne Zustandsbasis ist verboten.
- Zustand bestimmt erlaubte Aktionen.
- Missachtung führt zu Instabilität.

---

## 13. Architekturbindung

CommanderLink Zustandsmodell bindet sich an:

- messbare Systemrealität
- zeitlich diskrete Übergänge
- deterministische Zustandsdefinitionen

Andere Zustandsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Zustand ist die Wahrheit eines Systems.

Ein System ohne klares Zustandsmodell
verliert Kontinuität, Kontrolle und Determinismus.

Dieses Gesetz ist Grundlage aller
Lifecycle-, Recovery- und Kontrollmechanismen.


<<< END FILE: ./docs/laws/LAW_13_STATE.md

>>> START FILE: ./docs/laws/LAW_14_INTERFACE.md
# LAW_14_INTERFACE.md
## CommanderLink – Schnittstellen- & Grenz-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt alle Schnittstellen, Übergänge
und Grenzflächen zwischen Komponenten,
Subsystemen und externen Umgebungen
in CommanderLink.

Eine Schnittstelle ist eine physikalische und logische Grenze,
kein Komfortmechanismus.

---

## 1. Jede Schnittstelle ist eine Grenze

Schnittstellen trennen Verantwortlichkeiten und Zustände.

Folgerungen:
- Grenzen sind explizit zu definieren.
- Implizite Übergänge sind verboten.
- Grenzverletzungen sind Fehler.

---

## 2. Übergänge kosten Zeit und Ressourcen

Jeder Schnittstellenübertritt erzeugt Overhead.

Folgerungen:
- Übergänge sind zu minimieren.
- Ketten von Schnittstellen sind instabil.
- Versteckte Übergänge sind verboten.

---

## 3. Schnittstellen sind Verträge

Eine Schnittstelle definiert erlaubtes Verhalten.

Folgerungen:
- Vertragsverletzungen sind Fehler.
- Kulanzverhalten ist verboten.
- Fehlertoleranz ist explizit zu regeln.

---

## 4. Eingaben sind feindlich

Alle Eingaben gelten als potenziell fehlerhaft.

Folgerungen:
- Validierung ist Pflicht.
- Vertrauen ohne Prüfung ist verboten.
- Grenzprüfung ist nicht optional.

---

## 5. Ausgaben sind verbindlich

Ausgaben haben reale Wirkung.

Folgerungen:
- Falsche Ausgaben sind Fehler.
- Unvollständige Ausgaben sind unzulässig.
- Mehrdeutige Ausgaben sind verboten.

---

## 6. Richtung ist relevant

Schnittstellen sind nicht symmetrisch.

Folgerungen:
- Sender- und Empfängerrollen sind getrennt.
- Verantwortlichkeiten sind eindeutig.
- Umkehr ohne Vertrag ist verboten.

---

## 7. Versionierung ist Zustandswechsel

Änderungen an Schnittstellen sind Zustandsübergänge.

Folgerungen:
- Versionen sind explizit.
- Implizite Änderungen sind verboten.
- Abwärtskompatibilität ist kein Automatismus.

---

## 8. Stabilität schlägt Flexibilität

Stabile Schnittstellen sind wichtiger als flexible.

Folgerungen:
- Erweiterung schlägt Änderung.
- Änderung ist Ausnahme.
- Brechende Änderungen sind sichtbar zu machen.

---

## 9. Fehler gehören zur Schnittstelle

Fehlerfälle sind Teil des Vertrags.

Folgerungen:
- Fehlerausgaben sind definiert.
- Schweigen ist verboten.
- Teilantworten sind kenntlich zu machen.

---

## 10. Schnittstellen sind messbar

Grenzübergänge müssen beobachtbar sein.

Folgerungen:
- Latenz ist zu messen.
- Fehlerquoten sind sichtbar.
- Dunkle Schnittstellen sind verboten.

---

## 11. Isolation ist Pflicht

Schnittstellen begrenzen Schadensausbreitung.

Folgerungen:
- Fehler dürfen Grenzen nicht durchbrechen.
- Seiteneffekte sind zu minimieren.
- Kopplung ist zu reduzieren.

---

## 12. Minimalismus ist Sicherheit

Jede zusätzliche Funktion erhöht Risiko.

Folgerungen:
- Minimale Schnittstellen sind vorzuziehen.
- Überladung ist verboten.
- Unbenutzte Pfade sind zu entfernen.

---

## 13. Architekturbindung

CommanderLink Schnittstellen binden sich an:

- explizite Verträge
- messbare Übergänge
- deterministische Grenzdefinitionen

Andere Schnittstellenmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Schnittstellen entscheiden über Ordnung oder Chaos.

Ein System mit unscharfen Grenzen
kann weder sicher noch stabil sein.

Dieses Gesetz ist Grundlage aller
ABI-, API- und Wire-Verträge.


<<< END FILE: ./docs/laws/LAW_14_INTERFACE.md

>>> START FILE: ./docs/laws/LAW_15_CONFIGURATION.md
# LAW_15_CONFIGURATION.md
## CommanderLink – Konfigurations- & Parameter-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Konfiguration, Parameterisierung
und alle einstellbaren Werte
in CommanderLink.

Konfiguration verändert physikalisches Verhalten
und ist kein Komfortmerkmal.

---

## 1. Konfiguration ist Eingriff

Jede Konfiguration verändert den Systemzustand.

Folgerungen:
- Konfigurationsänderungen sind Zustandswechsel.
- Unbeabsichtigte Änderungen sind Fehler.
- Laufzeitänderungen sind besonders kritisch.

---

## 2. Default ist ein Vertrag

Ein Default-Wert ist eine bewusste Entscheidung.

Folgerungen:
- Defaults müssen stabil sein.
- Unsichere Defaults sind verboten.
- „Unkonfiguriert“ ist kein Zustand.

---

## 3. Konfiguration ist endlich

Nicht alles darf konfigurierbar sein.

Folgerungen:
- Physikalische Grenzen sind nicht konfigurierbar.
- Kernverhalten ist fest.
- Überkonfiguration ist ein Designfehler.

---

## 4. Konfiguration ersetzt keine Logik

Parameter dürfen keine fehlende Steuerung kompensieren.

Folgerungen:
- Parameter ohne Regelkreis sind verboten.
- Manuelle Feinabstimmung ersetzt keine Kontrolle.
- Magische Werte sind unzulässig.

---

## 5. Konfiguration ist deterministisch

Gleiche Konfiguration erzeugt gleiches Verhalten.

Folgerungen:
- Kontextabhängige Interpretation ist verboten.
- Zufällige Initialisierung ist unzulässig.
- Reihenfolgeeffekte sind zu vermeiden.

---

## 6. Konfiguration ist validierbar

Jede Konfiguration muss prüfbar sein.

Folgerungen:
- Ungültige Konfigurationen sind abzulehnen.
- Grenzwerte sind explizit.
- Teilgültigkeit ist verboten.

---

## 7. Konfiguration ist sichtbar

Aktive Konfigurationen müssen beobachtbar sein.

Folgerungen:
- Versteckte Parameter sind verboten.
- Laufende Werte sind einsehbar.
- Abweichungen sind erkennbar.

---

## 8. Konfiguration ist versioniert

Änderungen an Konfigurationen sind nachvollziehbar.

Folgerungen:
- Versionierung ist Pflicht.
- Implizite Migration ist verboten.
- Rollback muss möglich sein.

---

## 9. Konfiguration ist minimal

Weniger Parameter erhöhen Stabilität.

Folgerungen:
- Reduktion schlägt Flexibilität.
- Selten genutzte Parameter sind zu entfernen.
- Sonderfälle sind zu eliminieren.

---

## 10. Konfiguration folgt Physik

Parameter dürfen physikalische Realität nicht verletzen.

Folgerungen:
- Wunschwerte sind irrelevant.
- Physikalische Messung schlägt Konfiguration.
- Konflikte erzwingen Korrektur.

---

## 11. Konfiguration ist kein Geheimnis

Konfiguration ist kein Sicherheitsmechanismus.

Folgerungen:
- Versteckte Werte bieten keine Sicherheit.
- Sicherheit erfolgt an anderer Stelle.
- Obfuskation ist verboten.

---

## 12. Konfiguration endet an der Grenze

Externe Konfiguration darf interne Gesetze nicht brechen.

Folgerungen:
- Schnittstellen begrenzen Konfiguration.
- Überschreibung ohne Vertrag ist verboten.
- Externe Kontrolle ist eingeschränkt.

---

## 13. Architekturbindung

CommanderLink Konfiguration bindet sich an:

- deterministische Parameter
- explizite Validierung
- messbares Verhalten

Andere Konfigurationsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Konfiguration ist Macht über das System.

Wer Konfiguration ungezügelt zulässt,
tauscht Kontrolle gegen Chaos.

Dieses Gesetz ist Grundlage aller
Policy-, Tuning- und Betriebsverträge.


<<< END FILE: ./docs/laws/LAW_15_CONFIGURATION.md

>>> START FILE: ./docs/laws/LAW_16_DEPLOYMENT.md
# LAW_16_DEPLOYMENT.md
## CommanderLink – Ausrollungs- & Betriebs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Auslieferung, Inbetriebnahme,
Betrieb und Stilllegung
von CommanderLink.

Deployment ist ein physikalischer und organisatorischer Eingriff,
kein logistischer Nebenschritt.

---

## 1. Deployment verändert Realität

Jede Ausrollung verändert den Systemzustand.

Folgerungen:
- Deployment ist ein Zustandswechsel.
- Teildeployment ist ein Fehlerzustand.
- Ungesteuertes Deployment ist verboten.

---

## 2. Betrieb ist der Normalzustand

Der Betrieb ist kein Sonderfall.

Folgerungen:
- Betrieb bestimmt Designentscheidungen.
- Testzustände sind degradiert.
- Produktionsrealität hat Vorrang.

---

## 3. Inbetriebnahme ist kritisch

Der Start ist der fragilste Zustand.

Folgerungen:
- Initiale Last ist zu begrenzen.
- Schutzmechanismen sind aktiv.
- Optimismus ist verboten.

---

## 4. Stilllegung ist ein Zustand

Abschaltung ist Teil des Lebenszyklus.

Folgerungen:
- Geordnete Stilllegung ist Pflicht.
- Ressourcenfreigabe ist verbindlich.
- Abbruch ohne Cleanup ist verboten.

---

## 5. Rollout ist gestuft

Großflächige Änderungen erhöhen Risiko.

Folgerungen:
- Stufenweises Ausrollen ist Pflicht.
- Beobachtung zwischen Stufen ist notwendig.
- Sofortige Vollausrollung ist verboten.

---

## 6. Rollback ist Pflicht

Jede Änderung muss rückgängig gemacht werden können.

Folgerungen:
- Rückkehrpfade sind vorzuhalten.
- Einweg-Deployments sind verboten.
- Rollback-Zeit ist zu budgetieren.

---

## 7. Umgebung ist Teil des Systems

Hardware, OS und Topologie beeinflussen Verhalten.

Folgerungen:
- Umgebung ist zu erfassen.
- Annahmen über Umgebung sind verboten.
- Drift ist zu erkennen.

---

## 8. Betrieb erzeugt Verschleiß

Langzeitbetrieb verändert Systeme.

Folgerungen:
- Alterung ist einzukalkulieren.
- Ressourcenverhalten driftet.
- Periodische Neubewertung ist Pflicht.

---

## 9. Automatik schlägt manuelle Pflege

Dauerbetrieb erfordert Automatisierung.

Folgerungen:
- Manuelle Routinen sind fehleranfällig.
- Automatische Überwachung ist Pflicht.
- Mensch ist nicht der Regelkreis.

---

## 10. Updates sind Zustandswechsel

Aktualisierung ist kein Detail.

Folgerungen:
- Updates sind zu planen.
- Nebenwirkungen sind zu erwarten.
- Live-Updates ohne Schutz sind verboten.

---

## 11. Konfigurationsdrift ist Fehler

Abweichungen vom Sollzustand sind kritisch.

Folgerungen:
- Drift ist zu erkennen.
- Selbstheilung ist vorzusehen.
- Stiller Drift ist verboten.

---

## 12. Betrieb ist messpflichtig

Ein System ohne Betriebsdaten ist blind.

Folgerungen:
- Laufzeitmessung ist Pflicht.
- Langzeittrends sind relevant.
- Kurzsichtige Beobachtung ist unzureichend.

---

## 13. Architekturbindung

CommanderLink Betrieb bindet sich an:

- reale Betriebsumgebungen
- messbare Langzeitzustände
- kontrollierte Zustandswechsel

Andere Betriebsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Ein System, das nur im Labor funktioniert,
existiert nicht.

Stabiler Betrieb ist der einzige gültige Beweis
für Korrektheit.

Dieses Gesetz ist Grundlage aller
Release-, Update- und Betriebsverträge.


<<< END FILE: ./docs/laws/LAW_16_DEPLOYMENT.md

>>> START FILE: ./docs/laws/LAW_17_GOVERNANCE.md
# LAW_17_GOVERNANCE.md
## CommanderLink – Entscheidungs-, Autoritäts- & Änderungs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Entscheidungsfindung, Autorität,
Änderungen und Eskalation
innerhalb von CommanderLink.

Governance ist Teil der Systemstabilität,
keine organisatorische Nebensache.

---

## 1. Gesetze stehen über Implementierungen

Gesetze definieren die Realität des Systems.

Folgerungen:
- Implementierungen müssen Gesetzen folgen.
- Abweichungen sind Fehler.
- Nachträgliche Rechtfertigung ist verboten.

---

## 2. Änderungen sind Zustandswechsel

Jede Änderung verändert Systemverhalten.

Folgerungen:
- Änderungen sind explizit zu deklarieren.
- Implizite Änderungen sind verboten.
- Änderung ohne Freigabe ist unzulässig.

---

## 3. Freigabe ist bindend

Nicht freigegebene Artefakte existieren nicht.

Folgerungen:
- Vorläufige Zustände sind gekennzeichnet.
- Nutzung ohne Freigabe ist verboten.
- Freigabe ist ein klarer Akt.

---

## 4. Konsistenz schlägt Fortschritt

Inkonsistenter Fortschritt ist Rückschritt.

Folgerungen:
- Konsistenz hat Vorrang.
- Teilweise Aktualisierung ist verboten.
- Widersprüche sind sofort zu klären.

---

## 5. Autorität ist eindeutig

Entscheidungen benötigen eine klare Quelle.

Folgerungen:
- Mehrfachautorität ist verboten.
- Unklare Zuständigkeit ist ein Fehler.
- Eskalation ist definiert.

---

## 6. Eskalation ist strukturiert

Konflikte werden nicht ignoriert.

Folgerungen:
- Eskalationspfade sind bekannt.
- Blockaden sind sichtbar.
- Stillstand ohne Entscheidung ist verboten.

---

## 7. Rücknahme ist erlaubt

Fehlentscheidungen sind korrigierbar.

Folgerungen:
- Revidieren ist kein Scheitern.
- Festhalten an Fehlern ist verboten.
- Korrektur erfolgt offen.

---

## 8. Dokumente sind Verträge

Schriftliche Artefakte sind bindend.

Folgerungen:
- Unklare Dokumente sind ungültig.
- Widersprüchliche Dokumente sind Fehler.
- Mündliche Annahmen existieren nicht.

---

## 9. Versionierung ist Wahrheit

Der Stand eines Dokuments ist eindeutig.

Folgerungen:
- Versionen sind explizit.
- „Aktuell“ ohne Version ist verboten.
- Historie ist nachvollziehbar.

---

## 10. Stabilität begrenzt Änderung

Nicht alles darf jederzeit geändert werden.

Folgerungen:
- Kern-Gesetze sind stabil.
- Änderungen erfordern Begründung.
- Änderungsdruck ersetzt keine Notwendigkeit.

---

## 11. Transparenz ist Pflicht

Entscheidungen sind nachvollziehbar.

Folgerungen:
- Verborgene Änderungen sind verboten.
- Begründungen sind sichtbar.
- Unklare Motive sind unzulässig.

---

## 12. Governance ist messbar

Auch Entscheidungsprozesse erzeugen Signale.

Folgerungen:
- Verzögerungen sind sichtbar.
- Konflikthäufung ist ein Indikator.
- Governance-Versagen ist ein Systemfehler.

---

## 13. Architekturbindung

CommanderLink Governance bindet sich an:

- verbindliche Gesetze
- explizite Freigaben
- nachvollziehbare Entscheidungen

Andere Governance-Modelle erfordern neue Gesetze.

---

## 14. Schlussformel

Ohne klare Autorität gibt es keine Stabilität.

Ein System ohne Governance
zerfällt nicht technisch,
sondern durch Entscheidungen.

Dieses Gesetz ist Grundlage aller
Freeze-, Review- und Freigabeprozesse.


<<< END FILE: ./docs/laws/LAW_17_GOVERNANCE.md

>>> START FILE: ./docs/laws/LAW_18_DOCUMENTATION.md
# LAW_18_DOCUMENTATION.md
## CommanderLink – Dokumentations- & Wissens-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Erstellung, Pflege und Gültigkeit
aller schriftlichen Artefakte
in CommanderLink.

Dokumentation ist Teil des Systems,
nicht Begleitmaterial.

---

## 1. Dokumentation ist Wahrheitsträger

Was nicht dokumentiert ist, gilt als nicht existent.

Folgerungen:
- Implizites Wissen ist verboten.
- Annahmen ohne Dokument sind ungültig.
- Dokumentation ist bindend.

---

## 2. Gesetze schlagen Erläuterungen

Normative Texte haben Vorrang vor erklärenden.

Folgerungen:
- Gesetze definieren Verhalten.
- Kommentare erklären, ändern aber nichts.
- Widerspruch zugunsten der Norm.

---

## 3. Präzision schlägt Lesbarkeit

Eindeutigkeit hat Vorrang vor Stil.

Folgerungen:
- Mehrdeutige Formulierungen sind verboten.
- Umgangssprache ist unzulässig.
- Interpretationsfreiheit ist ein Fehler.

---

## 4. Vollständigkeit ist Pflicht

Teilwissen erzeugt Fehlverhalten.

Folgerungen:
- Lücken sind explizit zu kennzeichnen.
- Unvollständige Dokumente sind unfertig.
- Schweigen ist kein Default.

---

## 5. Dokumentation ist versioniert

Jeder Stand ist eindeutig identifizierbar.

Folgerungen:
- Versionsangabe ist Pflicht.
- Zeitliche Einordnung ist notwendig.
- „Letzter Stand“ ohne Referenz ist verboten.

---

## 6. Aktualität ist ein Zustand

Veraltete Dokumentation ist ein Fehler.

Folgerungen:
- Drift zwischen System und Text ist unzulässig.
- Änderungen erzwingen Aktualisierung.
- Stille Veralterung ist verboten.

---

## 7. Trennung von Norm und Kommentar

Normative und erklärende Inhalte sind getrennt.

Folgerungen:
- Gesetze enthalten keine Tutorials.
- Beispiele sind nicht normativ.
- Vermischung ist verboten.

---

## 8. Dokumentation ist maschinenlesbar denkbar

Dokumente müssen strukturiert sein.

Folgerungen:
- Klare Kapitelstruktur ist Pflicht.
- Referenzen sind eindeutig.
- Freitext ohne Struktur ist degradiert.

---

## 9. Redundanz ist kontrolliert

Mehrfachnennung erzeugt Inkonsistenz.

Folgerungen:
- Single Source of Truth ist anzustreben.
- Redundanz erfordert Synchronisation.
- Abweichungen sind Fehler.

---

## 10. Dokumentation ist überprüfbar

Texte müssen prüfbar widerspruchsfrei sein.

Folgerungen:
- Selbstwiderspruch ist verboten.
- Querverweise sind korrekt zu halten.
- Ungültige Referenzen sind Fehler.

---

## 11. Dokumentation ist öffentlich im Projekt

Versteckte Dokumente existieren nicht.

Folgerungen:
- Alle bindenden Texte sind auffindbar.
- Private Regeln sind verboten.
- Transparenz ist Pflicht.

---

## 12. Dokumentation endet nicht

Wissen altert, Systeme ändern sich.

Folgerungen:
- Pflege ist dauerhaft.
- Einmal schreiben reicht nicht.
- Stillstand ist Verfall.

---

## 13. Architekturbindung

CommanderLink Dokumentation bindet sich an:

- normative Markdown-Gesetze
- eindeutige Versionierung
- konsistente Terminologie

Andere Dokumentationsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Ein undokumentiertes System
ist nicht kontrollierbar.

Wer Dokumentation vernachlässigt,
überlässt die Wahrheit dem Zufall.

Dieses Gesetz ist Grundlage aller
Review-, Freeze- und Implementierungsphasen.


<<< END FILE: ./docs/laws/LAW_18_DOCUMENTATION.md

>>> START FILE: ./docs/laws/LAW_19_IMPLEMENTATION.md
# LAW_19_IMPLEMENTATION.md
## CommanderLink – Implementierungs- & Ableitungs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt die Ableitung von Implementierungen
aus den CommanderLink-Gesetzen.

Implementierung ist die physikalische Realisierung von Recht,
nicht dessen Interpretation.

---

## 1. Gesetze sind primär

Implementierungen existieren ausschließlich zur Umsetzung der Gesetze.

Folgerungen:
- Implementierungen haben keine Eigenautorität.
- „Funktioniert in der Praxis“ rechtfertigt keinen Gesetzesbruch.
- Optimierung ohne Gesetzesgrundlage ist verboten.

---

## 2. Ableitung ist deterministisch

Aus Gesetzen folgt genau ein erlaubter Lösungsraum.

Folgerungen:
- Mehrdeutige Ableitungen sind unzulässig.
- Implizite Annahmen sind verboten.
- Jeder Designschritt muss rückführbar sein.

---

## 3. Kein Code ohne Gesetz

Code ohne gesetzliche Grundlage ist nicht existent.

Folgerungen:
- Jedes Modul referenziert mindestens ein Gesetz.
- Unreferenzierter Code ist zu entfernen.
- „Vorbereitender Code“ ist verboten.

---

## 4. Implementierung respektiert Physik

Kein Code darf physikalische Realität abstrahieren oder ignorieren.

Folgerungen:
- Worst-Case-Pfad ist maßgeblich.
- Undefined Behavior ist verboten.
- Heuristik ohne Messung ist unzulässig.

---

## 5. Einfachheit ist bindend

Komplexität ist ein Implementierungsrisiko.

Folgerungen:
- Der einfachste gesetzeskonforme Ansatz ist zu wählen.
- Cleverness ohne Notwendigkeit ist verboten.
- Komplexität erfordert explizite Rechtfertigung.

---

## 6. Sichtbarkeit ist Pflicht

Implementiertes Verhalten muss beobachtbar sein.

Folgerungen:
- Stille Effekte sind verboten.
- Interne Zustände sind messbar zu machen.
- Debug-Pfad ist kein Sonderpfad.

---

## 7. Fehlerpfade sind gleichwertig

Fehlerpfade sind Teil der Implementierung.

Folgerungen:
- Fehlerpfade sind vollständig implementiert.
- Abkürzungen im Fehlerfall sind verboten.
- Recovery ist kein Nachgedanke.

---

## 8. Performance ist kein Selbstzweck

Performance dient Stabilität und Determinismus.

Folgerungen:
- Schnell, aber instabil ist ungültig.
- Vorhersagbarkeit schlägt Spitzenleistung.
- Optimierung ohne Messgrundlage ist verboten.

---

## 9. Portabilität ist nachrangig

Physikalische Korrektheit hat Vorrang vor Portabilität.

Folgerungen:
- x86_64 ist Referenzarchitektur.
- Abstraktion darf keine Kosten verschleiern.
- Andere Architekturen benötigen neue Gesetze.

---

## 10. Implementierung ist überprüfbar

Code muss überprüfbar sein.

Folgerungen:
- Klarheit schlägt Kürze.
- Deterministisches Verhalten ist beweisbar.
- Verifikation ist vorgesehen.

---

## 11. Implementierung ist austauschbar

Kein Implementierungsdetail ist sakrosankt.

Folgerungen:
- Austausch ohne Gesetzesänderung ist möglich.
- Lock-in durch Implementation ist verboten.
- Verhalten bleibt konstant.

---

## 12. Freeze ist bindend

Freigegebene Implementierungen sind eingefroren.

Folgerungen:
- Änderungen erfordern neue Freigabe.
- Stillen Drift gibt es nicht.
- Hotfix ohne Gesetz ist verboten.

---

## 13. Architekturbindung

CommanderLink Implementierungen binden sich an:

- x86_64 Physik
- explizite Gesetze
- deterministische Ableitung

Andere Implementierungsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Implementierung ist Ausführung von Recht.

Ein System, das seine Gesetze nicht einhalten kann,
ist nicht falsch implementiert –
es ist falsch entworfen.

Dieses Gesetz ist Grundlage aller
Header-, Code- und Build-Artefakte.


<<< END FILE: ./docs/laws/LAW_19_IMPLEMENTATION.md

>>> START FILE: ./docs/laws/LAW_20_VERIFICATION.md
# LAW_20_VERIFICATION.md
## CommanderLink – Verifikations-, Test- & Beweis-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Verifikation, Test, Nachweis
und Beweisführung
für CommanderLink.

Verifikation ist der Beweis der Gesetzestreue,
nicht eine Qualitätsvermutung.

---

## 1. Verifikation ist Pflicht

Unverifiziertes Verhalten ist ungültig.

Folgerungen:
- Jede relevante Eigenschaft ist zu verifizieren.
- Vertrauen ohne Nachweis ist verboten.
- Nicht prüfbares Verhalten ist unzulässig.

---

## 2. Gesetze definieren Tests

Tests leiten sich aus Gesetzen ab, nicht umgekehrt.

Folgerungen:
- Jeder Test referenziert mindestens ein Gesetz.
- Tests ohne Gesetzesbezug sind zu entfernen.
- Änderung eines Gesetzes erzwingt Testanpassung.

---

## 3. Worst-Case ist der Referenzfall

Verifikation erfolgt am schlimmsten Fall.

Folgerungen:
- Durchschnittstests sind unzureichend.
- Grenzfälle sind Pflicht.
- Erfolg im Best-Case ist irrelevant.

---

## 4. Determinismus ist beweispflichtig

Deterministisches Verhalten muss nachgewiesen werden.

Folgerungen:
- Wiederholbarkeit ist Pflicht.
- Abweichungen sind Fehler.
- Flaky Tests sind unzulässig.

---

## 5. Messung schlägt Simulation

Reale Messung hat Vorrang vor Modellannahmen.

Folgerungen:
- Hardware-nahe Tests sind Referenz.
- Simulation ist degradiert.
- Annahmen ohne Messung sind verboten.

---

## 6. Störung ist Teil des Tests

Tests müssen Störungen einschließen.

Folgerungen:
- Überlast, Hitze, Jitter sind zu provozieren.
- Ideale Bedingungen sind unzureichend.
- Robustheit ist zu beweisen.

---

## 7. Fehlerpfade sind primär

Fehlerpfade sind gleichwertig zu testen.

Folgerungen:
- Fehlerfalltests sind Pflicht.
- Recovery ist zu verifizieren.
- Untestbare Fehlerpfade sind verboten.

---

## 8. Langzeitverhalten ist relevant

Kurztests reichen nicht aus.

Folgerungen:
- Dauerläufe sind Pflicht.
- Drift ist zu erkennen.
- Stabilität über Zeit ist nachzuweisen.

---

## 9. Isolation ist überprüfbar

Grenzen müssen standhalten.

Folgerungen:
- Fehler dürfen Grenzen nicht überschreiten.
- Kaskaden sind zu testen.
- Isolation ohne Nachweis ist ungültig.

---

## 10. Regression ist sichtbar

Einmal korrektes Verhalten bleibt korrekt.

Folgerungen:
- Regressionstests sind Pflicht.
- Stillen Verschlechterungen sind verboten.
- Jede Abweichung ist zu begründen.

---

## 11. Beweise sind reproduzierbar

Nachweise müssen wiederholbar sein.

Folgerungen:
- Testumgebung ist definiert.
- Abhängigkeiten sind dokumentiert.
- Zufälligkeit ist ausgeschlossen.

---

## 12. Verifikation endet nicht

Änderung erzwingt neue Verifikation.

Folgerungen:
- Freigabe ist zeitgebunden.
- Alternde Nachweise sind ungültig.
- Pflege ist dauerhaft.

---

## 13. Architekturbindung

CommanderLink Verifikation bindet sich an:

- reale x86_64 Hardware
- messbare Zustände
- gesetzesgeleitete Testableitung

Andere Verifikationsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Was nicht bewiesen ist,
gilt als falsch.

Verifikation ist kein Schritt im Prozess,
sondern die Existenzbedingung des Systems.

Dieses Gesetz ist Grundlage aller
Test-, Audit- und Freigabeentscheidungen.


<<< END FILE: ./docs/laws/LAW_20_VERIFICATION.md

>>> START FILE: ./docs/laws/LAW_21_SCOPE.md
# LAW_21_SCOPE.md
## CommanderLink – Geltungs-, Abschluss- & Vollständigkeits-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz definiert den Geltungsrahmen,
die Vollständigkeit und den Abschluss
des CommanderLink-Gesetzeswerks.

Es legt fest, wann das System als vollständig,
konsistent und handlungsfähig gilt.

---

## 1. Das Gesetzeswerk ist geschlossen

Die Menge der Gesetze definiert den vollständigen Handlungsraum.

Folgerungen:
- Verhalten außerhalb der Gesetze ist unzulässig.
- Implizite Regeln existieren nicht.
- Ergänzungen erfolgen nur durch neue Gesetze.

---

## 2. Nicht geregeltes Verhalten ist verboten

Fehlende Regel ist kein Freiraum.

Folgerungen:
- Unregulierte Fälle sind Designfehler.
- Schweigen bedeutet Verbot.
- Lücken erzwingen Gesetzeserweiterung.

---

## 3. Gesetze sind hierarchisch konsistent

Alle Gesetze müssen widerspruchsfrei sein.

Folgerungen:
- Niedrigere Gesetze dürfen höhere nicht verletzen.
- Konflikte sind aufzulösen, nicht zu umgehen.
- Inkonsistenz blockiert Implementierung.

---

## 4. Physik bleibt oberste Instanz

Kein Gesetz darf physikalischer Realität widersprechen.

Folgerungen:
- LAW_00_PHYSICS ist absolut.
- Ableitung darf Physik nicht relativieren.
- Widerspruch erzwingt Revision.

---

## 5. Vollständigkeit ist überprüfbar

Das Gesetzeswerk muss überprüfbar vollständig sein.

Folgerungen:
- Jeder Systembereich ist abgedeckt.
- Ungeregelte Domänen sind sichtbar.
- „Später klären“ ist unzulässig.

---

## 6. Abschluss ist ein Zustand

Ein freigegebener Gesetzesstand ist ein stabiler Zustand.

Folgerungen:
- Freigabe erzeugt Freeze.
- Änderungen erfordern neue Version.
- Gleichzeitige Stände sind verboten.

---

## 7. Erweiterung ist strukturiert

Neue Gesetze folgen derselben Norm.

Folgerungen:
- Nummerierung ist strikt.
- Geltungsbereich ist explizit.
- Rückwirkung ist ausgeschlossen.

---

## 8. Reduktion ist erlaubt

Gesetze dürfen entfallen, wenn sie obsolet sind.

Folgerungen:
- Entfernung erfordert Begründung.
- Abhängigkeiten sind zu prüfen.
- Stille Streichung ist verboten.

---

## 9. Referenzstand ist eindeutig

Es existiert genau ein aktiver Gesetzesstand.

Folgerungen:
- Mehrdeutige Referenzen sind verboten.
- Implementierung bindet sich an einen Stand.
- Historische Stände sind archiviert.

---

## 10. Gesetze sind zeitlos formuliert

Gesetze beschreiben Prinzipien, keine Versionen.

Folgerungen:
- Temporäre Details sind verboten.
- Zeitabhängige Annahmen sind unzulässig.
- Gültigkeit endet nur durch Revision.

---

## 11. Gesetzesverletzung ist Systemfehler

Abweichung ist kein Feature.

Folgerungen:
- Verletzungen sind sichtbar zu machen.
- Umgehung ist verboten.
- Tolerierung ist unzulässig.

---

## 12. Abschluss definiert Handlungsfähigkeit

Mit Abschluss beginnt Implementierung.

Folgerungen:
- Vor Abschluss kein Code.
- Nach Abschluss ist Code verpflichtend gesetzestreu.
- Parallelität von Gesetz und Code ist verboten.

---

## 13. Architekturbindung

CommanderLink Geltungsrahmen bindet sich an:

- physikalische Realität
- konsistente Gesetzeshierarchie
- explizite Freigabestände

---

## 14. Schlussformel

Ein System ohne klaren Geltungsrahmen
kennt keine Grenze zwischen erlaubt und verboten.

Mit diesem Gesetz ist das Fundament geschlossen.

Alles Weitere ist Ableitung.


<<< END FILE: ./docs/laws/LAW_21_SCOPE.md

>>> START FILE: ./docs/laws/LAW_22_STATUS.md
# LAW_22_STATUS.md
## CommanderLink – Stand-, Abschluss- & Start-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGEGEBEN

---

## 0. Feststellung

Das CommanderLink-Gesetzeswerk ist vollständig.

Alle relevanten Domänen sind normativ geregelt.
Es existieren keine offenen Pflichtgesetze.

---

## 1. Abschlusszustand

Der aktuelle Stand umfasst:

- LAW_00_PHYSICS bis LAW_21_SCOPE
- Geschlossene, widerspruchsfreie Hierarchie
- Vollständige Abdeckung von Physik bis Governance

Dieser Stand ist **handlungsfähig**.

---

## 2. Freeze

Mit diesem Gesetz gilt:

- Gesetzesstand ist eingefroren
- Keine impliziten Ergänzungen
- Keine parallele Gesetzesentwicklung

Änderungen erfordern neue Gesetze
oder eine explizite Revision bestehender.

---

## 3. Startfreigabe

Ab diesem Stand ist erlaubt und verpflichtend:

- Ableitung von Verträgen
- Ableitung von Headern
- Ableitung von Code

Alles Weitere ist Implementierung.

---

## 4. Schlussformel

Ja.

Wir sind auf Stand.

Alles, was folgt, ist Ableitung –  
nicht mehr Definition.


<<< END FILE: ./docs/laws/LAW_22_STATUS.md

>>> START FILE: ./docs/laws/LAW_23_SYMBIONT.md
# LAW_23_SYMBIONT.md
## CommanderLink – Symbiont-Gesetz (Koexistenz mit dem Wirtssystem)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert CommanderLink als **Symbionten**:
ein System, das mit einem Wirt (Hardware + OS + Workloads)
koexistiert, diesen schützt und verstärkt,
ohne ihn zu dominieren.

CommanderLink ist kein Parasit, kein Orchestrator
und kein Ersatz für das Betriebssystem.

---

## 1. Symbiose ist Vorrang

CommanderLink existiert nur im Zusammenspiel mit dem Wirt.

Folgerungen:
- Der Wirt hat Existenzvorrang.
- Selbstschutz des Wirts schlägt Eigeninteresse von CL.
- Verdrängung des Wirts ist verboten.

---

## 2. Nicht-Invasivität ist Grundzustand

Der Default-Zustand ist minimaler Eingriff.

Folgerungen:
- Keine exklusiven Ressourcen ohne Notwendigkeit.
- Kein Dauer-Pinning ohne Rechtfertigung.
- Kein permanenter Hot-Path ohne Nutzen.

---

## 3. Schutz schlägt Leistung

CommanderLink schützt den Wirt vor Instabilität.

Folgerungen:
- Lastreduktion ist Pflicht bei Stress.
- Eigene Arbeit wird zuerst gedrosselt.
- Durchsatzverlust ist akzeptabel, Schaden nicht.

---

## 4. Rückzug ist korrektes Verhalten

CommanderLink muss sich zurückziehen können.

Folgerungen:
- Sofortiger Rückzug bei Interaktivität des Wirts.
- Ressourcenfreigabe ist priorisiert.
- Blockieren des Wirts ist verboten.

---

## 5. Koexistenz mit dem Scheduler

CommanderLink konkurriert nicht blind mit dem OS-Scheduler.

Folgerungen:
- OS-Entscheidungen sind Signale.
- CL passt sich an Preemption an.
- Gegenscheduling ist verboten.

---

## 6. Nutzung freier Kapazität

CommanderLink nutzt bevorzugt ungenutzte Ressourcen.

Folgerungen:
- Idle-Zeiten sind Primärziel.
- Opportunistische Beschleunigung ist erlaubt.
- Zwangsnutzung ist verboten.

---

## 7. Transparenz gegenüber dem Wirt

Der Wirt darf nicht überrascht werden.

Folgerungen:
- Ressourcennutzung ist sichtbar.
- Eingriffe sind nachvollziehbar.
- Verdecktes Verhalten ist verboten.

---

## 8. Reversibilität aller Eingriffe

Jeder Eingriff muss rückgängig gemacht werden können.

Folgerungen:
- Temporäre Maßnahmen sind der Normalfall.
- Dauerhafte Bindungen sind Ausnahmefälle.
- Irreversible Zustände sind verboten.

---

## 9. Eigenbudget ist begrenzt

CommanderLink besitzt ein eigenes Budget.

Folgerungen:
- CPU-, Speicher- und I/O-Budget sind begrenzt.
- Budgetüberschreitung erzwingt Selbstreduktion.
- Fremdbudget darf nicht konsumiert werden.

---

## 10. Eigenwahrnehmung ist Pflicht

CommanderLink überwacht sich selbst.

Folgerungen:
- Eigene Kosten sind messbar.
- Eigene Fehler sind sichtbar.
- Selbstblindheit ist verboten.

---

## 11. Symbiont schlägt Optimierer

CommanderLink optimiert nicht isoliert.

Folgerungen:
- Lokale Optimierung ohne Gesamtsicht ist verboten.
- Nutzen wird systemweit bewertet.
- Schaden am Wirt entwertet jeden Gewinn.

---

## 12. Eskalation nur bei Gefahr

Aktive Eingriffe erfolgen nur bei realem Risiko.

Folgerungen:
- Präventive Dominanz ist verboten.
- Schutzinterlocks haben Vorrang.
- Eingriffstiefe ist proportional.

---

## 13. Lebenszyklus ist gekoppelt

CommanderLink folgt dem Lebenszyklus des Wirts.

Folgerungen:
- Start verzögert sich hinter dem Wirt.
- Shutdown priorisiert den Wirt.
- CL darf keinen Zombie-Zustand erzeugen.

---

## 14. Architekturbindung

CommanderLink als Symbiont bindet sich an:

- reale OS-Scheduler und Ressourcenmodelle
- messbare Systemzustände
- reversible Eingriffsmechanismen

Andere Koexistenzmodelle erfordern neue Gesetze.

---

## 15. Schlussformel

CommanderLink existiert,
um den Wirt stabiler zu machen als ohne ihn.

Wenn der Wirt leidet,
hat CommanderLink versagt.

Dieses Gesetz ist Grundlage aller
Budget-, Shadow-, Reclaim- und Rückzugsmechanismen.


<<< END FILE: ./docs/laws/LAW_23_SYMBIONT.md

>>> START FILE: ./docs/laws/LAW_24_READINESS.md
# LAW_24_READINESS.md
## CommanderLink – Startreife-, Freeze- & Ableitungs-Gesetz (Manifest/Runtime)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert:

1. Welche zusätzlichen Pflichten vor Beginn der Header-Ableitung gelten.
2. Wann die Manifest-Header begonnen werden dürfen.
3. Den verbindlichen Arbeitsablauf von Gesetz → Vertrag → Header → Code.

---

## 1. Nichts Relevantes fehlt, wenn es geregelt ist

CommanderLink gilt als „bereit zur Ableitung“ nur, wenn:

- alle systemkritischen Domänen gesetzlich geregelt sind,
- keine impliziten Annahmen verbleiben,
- und keine Kernbegriffe unbestimmt sind.

Nicht geregeltes Verhalten ist verboten.

---

## 2. Pflichtliste „vor Header“

Vor Beginn der **Manifest-Header** müssen genau diese Punkte als **normative Texte** vorliegen:

1. **Terminologie-Fixierung** (Begriffe, Zustände, Rollen; Single Meaning)
2. **Freeze-Regel** (was ist „freigegeben“, was ist „in Arbeit“)
3. **Policy-vs-Runtime Trennung** (Manifest definiert compile-time Gesetze; Runtime beschreibt Laufzeit-Wahrheit)
4. **Trust/Join Grundsatz** (Default-deny; Übergänge; Entzug)
5. **Budget & Rückzug** (Symbiont-Regelkreis; Prioritäten)
6. **Endianness/Order** (Host-Order intern; Wire-Order explizit)
7. **ABI-Determinismus** (Layout, Größen, Alignment, keine impliziten Pads)

Wenn einer dieser Punkte nicht eindeutig geregelt ist, ist Header-Start verboten.

---

## 3. Header-Startkriterium

Manifest-Header dürfen begonnen werden, wenn:

- LAW_00 bis LAW_24 freigegeben sind,
- keine Widersprüche zwischen Gesetzen existieren,
- und die Pflichtliste „vor Header“ vollständig erfüllt ist.

Ab dann gilt:
- Manifest-Header sind **Ableitung**, nicht Verhandlung.
- Änderungen an Manifest-Headern sind nur über Gesetzesrevision zulässig.

---

## 4. Reihenfolge der Ableitung

Die Ableitung erfolgt strikt in dieser Reihenfolge:

1. Manifest (compile-time Gesetze)
2. Runtime-Verträge (SHM/Wahrheit/Segmente)
3. Common-Mechanik (kleinster gemeinsamer Unterbau)
4. Tools (ABI-Report, Dumper, Validity Gates)
5. Erst danach Data Plane / Link / Flow / Monitor

Abweichung ist verboten.

---

## 5. Arbeitsmodus „Symbiont“

Der Symbiont-Charakter wird vor allem durch diese Ableitungsziele erreicht:

- Budgetierung als primäre Leitplanke
- Rückzug/Degradation als Standardpfad
- Messung als einzige Wahrheit
- Interlocks mit Vorrang
- Reversibilität aller Eingriffe

Jede Header-Entscheidung muss auf diese Ziele rückführbar sein.

---

## 6. Projektzustand (normative Einschätzung)

CommanderLink ist im Kern **richtig** aufgestellt, wenn diese Eigenschaften erfüllt sind:

- Physik-first: Gesetze dominieren jede Implementation.
- Symbiont: Schutz des Wirts ist übergeordnet.
- Determinismus/Worst-Case: keine „best effort“-Lücken.
- Messung/Wahrheit: klare Trennung von Rohdaten und Interpretation.
- Änderungsdisziplin: Freeze/Versionierung/Single Source of Truth.

Wenn eine dieser Eigenschaften praktisch verletzt wird, ist das Projekt nicht „falsch gebaut“, sondern **noch nicht fertig abgeleitet**.

---

## 7. Wann beginnen wir konkret?

Beginn der Manifest-Header ist **jetzt** erlaubt, wenn:

- Du erklärst, dass LAW_00–LAW_24 als Arbeitsstand gelten,
- und wir die Pflichtliste (Abschnitt 2) als bereits erfüllt betrachten.

Ab dem Moment ist der nächste Schritt verbindlich:
**Manifest Paket 0: cl_manifest_base.h + cl_manifest_terms.h (nur Begriffe/Enums/States, keine Runtime-Layouts).**

---

## 8. Schlussformel

Es gibt keine „magische Restliste“ außerhalb der Gesetze.
Was wir beachten müssen, ist Disziplin:

- nichts implizit lassen,
- nichts doppelt definieren,
- nichts ohne Freigabe bauen.

Header beginnen, sobald du den LAW-Stand freigibst.


<<< END FILE: ./docs/laws/LAW_24_READINESS.md

>>> START FILE: ./docs/laws/LAW_25_CONFORMANCE.md
```markdown
# LAW_25_CONFORMANCE.md
## CommanderLink – Konformitäts- & Cacheline-Gesetz (Physics-First Proof)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert, was „konform“ bedeutet, und setzt die
nicht verhandelbaren Prüfkriterien für:

- Physics-first
- x86_64-first
- Cacheline-Exaktheit
- ABI-/Layout-Determinismus

Es beantwortet die Frage „Sind wir fertig?“ ausschließlich über
prüfbare Kriterien.

---

## 1. Law-Bedarf

Es besteht **kein weiterer Pflicht-LAW-Bedarf**, wenn und nur wenn
die in diesem Gesetz festgelegten Konformitätskriterien erfüllt sind.

Wenn ein Kriterium nicht erfüllt ist, besteht automatisch Law-Bedarf:
entweder Revision bestehender Gesetze oder neues Gesetz für die Lücke.

---

## 2. Definition „Physics-first konform“

Ein Artefakt ist Physics-first konform, wenn:

- es keine Annahme über ideale Ressourcen trifft,
- es Worst-Case dominiert,
- es messbasiert steuert,
- es Interlocks respektiert,
- und es reversible Degradation/Rückzug besitzt.

Fehlt eine dieser Eigenschaften, ist es nicht konform.

---

## 3. Definition „Cacheline-exakt“

Cacheline-exakt bedeutet:

- Jede **Hot-/kritische** Einheit ist exakt **64 Byte** groß.
- Jede zusammengesetzte Einheit ist ein **ganzzahliges Vielfaches** von 64 Byte.
- Keine impliziten Pads beeinflussen die Größe.
- Kein Feldlayout ist compiler-abhängig.

„Ungefähr 64B“ ist verboten.

---

## 4. Alignment-Anforderungen (x86_64)

Für CommanderLink gilt normativ:

- **64B** ist die Basiseinheit für Hot-State.
- Alignment auf **64B** ist für Hot-Blöcke Pflicht.
- Strides/Records sind Vielfache von 64B.
- Segment-/Page-Boundaries sind explizit.

Abweichung ist verboten.

---

## 5. SHM-/ABI-Layout-Anforderungen

Für alle SHM-/Runtime-Strukturen gilt:

- Keine `packed`-Layouts.
- Keine Annahmen über fehlendes Compiler-Padding.
- Feldreihenfolge folgt Alignment-Realität.
- End-Padding ist explizit und berechnet, nicht geraten.
- Jede Größe wird durch `_Static_assert` erzwungen.

Wenn ein Struct ohne harte Größenasserts existiert, ist es nicht konform.

---

## 6. „x64 ausgerichtet“ bedeutet 64B, nicht „x64“

Der Begriff „x64 ausgerichtet“ ist in CommanderLink verbindlich als
**64-Byte cacheline aligned** zu verstehen.

Jede andere Interpretation ist verboten.

---

## 7. Konformitätsnachweis ist Pflicht

Konformität ist nur gültig, wenn sie bewiesen ist durch:

- Compile-time Layout-Beweise (Größe/Offset/Alignment)
- Laufzeit-Sanity Checks (optional, aber erlaubt)
- ABI-Report als single source of truth

Ohne Nachweis gilt „nicht konform“.

---

## 8. Aktueller Stand (normative Antwort)

Aus den Gesetzen allein folgt:

- Die Forderung nach Physics-first ist vollständig abgedeckt.
- Die Forderung nach Cacheline-Exaktheit ist vollständig abgedeckt.
- Ob „alles exakt an 64B Cachelines ausgerichtet“ ist,
  kann **nicht** durch Gesetze behauptet werden, sondern nur durch Nachweis.

Daher gilt aktuell normativ:

- **Gesetzlich konformierbar:** JA.
- **Faktisch bewiesen konform:** NUR, wenn ABI-/Layout-Beweise vorliegen.

---

## 9. Startkriterium für Manifest-Header unter Cacheline-Anspruch

Manifest-Header dürfen nur begonnen werden, wenn:

- die Cacheline-Regeln dieses Gesetzes als oberste ABI-Norm akzeptiert sind,
- und jede geplante Manifest-/Runtime-Struktur
  eine verpflichtende Static-Assert-Strategie besitzt.

---

## 10. Schlussformel

LAW-Bedarf: NEIN, sofern diese Konformitätsdefinition akzeptiert ist.

Physics-first: JA, normativ vollständig.

Cacheline-Exaktheit: als Pflicht definiert,
aber als Tatsache erst bewiesen, wenn der Layout-Nachweis existiert.

Damit ist der nächste zwingende Schritt:
Konformitätsnachweis als Ableitungsartefakt (ABI-Report/Static-Asserts),
und dann Manifest-Header.
```


<<< END FILE: ./docs/laws/LAW_25_CONFORMANCE.md

>>> START FILE: ./docs/laws/LAW_26_LAYOUT.md
# LAW_26_LAYOUT.md
## CommanderLink – Layout-, Padding- & „packed“-Verbot-Gesetz (SHM/ABI)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz regelt verbindlich:

- Struktur-Layout (SHM/ABI)
- Padding/Alignment-Determinismus
- Umgang mit Compiler-Freiheiten
- Verbot von `packed` und verwandten Mechanismen

Ziel: physikalisch korrektes, deterministisches, cacheline-exaktes Layout
ohne Undefined Behavior und ohne implizite Drift.

---

## 1. `packed` ist verboten

Für alle CommanderLink Datenstrukturen gilt:

- `__attribute__((packed))` ist verboten.
- `#pragma pack(...)` ist verboten.
- „packed member access“ in SHM ist verboten.
- Jegliche Form der erzwungenen Misalignment-Serialisierung im Speicherlayout ist verboten.

Begründungen sind irrelevant.
Verstoß ist ein Systemfehler.

---

## 2. Keine impliziten Padding-Annahmen

Es ist verboten anzunehmen, dass:

- der Compiler „kein Padding“ einfügt,
- Padding „schon passt“,
- oder Feldreihenfolgen „egal“ sind.

Feldreihenfolge ist physikalisch wirksam und ist deterministisch zu wählen.

---

## 3. Layout-Determinismus ist Pflicht

Jede SHM-/ABI-relevante Struktur muss:

- Größe deterministisch festlegen,
- Offsets deterministisch festlegen,
- und Alignment-Anforderungen explizit erfüllen.

Für jede Struktur gilt:
- `_Static_assert(sizeof(T) == N)`
- `_Static_assert(_Alignof(T) == A)` sofern relevant
- `_Static_assert(offsetof(T, field) == K)` für kritische Felder

Ohne diese Beweise ist die Struktur ungültig.

---

## 4. Cacheline-Block-Primat (64B)

Für SHM/Runtime gilt:

- 64B ist die atomare Layout-Einheit.
- Hot/Warm/Cold-Einheiten sind 64B-Blöcke.
- Records/Strides sind Vielfache von 64B.

Teil-Cachelines als „Record“ sind verboten.

---

## 5. Zugriffssicherheit schlägt Bitdichte

Bitdichte ist nachrangig gegenüber:

- Alignment-Korrektheit
- Load/Store-Sicherheit
- deterministischem Verhalten

Daher gilt:
- Keine bitfield-basierten SHM-Layouts.
- Keine misaligned Multi-Byte-Felder.
- Keine „Wire-Layout im SHM“.

---

## 6. Wire und SHM sind strikt getrennt

Es ist verboten, Wire-Formate (LE/packed/bitted)
direkt in SHM-Strukturen abzubilden.

Folgerungen:
- Wire ist serialisiert, SHM ist nativ.
- Wire-Parsing/Encoding ist ein expliziter Schritt.
- Endianness-Konversion ist explizit und lokal.

---

## 7. Erlaubte Mittel zur Layout-Fixierung

Erlaubt sind ausschließlich:

- natürliche Feldreihenfolge nach Alignment (u64 → u32 → u16 → u8)
- explizite End-Padding-Felder (z. B. `uint8_t pad[...]`)
- 64B-Normflächen (z. B. `uint8_t raw[64]`) als Blockrahmen
- `_Static_assert`-Beweise

Nicht erlaubt:
- `aligned(64)` auf Substrukturen als Layout-Trick,
  wenn es implizite Padding-Drift erzeugt.
- 0-Byte Pads.
- compilerabhängige Extensions als Ersatz für Beweise.

---

## 8. Alias- und UB-Regeln

Für SHM-Daten gilt:

- Strict-Aliasing-Tricks sind verboten.
- Reinterpret-Casts zur Feldsicht sind verboten, wenn UB möglich ist.
- Notwendige Typumdeutung erfolgt über sichere Mechanik (z. B. Kopiersemantik).

Ein UB-Risiko macht den Datensatz ungültig.

---

## 9. Prüfpflicht

Jede Build-Konfiguration muss Layoutfehler als Hard-Fail behandeln:

- Warnings über „packed member access“ sind Hard-Fail.
- Size/Align/Offset-Drift ist Hard-Fail.
- Unterschiedliche Compiler-Ergebnisse sind Hard-Fail.

Ein Build, der solche Fehler toleriert, ist nicht CommanderLink.

---

## 10. Schlussformel

`packed` ist in CommanderLink nicht nur unerwünscht,
sondern physikalisch unzulässig.

Layout wird nicht „gemacht“,
Layout wird **bewiesen**.

Dieses Gesetz ist Grundlage aller
SHM-, Runtime- und ABI-Verträge.


<<< END FILE: ./docs/laws/LAW_26_LAYOUT.md

>>> START FILE: ./docs/laws/LAW_27_COVERAGE.md
# LAW_27_COVERAGE.md
## CommanderLink – Vollständigkeits-, Abdeckungs- & Konsistenz-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz beantwortet explizit die Frage:

> „Was ist mit allem anderen, was besprochen wurde?“

Es definiert, **was als abgedeckt gilt**, **wo nichts verloren gegangen ist**
und **wie mit bereits Besprochenem normativ umzugehen ist**.

---

## 1. Gesprochenes ohne Gesetz existiert nicht

In CommanderLink gilt:

- Diskussionen
- Architekturgespräche
- Designideen
- Chat-Verläufe
- implizite Übereinkünfte

haben **keine normative Wirkung**, solange sie **nicht als LAW** fixiert sind.

Folgerung:
- Nichts „Fehlendes“ ist vergessen.
- Alles Relevante muss entweder bereits Gesetz sein oder ist bewusst nicht bindend.

---

## 2. Abdeckung der bisher besprochenen Kernthemen

Alle bislang zentral diskutierten Themen sind **gesetzlich abgedeckt**:

### Physik / Hardware
- Physik-first, Worst-Case, Determinismus → LAW_00, LAW_25
- CPU, SIMD, Cachelines, Thermik → LAW_01, LAW_05, LAW_26
- Memory, SHM, ABI, Padding → LAW_02, LAW_25, LAW_26

### Runtime / Verhalten
- Scheduling, Zeit, Rückzug → LAW_04, LAW_06, LAW_23
- Budgetierung, Degradation → LAW_05, LAW_10, LAW_11
- Zustand, Übergänge, Persistenz → LAW_13

### Netzwerk / Wire
- Physik des Drahts, Pacing, Backpressure → LAW_03
- Trennung Wire vs SHM → LAW_26

### Sicherheit / Vertrauen
- Trust, Join, Default-deny → LAW_08, LAW_12
- Sichtbarkeit, Messung → LAW_09

### Projekt- & Arbeitsmodus
- Keine Header vor Gesetzen → LAW_19, LAW_24
- Freeze, Governance, Ableitung → LAW_17, LAW_21, LAW_24
- Dokumentationspflicht → LAW_18

### Symbiont-Prinzip
- Rückzug, Koexistenz, Schutz des Wirts → LAW_23

Es existiert **kein thematisches Loch**.

---

## 3. Implizite Annahmen wurden explizit gemacht

Alle früher impliziten, aber kritischen Punkte sind nun explizit normiert:

- `packed` verboten → LAW_26
- Cacheline = 64B, nicht „x64“ → LAW_25
- Keine impliziten Compiler-Freiheiten → LAW_26
- Keine Best-Effort-Semantik → LAW_00, LAW_10
- Kein Code ohne Gesetz → LAW_19
- Manifest ≠ Runtime → LAW_24

Damit ist **kein impliziter Restbestand** mehr vorhanden.

---

## 4. Was bewusst **kein** LAW ist

Folgende Dinge sind absichtlich **noch keine Gesetze**:

- konkrete Header-Namen
- konkrete Structs
- konkrete Segmente
- konkrete Toolchains
- konkrete Implementierungsdetails

Begründung:
Diese Dinge sind **Ableitung**, nicht Definition.

Sie beginnen **erst jetzt**.

---

## 5. Umgang mit zukünftigem „Das hatten wir doch mal gesagt“

Ab jetzt gilt verbindlich:

- Wenn etwas nicht als LAW existiert, ist es nicht bindend.
- Wenn etwas wichtig wird, entsteht ein neues LAW oder eine Revision.
- Rückgriff auf „frühere Gespräche“ ist unzulässig.

Das schützt das Projekt vor Drift und Erinnerungslücken.

---

## 6. Aktueller Projektzustand (normative Einordnung)

CommanderLink befindet sich jetzt in einem **selten sauberen Zustand**:

- Physikalisch korrekt gedacht
- Juristisch (gesetzlich) geschlossen
- Ableitungsbereit
- Frei von impliziten Altlasten
- Symbiontisch klar positioniert

Das Projekt ist **nicht früh**, sondern **reif**.

---

## 7. Nächster zwingender Schritt

Der nächste **legale** Schritt ist:

**Manifest-Ableitung – Paket 0**
- Begriffe
- Zustände
- Rollen
- Enums
- keine Layouts
- keine Größen
- keine Runtime

Alles andere wäre ein Regelbruch.

---

## 8. Schlussformel

Nichts Wichtiges fehlt.
Nichts Relevantes ist vergessen.
Nichts Implizites bleibt übrig.

Ab hier beginnt nicht mehr Denken,
sondern **Ableitung**.


<<< END FILE: ./docs/laws/LAW_27_COVERAGE.md

>>> START FILE: ./docs/laws/LAW_28_STRUCTURE.md
# LAW_28_STRUCTURE.md
## CommanderLink – Projektverzeichnis- & Artefakt-Struktur-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert die **verbindliche Verzeichnisstruktur**
des CommanderLink-Projekts.

Die Struktur ist kein Ordnungswunsch,
sondern ein **architektonischer Vertrag** zwischen
Gesetzen, Ableitung und Implementierung.

---

## 1. Struktur folgt Ableitung

Die Projektstruktur spiegelt strikt die Ableitungsreihenfolge wider:

1. Gesetze
2. Manifeste (compile-time Wahrheit)
3. Runtime (Laufzeit-Wahrheit)
4. Mechanik
5. Werkzeuge
6. Implementierung
7. Betrieb

Eine Vermischung ist verboten.

---

## 2. Wurzelverzeichnis

Das Projekt besitzt genau ein Wurzelverzeichnis:

```

commanderlink/

```

Alles darunter ist Teil des Systems.
Externe Ablagen sind verboten.

---

## 3. Gesetzesebene (bereits vorhanden)

```

commanderlink/
└── law/
├── LAW_00_PHYSICS.md
├── LAW_01_CPU.md
├── …
└── LAW_28_STRUCTURE.md

```

Regeln:
- `law/` enthält **ausschließlich** normative Markdown-Gesetze.
- Keine Code-Dateien.
- Keine Header.
- Keine Erklärtexte außerhalb der Gesetze.

`law/` ist die oberste Autorität.

---

## 4. Manifest-Ebene (nächster Schritt)

```

commanderlink/
└── manifest/
├── base/
├── terms/
├── policy/
└── manifest.md

```

Normen:
- `manifest/` enthält **compile-time Wahrheit**.
- Keine Runtime-Zustände.
- Keine SHM-Layouts.
- Keine dynamischen Werte.

Unterverzeichnisse:

- `terms/`  
  Begriffe, Rollen, Zustände, Enums (rein semantisch)

- `base/`  
  Grundlegende Festlegungen (Endianness, Größenklassen, Klassen von Blöcken)

- `policy/`  
  Ableitbare Regeln (Budgets, Limits, Profile – ohne Messwerte)

---

## 5. Runtime-Ebene (Wahrheit zur Laufzeit)

```

commanderlink/
└── runtime/
├── abi/
├── shm/
├── state/
└── runtime.md

```

Normen:
- Runtime beschreibt **was ist**, nicht was gelten soll.
- Alle Layouts sind cacheline-exakt.
- Alle Größen sind bewiesen.

Unterverzeichnisse:

- `abi/`  
  ABI-Berichte, Größen-, Offset- und Layout-Beweise

- `shm/`  
  Shared-Memory-Strukturen (physikalische Wahrheit)

- `state/`  
  Zustandsdefinitionen und Übergänge (laufzeitrelevant)

---

## 6. Common-Mechanik

```

commanderlink/
└── common/
├── time/
├── math/
├── bits/
└── common.md

```

Normen:
- Nur mechanische Hilfsmittel.
- Kein Policy-Wissen.
- Kein Runtime-Zustand.

---

## 7. Tools & Verifikation

```

commanderlink/
└── tools/
├── abi-report/
├── shm-dump/
├── validators/
└── tools.md

```

Normen:
- Tools beweisen Gesetze.
- Tools ändern kein Verhalten.
- Tools sind Teil der Verifikation.

---

## 8. Implementierung

```

commanderlink/
└── src/
├── hal/
├── core/
├── flow/
├── link/
├── oracle/
└── src.md

```

Normen:
- Jedes Modul referenziert Gesetze.
- Kein Modul ohne gesetzliche Grundlage.
- Reihenfolge ist bedeutungsvoll.

---

## 9. Monitor & Betrieb

```

commanderlink/
└── monitor/
└── deploy/

```

Normen:
- Monitor ist passiver Leser.
- Deploy enthält keine Logik.
- Betrieb verändert keine Gesetze.

---

## 10. Verbotene Strukturen

Explizit verboten sind:

- `include/` als Sammelbecken
- `utils/` ohne klare Rolle
- `misc/`, `old/`, `tmp/`
- Vermischung von Manifest und Runtime
- Mehrere Wahrheitsorte

---

## 11. Erweiterungsregel

Neue Verzeichnisse sind nur erlaubt, wenn:

- ihre Rolle gesetzlich definiert ist,
- sie eindeutig einer Ebene zugeordnet sind,
- sie keine bestehende Ebene unterlaufen.

---

## 12. Schlussformel

Die Verzeichnisstruktur ist Architektur.

Wer Struktur verwässert,
verletzt Gesetze.

Mit diesem Gesetz ist der Projektkörper definiert.
Der nächste Schritt ist **Manifest/terms/**.


<<< END FILE: ./docs/laws/LAW_28_STRUCTURE.md

>>> START FILE: ./docs/laws/LAW_29_NAMING.md
# LAW_29_NAMING.md
## CommanderLink – Benennungs-, Nummern- & Artefakt-Identitäts-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert verbindlich:

- Benennung von Dateien, Verzeichnissen und Artefakten
- Nummern- und Versionsdisziplin
- Identität von Manifest/Runtime/Common/Tools/Source
- Regeln für Erweiterung ohne Drift

Ziel: keine Mehrdeutigkeit, keine Nebenwahrheiten, keine „Ordnung nach Gefühl“.

---

## 1. Dateinamen sind Verträge

Ein Dateiname muss Rolle und Ebene erkennen lassen.

Folgerungen:
- Mehrdeutige Namen sind verboten.
- Sammelnamen sind verboten.
- Umbenennung ist ein Zustandswechsel.

---

## 2. Gesetzesdateien

Gesetze folgen strikt:

- `LAW_XX_<THEMA>.md`
- `XX` ist zweistellig, aufsteigend, ohne Lücken im aktiven Stand.
- `<THEMA>` ist großgeschrieben, ASCII, `_` als Trenner.

Beispiele:
- `LAW_00_PHYSICS.md`
- `LAW_26_LAYOUT.md`

---

## 3. Manifest-Artefakte

Manifest-Dateien folgen strikt:

- Präfix `clm_` (CommanderLink Manifest)
- Suffix nach Rolle: `_terms`, `_base`, `_policy`
- Keine Runtime-Inhalte.

Beispiele (normativ):
- `clm_terms_*.h`
- `clm_base_*.h`
- `clm_policy_*.h`

Ein Manifest-Artefakt ist ungültig, wenn es Laufzeit-Wahrheit enthält.

---

## 4. Runtime-Artefakte

Runtime-Dateien folgen strikt:

- Präfix `clr_` (CommanderLink Runtime)
- Suffix nach Rolle: `_abi`, `_shm`, `_state`

Beispiele (normativ):
- `clr_abi_*.h`
- `clr_shm_*.h`
- `clr_state_*.h`

Runtime-Artefakte enthalten nur Laufzeit-Wahrheit, keine Policy.

---

## 5. Common-Artefakte

Common-Dateien folgen strikt:

- Präfix `clc_` (CommanderLink Common)
- Mechanik-orientierte Namen
- Keine Policy, keine Runtime-Zustände

Beispiele:
- `clc_time_*.h`
- `clc_bits_*.h`

---

## 6. Tools

Tools folgen strikt:

- Präfix `clt_` (CommanderLink Tool)
- Name beschreibt Ausgabe, nicht Methode.

Beispiele:
- `clt_abi_report`
- `clt_shm_dump`
- `clt_validator_*`

---

## 7. Source-Module

Source-Module folgen strikt:

- Verzeichnis = Rolle (`hal`, `core`, `flow`, `link`, `oracle`)
- Dateien = eindeutige Funktion, kein „utils“.

Beispiele:
- `hal_sensors.c`
- `link_backend_udp.c`

Sammeldateien sind verboten.

---

## 8. Keine Doppelwahrheit

Für jede Definition gilt:

- exakt ein Ort der Wahrheit
- alle anderen Orte referenzieren

Folgerungen:
- Duplikate sind verboten.
- „Kopie zur Sicherheit“ ist verboten.
- Divergenz ist ein Fehlerzustand.

---

## 9. Versionierung von Ständen

Ein aktiver Stand ist eindeutig:

- Ein LAW-Stand
- Ein Manifest-Stand
- Ein Runtime-Stand

Folgerungen:
- „latest“ ist verboten.
- Versionen sind explizit.
- Mischstände sind unzulässig.

---

## 10. Erweiterungsregeln

Neue Artefakte sind nur erlaubt, wenn:

- ihre Ebene klar ist (LAW/Manifest/Runtime/Common/Tools/Src)
- ihr Name Rolle ausdrückt
- sie keine bestehende Wahrheit duplizieren

---

## 11. Verbotene Namen

Explizit verboten sind:

- `misc`, `tmp`, `old`, `backup`, `test2`, `final_final`
- `helpers`, `common_utils`, `stuff`, `notes`
- `include/` als Sammelbecken
- unnummerierte LAW-Dateien

---

## 12. Schlussformel

Benennung ist Kontrolle.

Wer Namen verwässert,
erzeugt doppelte Wahrheit.

Mit diesem Gesetz sind Identitäten und Namen fixiert.
Der nächste Schritt ist das erste Manifest-Paket
unter `manifest/terms/`.


<<< END FILE: ./docs/laws/LAW_29_NAMING.md

>>> START FILE: ./docs/laws/LAW_30_MANIFEST_START.md
# LAW_30_MANIFEST_START.md
## CommanderLink – Manifest-Start-, Umfangs- & Reinheits-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert **exakt**, wie der Einstieg in die
Manifest-Erstellung erfolgt, **was erlaubt ist**,
**was verboten ist** und **wann ein Manifest als korrekt gilt**.

Es ist das Scharnier zwischen Gesetz und Technik.

---

## 1. Manifest ist Gesetzesableitung

Ein Manifest ist keine Spezifikation,
sondern eine **mechanische Ableitung** der Gesetze.

Folgerungen:
- Manifest verhandelt nichts.
- Manifest erklärt nichts.
- Manifest konkretisiert ausschließlich.

---

## 2. Manifest ist compile-time Wahrheit

Manifest-Inhalte gelten zur Compile-Zeit.

Folgerungen:
- Keine Messwerte.
- Keine Laufzeit-Zustände.
- Keine dynamischen Größen.
- Keine Heuristiken.

Wenn ein Wert erst zur Laufzeit feststeht,
ist er im Manifest verboten.

---

## 3. Erlaubter Inhalt (positiv definiert)

Manifest darf **ausschließlich** enthalten:

- Begriffe (Terms)
- Rollen
- Zustände (symbolisch, nicht numerisch)
- Enums
- Klassen von Größen (z. B. SMALL/MEDIUM/LARGE)
- Symbolische Konstanten ohne physikalische Bedeutung
- Compile-time Flags mit normativer Semantik

Alles andere ist verboten.

---

## 4. Verbotener Inhalt (explizit)

Manifest darf **niemals** enthalten:

- Struct-Layouts
- Größen in Bytes
- Cacheline-Zahlen
- Alignment-Werte
- SHM-Segmente
- Offsets
- Runtime-Counter
- Performance-Werte
- „Optimale“ Parameter

Verstoß ist ein Gesetzesbruch.

---

## 5. Manifest kennt keine Physik-Zahlen

Physik wird **qualitativ**, nicht quantitativ abgebildet.

Beispiel:
- erlaubt: `CACHELINE`
- verboten: `CACHELINE_64B`

Die Quantisierung erfolgt **erst in Runtime/ABI**.

---

## 6. Manifest-Paket 0 (verbindlich)

Der erste Manifest-Schritt ist **festgelegt**:

```

manifest/
└── terms/
├── clm_terms_roles.h
├── clm_terms_states.h
├── clm_terms_domains.h
└── clm_terms_errors.h

```

Diese Dateien enthalten **nur**:
- Enums
- symbolische Namen
- Kommentare mit normativer Bedeutung

Keine Includes außer `<stdint.h>` wenn zwingend nötig.

---

## 7. Reihenfolge ist bindend

Manifest wird in genau dieser Reihenfolge aufgebaut:

1. terms/
2. base/
3. policy/

Ein späterer Schritt darf frühere nicht erweitern oder korrigieren.

---

## 8. Manifest-Freeze

Jedes Manifest-Paket wird eingefroren.

Folgerungen:
- Änderungen erfordern neue Version.
- Kein „Nachziehen“ für Runtime.
- Runtime passt sich Manifest an, nie umgekehrt.

---

## 9. Validitätskriterium

Ein Manifest ist gültig, wenn:

- es vollständig aus Gesetzen ableitbar ist,
- keine Laufzeitannahmen enthält,
- keine impliziten physikalischen Zahlen nutzt,
- und vollständig deterministisch ist.

---

## 10. Schlussformel

Manifest ist der erste Ort,
an dem Gesetze technisch greifbar werden.

Wer im Manifest Physik „vorwegnimmt“,
zerstört die Trennung von Recht und Realität.

Mit diesem Gesetz ist der Startpunkt definiert.

**Nächster erlaubter Schritt:**
`manifest/terms/clm_terms_roles.h`


<<< END FILE: ./docs/laws/LAW_30_MANIFEST_START.md

>>> START FILE: ./docs/laws/LAW_31_TERMS.md
# LAW_31_TERMS.md
## CommanderLink – Terminologie-, Begriffs- & Bedeutungs-Gesetz (Manifest/terms)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz fixiert die **verbindliche Terminologie**
für CommanderLink und definiert,
wie Begriffe im Manifest (`manifest/terms/`) zu entstehen haben.

Ziel: **Single Meaning**.
Kein Begriff darf mehr als eine Bedeutung tragen.
Keine Bedeutung darf mehr als einen Begriff haben.

---

## 1. Begriffe sind Verträge

Ein Begriff ist ein normativer Vertrag.

Folgerungen:
- Begriffe sind präzise.
- Begriffe sind stabil.
- Begriffe sind nicht erklärend, sondern definierend.

Ein unklarer Begriff ist ungültig.

---

## 2. Ein Begriff – eine Bedeutung

Für jeden Begriff gilt:

- exakt **eine** Bedeutung
- keine Synonyme
- keine Mehrfachverwendung in unterschiedlichen Kontexten

Wenn zwei Bedeutungen existieren, müssen zwei Begriffe existieren.

---

## 3. Keine implizite Bedeutung

Begriffe dürfen keine impliziten Annahmen tragen.

Folgerungen:
- Keine Kontextabhängigkeit.
- Keine Abkürzungen mit Deutungsspielraum.
- Keine „offensichtlichen“ Bedeutungen.

Alles ist explizit.

---

## 4. Ebenentrennung der Begriffe

Begriffe sind ihrer Ebene zugeordnet:

- **LAW-Begriffe**: normativ, abstrakt, zeitlos
- **Manifest-Begriffe**: symbolisch, compile-time
- **Runtime-Begriffe**: konkret, messbar, zeitgebunden

Vermischung ist verboten.

---

## 5. Begriffe kennen keine Größen

Im `terms/`-Manifest gilt:

- Keine numerischen Werte mit physikalischer Bedeutung
- Keine Bytes, Hertz, Sekunden
- Keine Cacheline-Größen

Begriffe sind **qualitativ**, nicht quantitativ.

---

## 6. Rollen sind statisch

Rollen beschreiben **was etwas ist**, nicht **was es tut**.

Folgerungen:
- Rollen sind unveränderlich während der Existenz.
- Wechsel der Rolle ist Zustandswechsel.
- Implizite Rollen sind verboten.

---

## 7. Zustände sind exklusiv

Zustände sind **mutual exclusive**.

Folgerungen:
- Ein Objekt befindet sich zu jedem Zeitpunkt in genau einem Zustand.
- Übergänge sind explizit.
- Mehrfachzustände sind verboten.

---

## 8. Domänen sind trennscharf

Domänen trennen Verantwortungsbereiche.

Folgerungen:
- Jede Domäne hat klare Grenze.
- Überschneidung ist verboten.
- Interaktion erfolgt nur über definierte Schnittstellen.

---

## 9. Fehler sind Begriffe, keine Codes

Fehlerbegriffe beschreiben Zustände, keine Reaktionen.

Folgerungen:
- Fehlercodes sind Runtime-Ableitung.
- Begriffe beschreiben Kategorie, nicht Handling.
- Vermischung ist verboten.

---

## 10. Kommentierung ist normativ

Kommentare in `terms/` sind **normativ**.

Folgerungen:
- Kommentare erklären Bedeutung, nicht Nutzung.
- Beispiele sind verboten.
- Implementierungsbezug ist verboten.

---

## 11. Naming-Regeln für `terms/`

Dateien in `manifest/terms/`:

- Präfix `clm_terms_`
- Inhalt: Enums, `typedef enum`, symbolische Konstanten
- Keine Structs
- Keine Layouts
- Keine Includes außer zwingend `<stdint.h>`

---

## 12. Erweiterungsregel

Neue Begriffe dürfen nur hinzugefügt werden, wenn:

- sie keine bestehende Bedeutung duplizieren,
- sie eine Lücke schließen,
- und ihre Ebene eindeutig ist.

Begriffsentfernung ist Revision, kein Patch.

---

## 13. Validitätskriterium

Ein `terms`-Artefakt ist gültig, wenn:

- jeder Begriff eindeutig definiert ist,
- keine numerische Physik enthalten ist,
- keine Runtime-Annahme existiert,
- und keine Überschneidung mit anderen Begriffen besteht.

---

## 14. Schlussformel

Begriffe sind die Atome der Architektur.

Wer Begriffe verwässert,
zerstört Determinismus, Ableitbarkeit und Wahrheit.

Mit diesem Gesetz ist der **Inhalt** von
`manifest/terms/` vollständig normiert.
Der nächste Schritt ist die **konkrete Erstellung**
der `terms`-Dateien.


<<< END FILE: ./docs/laws/LAW_31_TERMS.md

>>> START FILE: ./docs/laws/LAW_32_BASE.md
# LAW_32_BASE.md
## CommanderLink – Basisannahmen-, Klassen- & Quantisierungs-Gesetz (Manifest/base)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert den **Inhalt und die Grenzen**
der Manifest-Ebene `manifest/base/`.

`base/` ist der Ort, an dem **qualitative Klassen**
festgelegt werden, ohne physikalische Zahlen festzuschreiben.

Es ist die **Brücke** zwischen reinen Begriffen (`terms`)
und späterer physikalischer Konkretisierung (Runtime).

---

## 1. `base` ist keine Physik

`manifest/base/` enthält **keine** physikalischen Werte.

Verboten sind:
- Byte-Größen
- Cacheline-Zahlen
- Hertz, Sekunden, Watt
- MTU-Werte
- Limits, die gemessen werden müssen

Physik gehört ausschließlich in Runtime/ABI.

---

## 2. `base` definiert Klassen, nicht Werte

Erlaubt sind ausschließlich **diskrete Klassen**.

Beispiele (qualitativ):
- Größe: SMALL / MEDIUM / LARGE
- Nähe: LOCAL / NEAR / FAR
- Intensität: LOW / NORMAL / HIGH
- Kritikalität: OPTIONAL / IMPORTANT / CRITICAL

Diese Klassen besitzen **keine numerische Bedeutung** im Manifest.

---

## 3. Klassen sind total geordnet

Für jede Klassendefinition gilt:

- vollständige Ordnung
- keine Lücken
- keine Mehrdeutigkeit

Beispiel:
```

LOW < NORMAL < HIGH

```

Teilordnungen oder unordentliche Mengen sind verboten.

---

## 4. Klassen sind abgeschlossen

Eine Klassenmenge ist vollständig.

Folgerungen:
- Keine „sonstigen“ Klassen
- Keine Erweiterung zur Laufzeit
- Neue Klassen erfordern Manifest-Revision

---

## 5. Klassen sind interpretierbar, nicht messbar

Die Abbildung einer Klasse auf Physik erfolgt:

- ausschließlich in Runtime
- zustandsabhängig
- messbasiert

Manifest kennt **keine** Abbildungsfunktion.

---

## 6. Klassen sind kontextgebunden

Eine Klasse ist nur im definierten Kontext gültig.

Folgerungen:
- Keine Wiederverwendung von Klassen mit anderer Bedeutung
- Keine globalen „Universal-Klassen“
- Kontextwechsel erfordert neue Definition

---

## 7. `base` kennt keine Layouts

Explizit verboten in `base/`:

- Structs
- Offsets
- Alignments
- Größenannahmen
- Speichersegmente

`base` beschreibt **Eigenschaften**, nicht Speicher.

---

## 8. Trennung zu `policy`

`base` beschreibt **was existiert**,
`policy` beschreibt **wie entschieden wird**.

Folgerungen:
- `base` enthält keine Regeln
- `base` enthält keine Grenzwerte
- `policy` darf auf `base` referenzieren, nie umgekehrt

---

## 9. Naming-Regeln für `base/`

Dateien in `manifest/base/`:

- Präfix `clm_base_`
- Inhalt: Enums, symbolische Klassen
- Keine Abhängigkeit von Runtime oder Policy

Beispiele:
- `clm_base_size_class.h`
- `clm_base_criticality.h`

---

## 10. Validitätskriterium

Ein `base`-Artefakt ist gültig, wenn:

- jede Klasse qualitativ ist,
- keine physikalische Zahl enthalten ist,
- jede Klasse total geordnet ist,
- und keine Policy enthalten ist.

---

## 11. Schlussformel

`base` ist die letzte abstrakte Schicht
vor der physikalischen Wahrheit.

Wer hier Zahlen einführt,
vermischt Gesetz und Realität.

Mit diesem Gesetz ist die **zweite Manifest-Ebene**
vollständig definiert.

**Nächster erlaubter Schritt:**
`LAW_33_POLICY.md` – Ableitungsregeln ohne Physik.


<<< END FILE: ./docs/laws/LAW_32_BASE.md

>>> START FILE: ./docs/laws/LAW_33_POLICY.md
# LAW_33_POLICY.md
## CommanderLink – Policy-, Entscheidungs- & Ableitungs-Gesetz (Manifest/policy)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert den **Inhalt, die Grenzen und die Disziplin**
der Manifest-Ebene `manifest/policy/`.

`policy/` beschreibt **wie entschieden wird**, nicht **was gemessen wird**
und nicht **wie es implementiert ist**.

---

## 1. Policy ist Ableitung, keine Physik

Policy darf **keine** physikalischen Messwerte enthalten.

Verboten sind:
- konkrete Zahlen (Bytes, Hz, ms, Watt)
- hardwareabhängige Limits
- feste Schwellenwerte

Policy operiert ausschließlich auf:
- Begriffen aus `terms/`
- Klassen aus `base/`
- Zuständen aus `terms/`

---

## 2. Policy ist deterministisch

Gleiche Eingaben → gleiche Entscheidung.

Folgerungen:
- Keine Zufälligkeit
- Keine Zeitabhängigkeit
- Keine impliziten Nebenbedingungen

Nichtdeterministische Policy ist verboten.

---

## 3. Policy ist vollständig

Für jeden erlaubten Eingaberaum existiert eine Entscheidung.

Folgerungen:
- Keine „undefinierten Fälle“
- Kein „best effort“
- Kein Schweigen

Fehlende Regel ist ein Policy-Fehler.

---

## 4. Policy ist zustandsbasiert

Entscheidungen hängen vom **Zustand** ab, nicht von Wunschwerten.

Folgerungen:
- Zustand bestimmt Handlungsspielraum
- Policy kennt Übergänge, keine Aktionen
- Aktionen sind Runtime-Ableitung

---

## 5. Policy ist monotone Ordnung

Policy darf keine widersprüchlichen Entscheidungen erzeugen.

Folgerungen:
- Verschärfung führt nie zu Lockerung
- Degradation ist einseitig
- Eskalation ist gerichtet

Zyklen in der Entscheidungslogik sind verboten.

---

## 6. Policy kennt Prioritäten

Nicht alle Ziele sind gleichwertig.

Bindende Reihenfolge:
1. Physikalische Sicherheit
2. Stabilität des Wirts (Symbiont)
3. Determinismus / Worst-Case
4. Fortschritt / Durchsatz
5. Komfort / Opportunismus

Abweichung ist verboten.

---

## 7. Policy ist reversibel

Policy-Entscheidungen müssen rücknehmbar sein.

Folgerungen:
- Kein irreversibler Zustand
- Rückkehrpfade sind definiert
- Lock-in ist verboten

---

## 8. Policy ist transparent

Policy-Zustände sind sichtbar und erklärbar.

Folgerungen:
- Aktive Policy ist identifizierbar
- Entscheidungsgrundlage ist benennbar
- Verdeckte Policy ist verboten

---

## 9. Policy ist schmal

Policy enthält **nur** Entscheidungsregeln.

Verboten sind:
- Implementierungshinweise
- Optimierungstipps
- Workarounds
- Sonderfälle ohne Gesetzesbezug

Ein schlanker Policy-Raum ist stabiler.

---

## 10. Trennung zu Runtime

Policy entscheidet **was gelten soll**,
Runtime entscheidet **was tatsächlich passiert**.

Folgerungen:
- Policy kennt keine Messung
- Runtime kennt keine Normsetzung
- Rückkopplung erfolgt über Zustandsabbildung

---

## 11. Naming-Regeln für `policy/`

Dateien in `manifest/policy/`:

- Präfix `clm_policy_`
- Inhalt: Entscheidungsregeln als Enums / Tabellen / Zustandsmatrizen
- Keine Structs mit Layout
- Keine Zahlen mit physikalischer Bedeutung

Beispiele:
- `clm_policy_budget.h`
- `clm_policy_degradation.h`
- `clm_policy_trust.h`

---

## 12. Validitätskriterium

Ein Policy-Artefakt ist gültig, wenn:

- jede Entscheidung deterministisch ist,
- alle Eingabekombinationen abgedeckt sind,
- keine Physik-Zahlen enthalten sind,
- und jede Regel auf Gesetze rückführbar ist.

---

## 13. Schlussformel

Policy ist das letzte Wort **vor** der Realität.

Wer Policy mit Physik vermischt,
verliert Kontrolle über beide.

Mit diesem Gesetz ist die **Manifest-Ebene vollständig**.

**Nächster erlaubter Schritt:**
Freeze von `manifest/terms`, `manifest/base`, `manifest/policy`
und Beginn der **Runtime-Ableitung (ABI/SHM)**.


<<< END FILE: ./docs/laws/LAW_33_POLICY.md

>>> START FILE: ./docs/laws/LAW_34_RUNTIME_START.md
# LAW_34_RUNTIME_START.md
## CommanderLink – Runtime-Start-, Wahrheits- & Ableitungs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert den **Übergang von Manifest zu Runtime**.

Es legt fest:
- was Runtime ist,
- was sie enthalten darf,
- und wie physikalische Wahrheit erstmals **quantisiert** werden darf,
ohne Gesetze oder Manifeste zu verletzen.

---

## 1. Runtime ist Laufzeit-Wahrheit

Runtime beschreibt **was tatsächlich ist**.

Folgerungen:
- Runtime ist messbasiert.
- Runtime ist zeitgebunden.
- Runtime kann sich ändern.

Runtime ist **keine Norm**.

---

## 2. Runtime folgt Manifest strikt

Runtime ist vollständig aus Manifest abzuleiten.

Folgerungen:
- Runtime ergänzt Manifest, widerspricht ihm nie.
- Runtime darf nichts normativ festlegen.
- Runtime darf Manifest nicht „korrigieren“.

Wenn Runtime etwas braucht, das im Manifest fehlt,
ist das Manifest unvollständig.

---

## 3. Physikalische Zahlen entstehen erst hier

Erstmals erlaubt sind nun:

- Byte-Größen
- Cacheline-Größen
- Strides
- Alignment-Werte
- MTU-Werte
- gemessene Limits

Diese Werte sind:
- messbar,
- beweisbar,
- und explizit gebunden an Hardware/Architektur.

---

## 4. Runtime ist architekturgebunden

Runtime ist **nicht portabel per Definition**.

Folgerungen:
- x86_64 ist Referenz.
- Little-Endian ist bindend.
- Cacheline = reale Hardware-Cacheline.
- Abweichende Architekturen erfordern eigene Runtime-Ableitung.

---

## 5. Trennung der Runtime-Ebenen

Runtime gliedert sich strikt in:

```

runtime/
├── abi/     (Beweise, Größen, Offsets)
├── shm/     (physikalische Layouts)
└── state/   (laufzeitliche Zustände)

```

Vermischung ist verboten.

---

## 6. ABI ist Beweis, nicht Meinung

`runtime/abi/` enthält:

- Größenbeweise
- Offset-Beweise
- Alignment-Beweise
- Compile-time Assertions
- maschinenlesbare Reports

ABI-Dateien enthalten **keine Logik**.

---

## 7. SHM ist physikalische Wahrheit

`runtime/shm/` enthält:

- cacheline-exakte Strukturen
- SHM-Segmente
- Record-Strides
- keine Wire-Formate
- keine Policy

Jede SHM-Struktur ist beweispflichtig.

---

## 8. Runtime-Zustand ist konkret

`runtime/state/` enthält:

- konkrete Zustandsrepräsentationen
- numerische Counter
- Messwerte
- Historie

State ist beobachtbar, nicht normativ.

---

## 9. Runtime ist dynamisch, Manifest ist statisch

Folgerungen:
- Runtime kann wechseln.
- Manifest ist eingefroren.
- Policy wird interpretiert, nicht verändert.

---

## 10. Runtime kennt Fehler

Runtime darf und muss:

- ungültige Zustände ausdrücken,
- Degradation abbilden,
- Rückzug anzeigen.

Fehler sind Teil der Wahrheit.

---

## 11. Runtime ist messpflichtig

Jeder relevante Runtime-Wert muss:

- messbar sein,
- zeitlich referenziert sein,
- qualitativ gekennzeichnet sein.

Unmessbare Runtime ist verboten.

---

## 12. Validitätskriterium

Runtime-Ableitung ist gültig, wenn:

- jede physikalische Zahl erklärbar ist,
- jede Struktur cacheline-exakt ist,
- jede Abweichung vom Ideal messbasiert ist,
- und kein Manifest verletzt wird.

---

## 13. Schlussformel

Runtime ist der Moment,
in dem CommanderLink Realität akzeptiert.

Ab hier zählt nur noch:
Messung, Physik und Beweis.

Mit diesem Gesetz ist der Einstieg in
`runtime/abi/` und `runtime/shm/` erlaubt.

**Nächster zwingender Schritt:**
`LAW_35_ABI.md` – formale ABI- und Beweisregeln.


<<< END FILE: ./docs/laws/LAW_34_RUNTIME_START.md

>>> START FILE: ./docs/laws/LAW_35_ABI.md
# LAW_35_ABI.md
## CommanderLink – ABI-, Größen- & Beweis-Gesetz (Runtime/abi)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert das **ABI** als formalen Beweisraum
für alle physikalischen und strukturellen Eigenschaften
der CommanderLink-Runtime.

ABI ist kein Header-Design,
sondern **Nachweis der Wahrheit**.

---

## 1. ABI ist bindend

Das ABI ist der verbindliche Vertrag zwischen:

- Manifest
- Runtime
- Implementierung
- Tools
- Monitor

Folgerungen:
- ABI-Widerspruch ist Systemfehler.
- Implementierung ohne ABI-Nachweis ist ungültig.
- ABI hat Vorrang vor Code.

---

## 2. ABI ist vollständig

Für jedes runtime-relevante Artefakt gilt:

- Größe ist festgelegt
- Alignment ist festgelegt
- Offsets sind festgelegt
- Endianness ist festgelegt

Unvollständiges ABI ist ungültig.

---

## 3. Cacheline ist die Basiseinheit

Für x86_64 gilt normativ:

- Cacheline = reale Hardware-Cacheline
- Hot-/kritische Blöcke = exakt 1 Cacheline
- Records/Strides = Vielfache der Cacheline

Teil-Cachelines sind verboten.

---

## 4. Beweis ist verpflichtend

Jede ABI-Eigenschaft muss bewiesen werden durch:

- `_Static_assert(sizeof(T) == N)`
- `_Static_assert(_Alignof(T) == A)`
- `_Static_assert(offsetof(T, field) == K)` für kritische Felder

Ohne Beweis gilt die Eigenschaft als nicht existent.

---

## 5. Keine impliziten Compiler-Freiheiten

Es ist verboten, sich auf:

- implizites Padding
- implizite Alignment-Anpassung
- „übliche“ Compiler-Layouts

zu verlassen.

ABI muss unabhängig vom Compiler stabil sein.

---

## 6. Feldreihenfolge ist Teil des ABI

Die Reihenfolge der Felder ist normativ.

Folgerungen:
- Reordering ist ABI-Bruch.
- Einfügen von Feldern ist ABI-Bruch.
- Entfernen von Feldern ist ABI-Bruch.

ABI-Brüche erfordern neue Version.

---

## 7. Endianness ist explizit

Für Runtime/ABI gilt:

- Host-Order intern
- Keine implizite Konversion
- Wire-Order ist kein ABI-Thema

Vermischung ist verboten.

---

## 8. Keine `packed`-Layouts

Bestätigung von LAW_26:

- `packed` ist verboten
- Misaligned Access ist verboten
- ABI erzwingt natürliche Alignment-Regeln

Abweichung ist ungültig.

---

## 9. ABI kennt Versionen

Jeder ABI-Stand ist eindeutig:

- ABI-Version ist explizit
- ABI-Version ist monoton
- Mehrere ABI-Stände parallel sind verboten

---

## 10. ABI ist maschinenlesbar

ABI-Artefakte müssen maschinenlesbar sein:

- für Tools
- für Monitor
- für Verifikation

Freitext ersetzt keinen Beweis.

---

## 11. ABI-Report ist Single Source of Truth

Der ABI-Report enthält:

- alle Größen
- alle Alignments
- alle Offsets
- alle Versionen

Code darf diese Informationen **nicht duplizieren**.

---

## 12. ABI ist testbar

ABI-Eigenschaften müssen:

- beim Build geprüft werden
- bei Abweichung den Build abbrechen
- reproduzierbar sein

ABI-Drift ist verboten.

---

## 13. Architekturbindung

Dieses ABI gilt ausschließlich für:

- x86_64
- Little-Endian
- definierte Cacheline-Größe

Andere Architekturen benötigen neues ABI-Gesetz.

---

## 14. Schlussformel

ABI ist Beweis, nicht Behauptung.

Ein System ohne bewiesenes ABI
existiert nicht deterministisch.

Mit diesem Gesetz ist der formale Rahmen
für `runtime/abi/` vollständig.

**Nächster erlaubter Schritt:**
`LAW_36_SHM.md` – physikalische Shared-Memory-Strukturen.


<<< END FILE: ./docs/laws/LAW_35_ABI.md

>>> START FILE: ./docs/laws/LAW_36_SHM.md
# LAW_36_SHM.md
## CommanderLink – Shared-Memory-, Segment- & Layout-Gesetz (Runtime/shm)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert die **physikalische Shared-Memory-Wahrheit**
von CommanderLink.

SHM ist kein Datencontainer,
sondern ein **direkt abbildbarer Zustand der Maschine**.

---

## 1. SHM ist physikalische Wahrheit

SHM repräsentiert reale Zustände zur Laufzeit.

Folgerungen:
- SHM ist messbasiert.
- SHM ist zeitgebunden.
- SHM ist beobachtbar.

SHM ist **keine Policy** und **kein Manifest**.

---

## 2. SHM ist cacheline-exakt

Für alle SHM-Strukturen gilt:

- Basiseinheit: **64 Byte Cacheline**
- Jede Hot-Einheit = exakt 64B
- Records/Strides = Vielfache von 64B
- Keine Teil-Cachelines

Abweichung ist verboten.

---

## 3. SHM kennt keine `packed`-Layouts

Bestätigung und Anwendung von LAW_26:

- `packed` ist verboten
- Bitfields sind verboten
- Misaligned Access ist verboten

SHM folgt natürlichem Alignment der Hardware.

---

## 4. Layout ist ABI-gebunden

Jedes SHM-Layout:

- ist Teil des ABI
- besitzt harte Größen-, Offset- und Alignment-Beweise
- ist versionsgebunden

Änderungen sind ABI-Brüche.

---

## 5. Wire ≠ SHM

SHM darf **niemals** Wire-Formate abbilden.

Folgerungen:
- Keine serialisierten Header im SHM
- Keine LE/BE-Felder im SHM
- Keine verdichteten Bitformate

Wire wird explizit encodiert/decodiert.

---

## 6. SHM ist segmentiert

SHM besteht aus klar getrennten Segmenten.

Normativ:
- Segmente haben feste Rollen
- Segmente sind unabhängig versionierbar
- Segment-Grenzen sind explizit

Monolithisches SHM ist verboten.

---

## 7. Hot / Warm / Cold Trennung

SHM-Daten sind nach Zugriffshäufigkeit getrennt:

- **Hot**: ständig gelesen (64B)
- **Warm**: regelmäßig gelesen (Vielfache von 64B)
- **Cold**: selten gelesen (Vielfache von 64B)

Vermischung in einer Cacheline ist verboten.

---

## 8. Zugriff ist primär lesend

SHM ist primär ein **Read-Model**.

Folgerungen:
- Leser dominieren
- Schreiber sind begrenzt
- Schreibzugriffe sind kontrolliert

Unkontrolliertes Schreiben ist verboten.

---

## 9. Synchronisation ist explizit

SHM kennt keine implizite Synchronisation.

Folgerungen:
- Atomics sind explizit
- Memory-Order ist explizit
- Konsistenzmodelle sind dokumentiert

„Es funktioniert zufällig“ ist unzulässig.

---

## 10. Zeitbezug ist Pflicht

Jede relevante SHM-Einheit enthält:

- Zeitstempel oder Epoch-Bezug
- Gültigkeitskontext

Zeitlose SHM-Wahrheit ist verboten.

---

## 11. Reclaim ist Teil des Designs

SHM kann teilweise freigegeben werden.

Folgerungen:
- Reclaim-Status ist sichtbar
- Abwesenheit von Segmenten ist ein Zustand
- Zugriff auf reclaimte Segmente ist definiert

Leckender SHM ist verboten.

---

## 12. SHM ist passiv beobachtbar

Externe Leser (Monitor, Tools):

- lesen passiv
- verändern nichts
- verursachen keinen Lock

Beobachtung darf das System nicht stören.

---

## 13. Fehler sind SHM-Zustände

Fehler werden **nicht versteckt**.

Folgerungen:
- Fehlerflags sind explizit
- Inkonsistenzen sind sichtbar
- „Heilung durch Überschreiben“ ist verboten

---

## 14. Validitätskriterium

Ein SHM-Layout ist gültig, wenn:

- jede Einheit cacheline-exakt ist,
- jedes Feld ABI-belegt ist,
- keine Wire-Semantik enthalten ist,
- jede Änderung versioniert ist,
- und alle Beweise existieren.

---

## 15. Architekturbindung

Dieses SHM-Gesetz gilt ausschließlich für:

- x86_64
- Little-Endian
- definierte Cacheline-Größe

Andere Architekturen benötigen eigene SHM-Gesetze.

---

## 16. Schlussformel

SHM ist der Spiegel der Maschine.

Wer SHM wie ein normales Datenmodell behandelt,
verliert Physik, Wahrheit und Determinismus.

Mit diesem Gesetz ist `runtime/shm/`
vollständig normiert.

**Nächster erlaubter Schritt:**
`LAW_37_STATE.md` – konkrete Runtime-Zustände & Übergänge.


<<< END FILE: ./docs/laws/LAW_36_SHM.md

>>> START FILE: ./docs/laws/LAW_37_RUNTIME_STATE.md
# LAW_37_RUNTIME_STATE.md
## CommanderLink – Runtime-Zustands-, Übergangs- & Epoch-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert **konkrete Laufzeitzustände**,
deren Übergänge und zeitliche Gültigkeit
für CommanderLink.

---

## 1. Runtime-Zustand ist konkret

Runtime-Zustände sind numerisch, messbar und zeitgebunden.

Folgerungen:
- Zustände sind nicht symbolisch.
- Zustände altern.
- Zustände können ungültig werden.

---

## 2. Genau ein aktiver Zustand

Zu jedem Zeitpunkt gilt:
- genau ein aktiver Zustand
- optionale historische Zustände

Mehrfachaktive Zustände sind verboten.

---

## 3. Übergänge sind atomar

Zustandswechsel erfolgen atomar oder klar zweistufig.

Folgerungen:
- Halbe Zustände sind verboten.
- Übergangsdauer ist messbar.
- Rollback ist definiert.

---

## 4. Epoch ist Pflicht

Jeder Zustand ist einer Epoch zugeordnet.

Folgerungen:
- Epoch monoton steigend
- Epoch-Wechsel sichtbar
- Epoch-Kollision ist Fehler

---

## 5. Zustand + Epoch = Wahrheit

Ein Zustand ohne Epoch ist bedeutungslos.

---

## 6. Schlussformel

Runtime-Zustände sind die lebende Wahrheit.
Ohne Epoch gibt es keine Zeit, ohne Zeit keine Wahrheit.


<<< END FILE: ./docs/laws/LAW_37_RUNTIME_STATE.md

>>> START FILE: ./docs/laws/LAW_38_BUDGET.md
# LAW_38_BUDGET.md
## CommanderLink – Budget-, Quoten- & Selbstbegrenzungs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 1. Budget ist Pflicht

CommanderLink operiert ausschließlich innerhalb expliziter Budgets.

- CPU
- Memory
- I/O
- Netzwerk

---

## 2. Eigenbudget zuerst

Bei Knappheit wird **zuerst CL selbst reduziert**.

---

## 3. Budget ist hart

Budgetüberschreitung erzwingt Degradation.

---

## 4. Budget ist messbasiert

Schätzung ist verboten.

---

## 5. Schlussformel

Budget ist Selbstdisziplin.
Ohne Budget ist Symbiose unmöglich.


<<< END FILE: ./docs/laws/LAW_38_BUDGET.md

>>> START FILE: ./docs/laws/LAW_39_WIRE.md
# LAW_39_WIRE.md
## CommanderLink – Wire-, Serialisierungs- & Transport-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 1. Wire ist physikalisch getrennt

Wire ist serialisiert, SHM ist nativ.

---

## 2. Wire ist explizit endian-kodiert

Keine implizite Endianness.

---

## 3. Wire ist zeitgebunden

Sequenzen, Epochs, Drops sind sichtbar.

---

## 4. Keine Wire-Logik im SHM

Strikte Trennung.

---

## 5. Schlussformel

Wire ist Übersetzung, nicht Wahrheit.


<<< END FILE: ./docs/laws/LAW_39_WIRE.md

>>> START FILE: ./docs/laws/LAW_40_MONITOR.md
# LAW_40_MONITOR.md
## CommanderLink – Monitor-, Beobachtungs- & Read-Only-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 1. Monitor ist passiv

Monitor liest, niemals schreibt.

---

## 2. Monitor ist vollständig

Alles Relevante ist sichtbar.

---

## 3. Monitor ist ehrlich

Keine Glättung, keine Verschleierung.

---

## 4. Schlussformel

Der Monitor lügt nie.


<<< END FILE: ./docs/laws/LAW_40_MONITOR.md

>>> START FILE: ./docs/laws/LAW_41_TOOLING.md
# LAW_41_TOOLING.md
## CommanderLink – Tool-, Prüf- & Ableitungs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 1. Tools beweisen Gesetze

Tools sind keine Komfortprogramme.

---

## 2. Tools verändern nichts

Read-only oder Build-time only.

---

## 3. Tools sind verpflichtend

Kein Tool → kein Beweis → ungültig.

---

## 4. Schlussformel

Ohne Tools keine Wahrheit.


<<< END FILE: ./docs/laws/LAW_41_TOOLING.md

>>> START FILE: ./docs/laws/LAW_42_FINAL.md
# LAW_42_FINAL.md
## CommanderLink – Abschluss- & Ableitungs-Freigabe-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGEGEBEN

---

## 0. Feststellung

Das CommanderLink-Gesetzeswerk ist vollständig.

---

## 1. Erlaubnis

Ab jetzt erlaubt:
- Manifest schreiben
- Runtime ableiten
- Header erzeugen
- Code implementieren

---

## 2. Verbot

Nicht mehr erlaubt:
- neue implizite Regeln
- Rückgriff auf Chatwissen
- „das hatten wir doch gesagt“

---

## 3. Schlussformel

Die Definition ist abgeschlossen.

Jetzt beginnt **Engineering**.


<<< END FILE: ./docs/laws/LAW_42_FINAL.md

>>> START FILE: ./docs/MEMORY_MODEL.md
# CommanderLink – MEMORY MODEL

## Ziel
Beschreibung des Speicher- und Cache-Modells von CommanderLink.

---

## 1. Cacheline-Primat

- 1 Cacheline = 64 Byte
- Jede Hot-Struktur passt exakt in eine Cacheline
- Kein Objekt überschreitet eine Cacheline ohne Notwendigkeit

---

## 2. Hot / Warm / Cold Trennung

### Hot
- Wird häufig geschrieben
- Atomics erlaubt
- Eigene Cacheline

### Warm
- Periodisch aktualisiert
- Keine Atomics

### Cold
- Statisch / selten geändert
- Strings / Metadaten

---

## 3. False Sharing Verbot

- Keine zwei schreibenden Cores auf derselben Cacheline
- Layout erzwingt Trennung

---

## 4. Zero-Transformation-Prinzip

- Daten werden exakt so verarbeitet, wie sie im Register liegen
- Keine zusätzlichen Kopien
- Keine Umformatierung
- Keine Shifts im Fast-Path

---

## 5. Register-Geometrie

- AVX-512: 64 Byte = 1 ZMM
- CL-Atom = Register-Atom
- Cacheline == Registerbreite

---

## 6. Speicher als Staudamm

- RAM darf aggressiv als Puffer genutzt werden
- Credits bestätigen RAM-Eingang, nicht Disk-Commit
- Disk-I/O entkoppelt vom Netz

---

## 7. Merksatz

> **Die CPU darf niemals auf Speicher warten.**


<<< END FILE: ./docs/MEMORY_MODEL.md

>>> START FILE: ./docs/PROJECT_GUARDRAILS.md
# CommanderLink – Projekt‑Guardrails (Physik‑First, ABI‑First, Security‑First)

Dieses Dokument ist die **verbindliche Arbeitsgrundlage**. Es dient als „Definition of Done“ für Header, Runtime‑ABI und Monitoring.

## 0. Leitprinzip

**Maximum ist Minimum.**  
CL nutzt alle verfügbaren Ressourcen aggressiv **bis** ein Schutz‑Gate greift.  
Sobald ein Gate triggert: **innerhalb eines Ticks** sauber degradiert, nie experimentell.

## 1. Architektur‑Zerlegung (Schlüsseltechnologien)

- **HAL**: Hardware‑Erkennung, Sensor‑Sampling, Feature‑Probing (SSE4/AVX2/AVX‑512/AMX…), Thermik/VRM‑Signale (gefiltert).
- **CORE**: Zustandsautomaten (Cold‑Start, Join, Autopath), deterministische Entscheidungen.
- **LINK**: Transport‑Mechanik (BYPASS/UDP/TCP), MTU‑Negotiation, Grants/Credits.
- **FLOW**: Pacing, Queueing, Backpressure, Kompression/FEC‑Policy, „Shock‑Absorber Mode“ (RAM als Dämpfer).
- **ORACLE**: Bewertung, Empfehlungen, Prognosen (bottleneck inference, health scoring), aber **gedämpft** und explainable.
- **MONITOR**: Sichtbarkeit: *warum* sind wir wo wir sind (Reason/Constraints) + Hardware‑Inventar + Verlauf.
- **RUNTIME/SHM**: ABI‑stabile Wahrheitsschicht (Root/TOC/Segments).

## 2. ABI‑Vertrag für SHM (nicht verhandelbar)

### 2.1 Grundregeln
- **SHM ist Host‑Byteorder** (kein ntohl‑Salat im Monitor).
- **Kein `packed` im SHM.**  
  Stattdessen: explizites Padding + `_Static_assert(sizeof)==…`.
- **Fixe Segmentgrößen** (z. B. 256/512/1024/4096) und **Fix‑Alignment** (mind. 64B; Root 4096).
- **Union‑Normflächen** sind erlaubt/erwünscht:
  - `uint8_t raw[64]`, `raw[256]`, `raw[4096]` als ABI‑Anker
  - darüber strukturierte Sichten (Hot/Warm/Cold)
- **Keine 0‑Sized Arrays**, keine flex arrays in SHM‑Segmenten.
- **Append‑Only**: Felder werden nur hinten ergänzt; für Umbrüche: `schema_version` bump.

### 2.2 Atomics & Memory‑Order
- `_Atomic` nur dort, wo Reader/Writer parallel sind.
- Für jedes Atomic‑Feld: Kommentar, ob `relaxed` genügt oder `acquire/release` benötigt wird.
- `volatile` ist **kein** Synchronisationsersatz.

### 2.3 ABI‑Prüfpflicht
- Jede Änderung an `include/cl_runtime/*` muss durch:
  - `cl_abi_report` (Alignof/sizeof/offsets)
  - `cl_shm_dump` (TOC‑Kohärenz)
  - `make monitor` (Header‑Konsistenz)

## 3. Wire‑Vertrag (OOB / Data‑Plane)

### 3.1 OOB Wire
- Wire‑Structs sind **packed**.
- Zahlenfelder sind **explizit little‑endian** (`*_le`).
- Größen müssen exakt passen: `hdr32`, `beacon64`, `hello128`, `grant128` via `_Static_assert`.

### 3.2 Zero‑Trust: „Beacon ist untrusted“
- **Beacon** dient nur der Sichtbarkeit („seen“) und grobem Capability‑Hinweis.
- **Keine** Autorisierung anhand Beacon.
- Join/Trust entsteht erst via **Hello/Grant** mit Auth‑Tag + Anti‑Replay.

## 4. Join Policy (Security‑First, paranoid)

### 4.1 Ziel
- Kein Fremdgerät darf „aus Versehen“ Partner werden, nur weil es im selben L2/L3 auftaucht.
- Default: **deny**. Allow nur, wenn Join‑Policy es gestattet.

### 4.2 Mindestmechaniken
- `mesh_tag64` als Domain‑Trennung (mehrere Meshes im selben LAN).
- `node_tag64` als Identität.
- Anti‑Replay: monotones `epoch` pro Sender/Peer.
- Auth‑Tag (truncated) für Hello/Grant.
- Rate‑Limit/Backoff: gegen Flood/Join‑Storm.
- Fail‑Safe: bei Unsicherheit → `PASSIVE_MONITORING` oder `OOB_ONLY`.

### 4.3 Praxis‑Szenario: „10G + 1G Mischverkabelung“
- Peers können über unterschiedliche NICs sichtbar sein (10G MikroTik + 1G Fritz‑LAN).
- Join muss explizit entscheiden:
  - **welcher** physische Pfad (NIC/Route) ist „data eligible“
  - welche Pfade sind nur OOB/Discovery
- Ergebnis: kein „Bridging“, kein Default‑Route‑Hack.

## 5. Autopath & Fallback (Stabilität vor Turbo)

- Baseline immer möglich: **UDP**.
- Upgrade auf BYPASS nur nach Probe + Health‑Check + Hysterese.
- Sofort‑Downgrade bei Fehlern (Penalty Box).
- TCP ist Rettungsboot, nicht Standard.

## 6. Sensorik/VRM/Thermik (Reality‑Filter)

- VRM/Board/Power‑Sensoren sind oft noisy.  
  → Sie dürfen **nicht** das Micro‑Pacing im Fast‑Path steuern.
- Regel: VRM/Power ist **Safety Cutoff** mit Hysterese/Glättung (Trend‑Filter).
- Wenn kritisch: sofort dämpfen (Constraints setzen), aber kein Zickzack.

## 7. „Maximum‑Minimum“ Performance‑Policy

- Kompression/FEC/Vector‑Pfad dürfen hochskalieren, wenn:
  - Bottleneck == Netzwerk
  - CPU Budget verfügbar
  - Thermik nicht kritisch
  - User‑Interaktivität nicht leidet (Shadow/Reclaim)
- Wenn Bottleneck == Storage/Senke → Backpressure statt „mehr CPU“.

## 8. Watchdog (geplant / Erweiterung)

- Watchdog darf CL neu starten, weil Fail‑Open das OS stabil hält.
- Jeder Restart muss:
  - Grund/Reason/Constraints loggen (System‑Log‑Ordner)
  - im SHM „Forensics“ die letzten 5 Events führen
  - Monitor: Dashboard‑Status „Watchdog active“ + Historie

## 9. Code‑Stil (menschenlesbar, deutsch dokumentiert)

- Header‑Kommentare und Feld‑Kommentare **Deutsch**.
- Strukturen klar segmentieren (Hot/Warm/Cold).
- Keine „Workarounds“ die ABI verschleiern: jedes Padding ist bewusst und kommentiert.
- PRI‑Makros (`PRIu64` etc.) in Monitor‑Formatierung verwenden.

## 10. Definition of Done (für jede Änderung)

- Kompiliert auf Linux + FreeBSD/GhostBSD + OmniOS (mindestens Header‑/Tool‑Build).
- ABI‑Report: `RESULT: ABI_STABLE`.
- OOB‑Wire: `_Static_assert` für alle Message‑Sizes grün.
- Monitor liest ohne nt…‑Konvertierung und erklärt *warum* (Reason).


<<< END FILE: ./docs/PROJECT_GUARDRAILS.md

>>> START FILE: ./docs/SECURITY_AND_JOIN_POLICY.md
# CommanderLink – SECURITY & JOIN POLICY

## Ziel
Paranoide, deterministische Join-Regeln ohne Heuristik.

---

## 1. Grundsatz

> **Kein Peer ist vertrauenswürdig, bevor er es bewiesen hat.**

---

## 2. Mesh-Identität

- `mesh_tag64`: Domain-Identität
- `node_tag64`: Hardware-Identität

Beide:
- deterministisch
- persistent
- nicht erratbar

---

## 3. Beacon (untrusted)

- Sichtbarkeit
- Caps-Anzeige
- Kein Vertrauen

---

## 4. Hello / HelloAck

- Authentifiziert
- Geometrie-Aushandlung
- Overlay-IP
- Gates

---

## 5. Grant

- Credits
- FEC/CRC-Parameter
- Accept-Mode
- TTL

Ohne gültigen Grant:
- kein Senden

---

## 6. Replay-Schutz

- Epoch pro Peer
- Strict Monotonicity

---

## 7. Fail-Safe

- Bei Fehler → PASSIVE
- Overlay-Routen entfernen
- OS übernimmt

---

## 8. Merksatz

> **Security ist ein Zustand, kein Feature.**


<<< END FILE: ./docs/SECURITY_AND_JOIN_POLICY.md

>>> START FILE: ./docs/SPEC_EXEC_CTX_64.md
# CommanderLink SPEC: Execution Context 64B (Host)

## 1. Status
Normativ. Dieses Dokument definiert das einzige zulässige Host-Objekt für die Fastpath-Verarbeitung: `cl_exec_ctx_64_t`.

## 2. Physikalische Wahrheit
- Der Execution Context ist exakt 64 Byte groß (eine Cacheline).
- `raw[64]` ist die Normfläche. Feldsicht ist sekundär.
- Host-Order ist intern verbindlich.
- Wire-Endianness ist ausschließlich im Wire-Protokoll relevant.

## 3. Verbote
- Keine Pointer im Execution Context.
- Kein `packed`.
- Keine compilerabhängigen Layoutannahmen.
- Keine variablen Längenstrukturen im Context.

## 4. Ingest/Egress
- Ingest expandiert Wire-Header + lokale Metadaten deterministisch in `cl_exec_ctx_64_t`.
- Egress darf ausschließlich aus `cl_exec_ctx_64_t` plus separater Payload-Region erzeugen.
- Der Context ist nie der Payload selbst, sondern die Verarbeitungseinheit/Metadaten.

## 5. SIMD-Prinzip
- SIMD-first: Fastpath arbeitet primär auf `HOT` (16B) und den festen Kopf-Feldern.
- SIMD-Breite (SSE4/AVX2/AVX-512) ist eine Policy/Gate-Entscheidung; der Context bleibt invariant.

## 6. PHV / Zero-Transformation
- `payload_quantum`, `headroom`, `tailroom` sind deterministische Parameter.
- Zero-Transformation ist der Default: Keine impliziten Kopien/Reshapes.
- Transformationen (z.B. LZ4/FEC) sind explizit und müssen über Flags/Policy sichtbar sein.

## 7. Audit/Forensik
- AUX-Felder sind minimal und dürfen den Fastpath nicht destabilisieren.
- Detaillierte Forensik ist außerhalb des 64B-Contexts zu führen (History/Forensics-Segmente).


<<< END FILE: ./docs/SPEC_EXEC_CTX_64.md

>>> START FILE: ./docs/TYPES_AND_ABI.md
# CommanderLink – TYPES & ABI CONTRACT

## Zweck
Dieses Dokument definiert verbindlich,
welche C-Datentypen in CommanderLink erlaubt sind
und wo sie eingesetzt werden dürfen.

Es verhindert ABI-Drift, Padding-Fehler und Plattform-Inkonsistenzen.

---

## 1. Grundregel

> **Shared Memory und Wire sind heilig.**

Alles, was dort liegt, muss:
- exakt
- reproduzierbar
- ABI-stabil
- endian-klar
sein.

---

## 2. Erlaubte Typen in SHM & Wire

### 2.1 Integer

Erlaubt:
- `uint8_t`
- `uint16_t`
- `uint32_t`
- `uint64_t`
- `int16_t`, `int32_t`, `int64_t` (nur wenn nötig)

Nicht erlaubt:
- `int`
- `long`
- `size_t`
- `bool`
- `enum` ohne explizite Größe

---

### 2.2 Atomics

Erlaubt:
- `_Atomic(uint8_t)`
- `_Atomic(uint32_t)`
- `_Atomic(uint64_t)`

Verwendung:
- Counters
- Flags
- Epochs

Nicht erlaubt:
- Atomics auf Structs
- Atomics auf Arrays

---

### 2.3 Bitfelder

**Verboten.**

Bitfelder sind ABI- und Endian-abhängig.

Stattdessen:
- Bitmasken in `uint32_t` oder `uint64_t`

---

### 2.4 Floating Point

In SHM/Wire:
- **verboten**

Stattdessen:
- `*_permille`
- `*_ppm`
- `*_x10`, `*_x100`

---

## 3. Typen im Hot Path (intern)

Erlaubt:
- `uint_fast32_t`, `uint_fast64_t`
- `size_t` (nur lokal)
- `uintptr_t`
- SIMD-Typen (`__m128i`, `__m256i`, `__m512i`)

Nicht erlaubt:
- Speicherung dieser Typen im SHM/Wire

---

## 4. Endianness-Regeln

- SHM: **Host-Order**
- Wire: **Little-Endian** (`*_le`)

Konvertierung:
- Nur an der Wire-Grenze
- Niemals im Monitor

---

## 5. Alignment-Regeln

- Cacheline-Einheiten: exakt 64 Byte
- Root-Strukturen: 4096 Byte
- DMA-Segmente: 4096 Byte

Kein implizites Compiler-Padding erlaubt.

---

## 6. Schema-Versionierung

Jede SHM-Root-Struktur enthält:
- `schema_version`
- `endian_magic`

Neue Felder:
- nur in reservierten Bereichen
- Schema-Version erhöhen

---

## 7. ABI-Tests

Pflicht:
- `_Static_assert(sizeof(...))`
- `_Static_assert(_Alignof(...))`
- `cl_abi_report` grün

Ohne ABI-Grün kein Merge.

---

## 8. Merksatz

> **Alles, was nicht exakt ist, ist ein Bug.**


<<< END FILE: ./docs/TYPES_AND_ABI.md

>>> START FILE: ./docs/WATCHDOG_AND_FORENSICS.md
# CommanderLink – WATCHDOG & FORENSICS

## Ziel
Automatische Selbstheilung ohne Datenverlust.

---

## 1. Watchdog-Aufgabe

- Überwacht CL-Prozess
- Erkennt Deadlocks / Panics
- Restartet CL

---

## 2. Restart-Regeln

- Immer Fail-Open
- Keine Kernel-Abhängigkeit
- Kein System-Neustart

---

## 3. Forensik-Log

Bei jedem Restart:
- Zeitstempel
- Grund
- letzter Path-State
- letzte Constraint-Flags

---

## 4. Monitor-Integration

- Watchdog-Status sichtbar
- Letzte 5 Restart-Events
- Lesbare Zeitformate

---

## 5. Merksatz

> **Ein Neustart ist kein Fehler, sondern Wartung.**


<<< END FILE: ./docs/WATCHDOG_AND_FORENSICS.md

>>> START FILE: ./docs/WATCHDOG.md
# CommanderLink Watchdog (FINAL)
Datei: docs/WATCHDOG.md

## Zweck
Der Watchdog stellt sicher, dass CommanderLink sich selbst heilen kann:
- Bei Stall oder Panic wird CL neu gestartet.
- Das OS bleibt stabil (Fail-open).

## Prinzipien
- Fail-open für OS: cl0 ist non-persistent; routes sind /32; keine Default-Route Änderungen.
- Fail-closed für CL Data Plane: Bei Unsicherheit TX locked, OOB optional.
- Restart erfolgt über Supervisor (systemd/rc.d/SMF), nicht durch Systemreboot.

## Fortschritt vs. Liveness
Liveness bedeutet: Modul tickt.
Fortschritt bedeutet: System bewegt sich (commit_epoch/seq_cnt/peer seen).

## Restart-Log
Der Watchdog schreibt beim Restart einen Logeintrag in:
- /var/log/commanderlink/cl_watchdog.log

Format: eine Zeile pro Restart (maschinenlesbar)
- ts_ns=<uint64>
- reason=<wd_reason>
- module=<wd_module>
- last_progress_ns=<uint64>
- last_commit_epoch=<uint64>
- backend=<enum>
- profile=<enum>
- constraints=0x...
- mesh=<short>
- node=<short>
- restart_count=<u32>

Zeitumwandlung in lesbar erfolgt im Monitor (age/uptime).

## Monitor Pflichtanzeige
Dashboard:
- WATCHDOG: OK/WARN/STALL/PANIC (farbig, bold bei nicht OK)
- RESTARTS: total count
- LAST: age + reason/module

Forensics:
- zeigt die letzten 5 Restart-bezogenen Events

## Forensics Events (append-only)
- WD_RESTART_REQUEST
- WD_SELF_EXIT
- WD_HARD_KILL
- WD_RESTARTED


<<< END FILE: ./docs/WATCHDOG.md

>>> START FILE: ./docs/ZERO_LAWS_2.md
# CommanderLink – KANONISCHE GESETZE (aus diesem Gespräch)
## Stand: konsolidiert, ZERO-Abweichung, physics-first

---

## LAW_00_PHYSICS_FIRST

Physik ist die oberste Autorität.

Wenn elektrische, thermische, zeitliche oder speicherphysikalische Realität
einer Spezifikation, Konvention oder Implementationsannahme widerspricht,
gilt immer die Physik.

Spezifikationen sind Untergrenzen, niemals Designziele.

---

## LAW_01_WORST_CASE_BOUNDEDNESS

Jeder Pfad in CommanderLink muss worst-case-begrenzt sein.

Unbounded Loops, implizite Backoffs, adaptive Heuristiken ohne harte Grenzen
sind verboten.

Worst-Case-Stabilität hat Vorrang vor Durchschnittsperformance.

---

## LAW_02_SHM_IS_TRUTH

Shared Memory ist die einzige Wahrheit.

Alle Zustände existieren ausschließlich in SHM.
Logs, Events oder UI-Zustände haben keinen Wahrheitsanspruch.

---

## LAW_03_SHADOW_TO_ACTIVE_CORE_ONLY

Der Übergang von Shadow nach Active darf ausschließlich im CORE erfolgen.

Der Übergang ist atomar.
Kein anderes Modul darf Active schreiben oder Shadow „reparieren“.

---

## LAW_04_ROLE_PURITY

Rollen sind strikt getrennt:

- HAL misst und publiziert Shadow.
- CORE entscheidet und setzt Wahrheit.
- FLOW leitet ab und erzeugt Intent.
- LINK führt aus und entscheidet nicht.
- ORACLE liest und empfiehlt.
- MONITOR liest passiv.

Jede Rollenverletzung ist illegal.

---

## LAW_05_ZERO_TRANSFORMATION

Im Kern von CommanderLink sind Transformationen verboten.

Verboten sind:
- implizite Kopien
- semantische Rewrites
- implizite Format- oder Bedeutungsänderungen

Zulässig sind ausschließlich explizit vertraglich definierte Operationen
(CRC, FEC, Kompression), vollständig auditierbar und gate-gebunden.

---

## LAW_06_MINIMUM_IS_MAXIMUM

Der Mindestbetrieb von CommanderLink ist vollwertig.

„Degraded Mode“ existiert nicht.
Optimierungen sind Skalierungen, keine Rettungsmechanismen.

---

## LAW_07_MINIMUM_TRANSFER_MODE

Der Mindestübertragungsmodus von CommanderLink ist:

Ein CL-semantischer, credit- und pacing-gesteuerter Transport über UDP
ab Sekunde 0.

TCP ist kein Mindestmodus.
TCP ist ausschließlich ein Transport-Fallback, niemals Semantikträger.

CommanderLink ersetzt TCP ab dem ersten Paket.

---

## LAW_08_SENDER_WAITS

Der Sender wartet.

Senden ohne Credits, ohne Drain-Rate oder außerhalb von Pacing-Quanten
ist verboten.

Push-basierte Übertragung ist unzulässig.

---

## LAW_09_EXPLICIT_FLOW_CONTROL

Flow-Control ist explizit, sichtbar und deterministisch.

Credits, Inflight-Budgets, Burst-Caps und Rate-Ziele sind
tabellengetrieben und SHM-sichtbar.

Implizite Kernel- oder Protokollheuristiken sind unzulässig.

---

## LAW_10_AUTOMATION_WITHOUT_HEURISTICS

Automatik bedeutet deterministische Ableitung, nicht adaptive Heuristik.

Autopath, Autopacing, AutoMTU, AutoIntegrity und Autoscale
sind endliche Zustandsautomaten mit festen Tabellen und Hysterese.

LINK darf niemals autonom entscheiden.

---

## LAW_11_DEFAULT_DENY_TRUST

Join und Trust sind Default-Deny.

Ohne expliziten TRUSTED_ACTIVE-Zustand existieren:
- keine Overlay-Routen
- keine Grants
- keine Data-Plane

Fail-Open betrifft Betrieb, nicht Berechtigung.

---

## LAW_12_WATCHDOG_MANDATORY

Ein Watchdog ist verpflichtend.

Verletzungen von Invarianten, Hänger oder Vertragsbrüche
müssen deterministisch erkannt und behandelt werden.

---

## LAW_13_ABI_AND_LAYOUT_IMMUTABILITY

ABI- und SHM-Layouts sind deterministisch und unverhandelbar.

- Cacheline-Union-Prinzip
- feste Strides (256/512/1024/4096)
- kein `packed`
- explizites Padding
- Static Asserts überall

---

## LAW_14_ELASTIC_BULK_SHM

Bulk-SHM ist elastisch und jederzeit reclaimable.

- Core-SHM ist immer resident und minimal funktionsfähig.
- Bulk-SHM darf bis zum maximal verfügbaren RAM wachsen.
- Bulk-SHM darf jederzeit bis auf 0 verschwinden.

Bulk-Präsenz ist ausschließlich über `bulk_present` und `bulk_epoch`
definiert.

Bulk-Abwesenheit ist semantisch RECLAIMED, nicht „leer“.

---

## LAW_15_LIVE_REEVALUATION

CommanderLink skaliert permanent live.

Jeder Tick ist eine Neuberechnung der physikalisch zulässigen Realität.

Es existiert kein stabiler Betriebszustand,
nur ein aktuell erlaubter Zustand.

---

## LAW_16_AUDITABILITY_TO_LAST_BIT

Jedes Bit ist entweder:
- semantisch definiert
- explizit reserviert

Undefinierte Bytes sind verboten.

Der Monitor zeigt Wahrheit, nicht Interpretation.

---

## LAW_17_ZERO_DEVIATION

Abweichungen von diesen Gesetzen sind unzulässig.

Wenn Implementierung und Gesetz widersprechen,
ist die Implementierung falsch.

Diese Gesetze sind endlos gültig.


<<< END FILE: ./docs/ZERO_LAWS_2.md

>>> START FILE: ./docs/ZERO_LAWS.md
# CommanderLink – ZERO LAWS
## Endlos gültig · bitgenau · physics-first · ZERO-Abweichung

---

## ZERO_LAW_00_PHYSICS_ABSOLUTE

Physik ist die einzige Autorität.

Elektrische, thermische, zeitliche und speicherphysikalische Realität
haben immer Vorrang vor Spezifikationen, Konventionen,
Implementationen oder Meinungen.

---

## ZERO_LAW_01_ZERO_DEVIATION

Abweichungen sind unzulässig.

Es existiert kein Sonderfall, kein Debug-Modus,
keine Übergangsregel und kein späterer Fix.

Wenn Implementierung und Gesetz widersprechen,
ist die Implementierung falsch.

---

## ZERO_LAW_02_SHM_SINGLE_SOURCE_OF_TRUTH

Shared Memory ist die einzige Wahrheit.

Alle Zustände existieren ausschließlich in SHM.
Logs, Events, UI-Zustände oder Heuristiken haben keinen Wahrheitsanspruch.

---

## ZERO_LAW_03_SHADOW_TO_ACTIVE_CORE_ONLY

Der Übergang von Shadow nach Active darf ausschließlich im CORE erfolgen.

Der Übergang ist atomar.
Kein anderes Modul darf Active schreiben
oder Shadow interpretieren oder reparieren.

---

## ZERO_LAW_04_ROLE_PURITY

Rollen sind strikt getrennt und unverletzlich:

- HAL misst und publiziert Shadow.
- CORE entscheidet und setzt Wahrheit.
- FLOW leitet ab und erzeugt Intent.
- LINK führt aus und entscheidet nicht.
- ORACLE liest und empfiehlt.
- MONITOR liest passiv.

Rollenvermischung ist illegal.

---

## ZERO_LAW_05_ZERO_TRANSFORMATION

Im Kern von CommanderLink sind Transformationen verboten.

Verboten sind:
- implizite Kopien
- semantische Rewrites
- implizite Bedeutungsänderungen
- versteckte Normalisierungen

Zulässig sind ausschließlich explizit vertraglich definierte,
auditierbare Operationen unter Gate-Kontrolle.

---

## ZERO_LAW_06_MINIMUM_IS_MAXIMUM

Der Mindestbetrieb ist vollwertig.

Es existiert kein „Degraded Mode“.
Optimierungen sind Skalierungen,
keine funktionalen Rettungsmechanismen.

---

## ZERO_LAW_07_MINIMUM_TRANSFER_MODE

Der Mindestübertragungsmodus ist:

Ein CL-semantischer, credit- und pacing-gesteuerter Transport
über UDP ab Sekunde 0.

TCP ist kein Mindestmodus.
TCP ist ausschließlich Transport-Fallback.

CommanderLink ersetzt TCP ab dem ersten Paket.

---

## ZERO_LAW_08_SENDER_WAITS

Der Sender wartet.

Senden ohne Credits, ohne Drain-Rate
oder außerhalb deterministischen Pacings
ist verboten.

Push-basierte Übertragung ist unzulässig.

---

## ZERO_LAW_09_NO_IMPLICIT_HEURISTICS

Implizite Heuristiken sind verboten.

Alle Entscheidungen sind:
- tabellengetrieben
- zustandsbasiert
- worst-case-begrenzt
- SHM-sichtbar

---

## ZERO_LAW_10_WORST_CASE_BOUNDEDNESS

Jeder Pfad ist worst-case-begrenzt.

Unbounded Loops, implizite Backoffs,
opportunistische Entscheidungen
und adaptive Logik ohne harte Grenzen
sind verboten.

---

## ZERO_LAW_11_DEFAULT_DENY_TRUST

Join und Trust sind Default-Deny.

Ohne TRUSTED_ACTIVE existieren:
- keine Overlay-Routen
- keine Grants
- keine Data-Plane

Fail-Open betrifft Betrieb, nicht Berechtigung.

---

## ZERO_LAW_12_WATCHDOG_MANDATORY

Ein Watchdog ist verpflichtend.

Invariantverletzungen, Hänger
oder Vertragsbrüche müssen
deterministisch erkannt und behandelt werden.

---

## ZERO_LAW_13_ABI_AND_LAYOUT_IMMUTABLE

ABI- und SHM-Layouts sind unveränderlich.

- Cacheline-Union-Prinzip
- feste Strides
- kein `packed`
- explizites Padding
- statische Verifikation

---

## ZERO_LAW_14_ELASTIC_BULK_WITH_MINIMUM

Bulk-SHM ist elastisch und jederzeit reclaimable.

- Core-SHM ist immer resident und minimal funktionsfähig.
- Bulk-SHM darf bis zum maximal verfügbaren RAM wachsen.
- Bulk-SHM darf jederzeit bis auf 0 verschwinden.

Bulk-Abwesenheit ist semantisch RECLAIMED.

---

## ZERO_LAW_15_LIVE_REEVALUATION

CommanderLink skaliert permanent live.

Jeder Tick ist eine Neuberechnung
der physikalisch zulässigen Realität.

Es existiert kein stabiler Zustand,
nur ein aktuell erlaubter.

---

## ZERO_LAW_16_AUDITABILITY_TO_LAST_BIT

Jedes Bit ist entweder:
- semantisch definiert
- explizit reserviert

Undefinierte Bytes sind verboten.

Der Monitor zeigt Wahrheit, nicht Interpretation.

---

## ZERO_LAW_17_FINALITY

Diese Gesetze sind endlos gültig.

Sie stehen über Implementierungen,
Tools, Betriebssystemen und Meinungen.

CommanderLink ist ZERO oder nicht CommanderLink.


<<< END FILE: ./docs/ZERO_LAWS.md

>>> START FILE: ./include/cl_common/cl_align.h
#pragma once
/* ============================================================================
 * CommanderLink – Alignment/ABI Grundbausteine (Common) – FINAL
 * Datei: include/cl_common/cl_align.h
 * ============================================================================
 *
 * Zweck:
 *   Einheitliche OS-freie Makros für Alignment und Compile-Time-Gates.
 *
 * Maschinenregel:
 *   Alignment ist Geometrie (Cacheline/Page/Stride), kein Compiler-Zufall.
 * ============================================================================
 */

#include <stddef.h>
#include <stdint.h>

#if defined(__GNUC__) || defined(__clang__)
  #define CL_ALIGNAS(N) __attribute__((aligned(N)))
#else
  #define CL_ALIGNAS(N) _Alignas(N)
#endif

#define CL_STATIC_ASSERT(expr, msg) _Static_assert((expr), msg)


<<< END FILE: ./include/cl_common/cl_align.h

>>> START FILE: ./include/cl_common/cl_endian.h
#pragma once
/* ============================================================================
 * CommanderLink – Endianness Helpers (Common) – FINAL
 * Datei: include/cl_common/cl_endian.h
 * ============================================================================
 *
 * Maschinenregeln:
 *   - SHM ist Host-Order.
 *   - Wire/OOB ist explizit little-endian (_le) und wird an der Grenze konvertiert.
 * ============================================================================
 */

#include <stdint.h>

#if defined(__clang__) || defined(__GNUC__)
  #define CL_BSWAP16(x) __builtin_bswap16((uint16_t)(x))
  #define CL_BSWAP32(x) __builtin_bswap32((uint32_t)(x))
  #define CL_BSWAP64(x) __builtin_bswap64((uint64_t)(x))
#else
  static inline uint16_t CL_BSWAP16(uint16_t x) { return (uint16_t)((x<<8) | (x>>8)); }
  static inline uint32_t CL_BSWAP32(uint32_t x) {
      return ((x & 0x000000FFu) << 24) |
             ((x & 0x0000FF00u) <<  8) |
             ((x & 0x00FF0000u) >>  8) |
             ((x & 0xFF000000u) >> 24);
  }
  static inline uint64_t CL_BSWAP64(uint64_t x) {
      return ((x & 0x00000000000000FFull) << 56) |
             ((x & 0x000000000000FF00ull) << 40) |
             ((x & 0x0000000000FF0000ull) << 24) |
             ((x & 0x00000000FF000000ull) <<  8) |
             ((x & 0x000000FF00000000ull) >>  8) |
             ((x & 0x0000FF0000000000ull) >> 24) |
             ((x & 0x00FF000000000000ull) >> 40) |
             ((x & 0xFF00000000000000ull) >> 56);
  }
#endif

#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
  #define CL_HOST_IS_LE 1
#else
  #define CL_HOST_IS_LE 0
#endif

static inline uint16_t cl_host_to_le16(uint16_t v) { return CL_HOST_IS_LE ? v : CL_BSWAP16(v); }
static inline uint32_t cl_host_to_le32(uint32_t v) { return CL_HOST_IS_LE ? v : CL_BSWAP32(v); }
static inline uint64_t cl_host_to_le64(uint64_t v) { return CL_HOST_IS_LE ? v : CL_BSWAP64(v); }

static inline uint16_t cl_le16_to_host(uint16_t v) { return CL_HOST_IS_LE ? v : CL_BSWAP16(v); }
static inline uint32_t cl_le32_to_host(uint32_t v) { return CL_HOST_IS_LE ? v : CL_BSWAP32(v); }
static inline uint64_t cl_le64_to_host(uint64_t v) { return CL_HOST_IS_LE ? v : CL_BSWAP64(v); }


<<< END FILE: ./include/cl_common/cl_endian.h

>>> START FILE: ./include/cl_manifest/cl_enums.h
#pragma once
/* ============================================================================
 * CommanderLink – Enums/Flags (Manifest) – FINAL, EINZIGE WAHRHEIT
 * Datei: include/cl_manifest/cl_enums.h
 * ============================================================================
 *
 * Maschinenregel:
 *   - Alle Zustände/Flags/Reason Codes hier, keine Doppeldefinitionen.
 *   - „Maximalmodell“: UNSUPPORTED/DISABLED/IDLE/ACTIVE/UNKNOWN/FAULT sind Pflicht.
 * ============================================================================
 */

#include <stdint.h>

/* ---------------- Globale Health Bits ---------------- */
#define CL_HEALTH_OK               (1u << 0)
#define CL_HEALTH_DEGRADED         (1u << 1)
#define CL_HEALTH_FAULT            (1u << 2)

#define CL_HEALTH_OOB_OK           (1u << 8)
#define CL_HEALTH_OVERLAY_OK       (1u << 9)
#define CL_HEALTH_SECURITY_OK      (1u << 10)
#define CL_HEALTH_THERMAL_CAP      (1u << 11)
#define CL_HEALTH_VRM_CAP          (1u << 12)
#define CL_HEALTH_POWER_CAP        (1u << 13)
#define CL_HEALTH_STORAGE_CAP      (1u << 14)

/* ---------------- Feature State (Maximalmodell) ---------------- */
typedef enum {
    CL_FEAT_UNSUPPORTED = 0, /* Hardware/OS kann es nicht */
    CL_FEAT_UNKNOWN     = 1, /* könnte, aber nicht messbar / nicht bestätigt */
    CL_FEAT_DISABLED    = 2, /* möglich, aber Policy/Gate verbietet */
    CL_FEAT_IDLE        = 3, /* möglich & erlaubt, aber aktuell nicht aktiv */
    CL_FEAT_ACTIVE      = 4, /* aktiv genutzt */
    CL_FEAT_FAULT       = 5  /* defekt / Grenzwert überschritten */
} cl_feature_state_t;

/* ---------------- Budget State ---------------- */
typedef enum {
    CL_BUDGET_BOOST   = 0,
    CL_BUDGET_NORMAL  = 1,
    CL_BUDGET_SHADOW  = 2,
    CL_BUDGET_RECLAIM = 3,
    CL_BUDGET_RECOVER = 4
} cl_budget_state_t;

/* ---------------- Path State ---------------- */
typedef enum {
    CL_PATH_BOOT = 0,
    CL_PATH_PASSIVE_MONITORING,
    CL_PATH_OOB_DISCOVERY,
    CL_PATH_NEGOTIATING,
    CL_PATH_ACTIVE_BYPASS,
    CL_PATH_ACTIVE_UDP,
    CL_PATH_DEGRADED,
    CL_PATH_TCP_FALLBACK
} cl_path_state_t;

/* RX/TX Gates */
typedef enum { CL_RX_NONE=0, CL_RX_OOB_ONLY=1, CL_RX_FULL=2 } cl_rx_gate_t;
typedef enum { CL_TX_LOCKED=0, CL_TX_OOB_ONLY=1, CL_TX_ALLOWED=2 } cl_tx_gate_t;

/* ---------------- Backend Active ---------------- */
typedef enum { CL_BACKEND_NONE=0, CL_BACKEND_BYPASS, CL_BACKEND_UDP, CL_BACKEND_TCP } cl_backend_active_t;

/* Backend detail */
typedef enum {
    CL_BACKEND_DETAIL_NONE = 0,
    CL_BACKEND_DETAIL_NETMAP,
    CL_BACKEND_DETAIL_AF_XDP,
    CL_BACKEND_DETAIL_UDP_SOCKET,
    CL_BACKEND_DETAIL_TCP_SOCKET
} cl_backend_detail_t;

typedef enum { CL_BSTATE_UDP_BASE=0, CL_BSTATE_BYPASS_ACTIVE, CL_BSTATE_DEGRADED, CL_BSTATE_TCP_FALLBACK } cl_backend_state_t;

/* ---------------- Link Modes ---------------- */
typedef enum {
    CL_LINK_RAW          = 0x0001,
    CL_LINK_FLOW         = 0x0002,
    CL_LINK_FLOW_LZ4     = 0x0003,
    CL_LINK_FLOW_FEC     = 0x0004,
    CL_LINK_FLOW_LZ4_FEC = 0x0005,
    CL_LINK_OOB          = 0x00F0,
    CL_LINK_SYNC         = 0x00F1
} cl_link_mode_t;

/* ---------------- Profiles ---------------- */
typedef enum { CL_PROFILE_BASIC=0, CL_PROFILE_BALANCED=1, CL_PROFILE_HPP_PLUS=2 } cl_transfer_profile_t;

/* Thermal */
typedef enum { CL_THERM_OPTIMAL=0, CL_THERM_WARM=1, CL_THERM_HOT=2, CL_THERM_CRITICAL=3 } cl_thermal_state_t;

/* Peer online */
typedef enum { CL_PEER_UNKNOWN=0, CL_PEER_ONLINE=1, CL_PEER_OFFLINE=2 } cl_peer_state_t;

/* Trust */
typedef enum {
    CL_TRUST_UNKNOWN=0,
    CL_TRUST_SEEN_UNTRUSTED=1,
    CL_TRUST_NEGOTIATING_AUTH=2,
    CL_TRUST_TRUSTED_ACTIVE=3,
    CL_TRUST_DENIED=4
} cl_peer_trust_state_t;

/* Accept mode (Transfer semantics) */
typedef enum { CL_ACCEPT_BUFFERED=0, CL_ACCEPT_DURABLE=1 } cl_accept_mode_t;

/* CRC modes (Maximalmodell) */
typedef enum {
    CL_CRC_NONE   = 0,
    CL_CRC_CRC32C = 1,
    CL_CRC_CRC64  = 2,
    CL_CRC_CRC128 = 3
} cl_crc_mode_t;

/* FEC modes (Maximalmodell) */
typedef enum {
    CL_FEC_OFF   = 0,
    CL_FEC_XOR   = 1, /* 1-parity erasure */
    CL_FEC_RS    = 2, /* Reed-Solomon erasure (future/enterprise) */
    CL_FEC_OTHER = 3
} cl_fec_mode_t;

/* Compression ladder */
typedef enum { CL_COMP_OFF=0, CL_COMP_LZ4_FAST=1, CL_COMP_LZ4_HC_LOW=2, CL_COMP_LZ4_HC_MAX=3 } cl_comp_mode_t;
typedef enum { CL_COMP_CAP_OK=0, CL_COMP_CAP_THERMAL, CL_COMP_CAP_BUDGET, CL_COMP_CAP_BAD_RATIO, CL_COMP_CAP_SINK_LIMIT, CL_COMP_CAP_INTEGRITY, CL_COMP_CAP_PEER_LIMIT } cl_comp_cap_reason_t;

/* Constraint flags */
typedef uint32_t cl_constraint_flags_t;

#define CL_CF_NONE               0u
#define CL_CF_BUDGET_SHADOW      (1u << 0)
#define CL_CF_BUDGET_RECLAIM     (1u << 1)
#define CL_CF_THERMAL_CAP        (1u << 2)
#define CL_CF_BOARD_VRM_CAP      (1u << 3)
#define CL_CF_POWER_UNSTABLE     (1u << 4)
#define CL_CF_STORAGE_SINK_CAP   (1u << 5)

#define CL_CF_FIREWALL_BLOCK     (1u << 8)
#define CL_CF_BACKEND_FAIL       (1u << 9)
#define CL_CF_PEER_CAPS          (1u << 10)
#define CL_CF_NET_HEALTH         (1u << 11)
#define CL_CF_LINK_DEGRADED      (1u << 12)
#define CL_CF_OVERLAY_DOWN       (1u << 13)
#define CL_CF_ROUTE_ORPHAN       (1u << 14)
#define CL_CF_CREDIT_STALE       (1u << 15)
#define CL_CF_SECURITY_REQUIRED  (1u << 16)
#define CL_CF_SECURITY_DEGRADED  (1u << 17)
#define CL_CF_PEER_UNTRUSTED     (1u << 18)

/* Reason codes */
typedef enum {
    CL_RC_OK=0,
    CL_RC_ADMIN_POLICY,

    CL_RC_PEER_TIMEOUT,
    CL_RC_PEER_NO_CAPS,
    CL_RC_NO_OOB_ACK,

    CL_RC_NO_UDP_ACK,
    CL_RC_BACKEND_ERROR,
    CL_RC_CREDIT_EXPIRED,

    CL_RC_LOSS_SPIKE,
    CL_RC_JITTER_SPIKE,
    CL_RC_THERMAL_EVENT,
    CL_RC_BUDGET_EVENT,
    CL_RC_BOARD_VRM_EVENT,
    CL_RC_POWER_UNSTABLE_EVENT,
    CL_RC_STORAGE_SINK_EVENT,

    CL_RC_MTU_MISMATCH,
    CL_RC_VERSION_MISMATCH,

    CL_RC_IP_COLLISION,
    CL_RC_IP_COLLISION_STORM,
    CL_RC_OVERLAY_SETUP_FAIL,

    CL_RC_SECURITY_PREREQ_MISSING,
    CL_RC_SECURITY_VERSION_TOO_OLD,
    CL_RC_AUTH_FAILED,
    CL_RC_REPLAY_DETECTED,
    CL_RC_UNTRUSTED_PEER
} cl_reason_code_t;

/* Drop reason (hot path) */
typedef enum {
    CL_DROP_NONE=0, CL_DROP_HDR_CRC, CL_DROP_AUTH, CL_DROP_NO_SESSION, CL_DROP_DUPLICATE,
    CL_DROP_OUT_OF_WINDOW, CL_DROP_RESOURCE, CL_DROP_BACKEND_FAIL, CL_DROP_MTU_MISMATCH, CL_DROP_THERMAL
} cl_drop_reason_t;


<<< END FILE: ./include/cl_manifest/cl_enums.h

>>> START FILE: ./include/cl_manifest/cl_features.h
#pragma once
/* ============================================================================
 * CommanderLink – Features/Caps (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_features.h
 * ============================================================================
 */

#include <stdint.h>
#include "cl_enums.h"

typedef uint32_t cl_cpu_isa_mask_t;
#define CL_ISA_SSE42   (1u << 0)
#define CL_ISA_AVX2    (1u << 1)
#define CL_ISA_AVX512  (1u << 2)
#define CL_ISA_AMX     (1u << 3)
#define CL_ISA_AESNI   (1u << 4)
#define CL_ISA_PCLMUL  (1u << 5)

typedef enum { CL_ISA_EFF_SSE42=0, CL_ISA_EFF_AVX2=1, CL_ISA_EFF_AVX512=2, CL_ISA_EFF_AMX=3 } cl_cpu_isa_effective_t;

typedef uint32_t cl_backend_mask_t;
#define CL_BE_M_BYPASS (1u << 0)
#define CL_BE_M_UDP    (1u << 1)
#define CL_BE_M_TCP    (1u << 2)

/* Security caps */
typedef struct {
    uint8_t openssl_present;
    uint8_t openssl_version_ok;
    uint8_t auth_required;
    uint8_t reserved0;
} cl_security_caps_t;

/* Memory caps */
typedef struct {
    uint64_t total_ram_bytes;
    uint64_t staging_cap_max_bytes;
    uint64_t staging_cap_current_bytes;
    uint64_t rx_window_current_bytes;
    uint8_t hugepages_supported;
    uint8_t hugepages_active;
    uint16_t reserved0;
} cl_mem_caps_t;

/* NIC caps */
typedef struct {
    uint16_t ports_count;
    uint16_t queues_count;
    uint32_t link_speed_mbps;
    uint16_t mtu_min;
    uint16_t mtu_max;
    cl_backend_mask_t backend_possible_mask;
} cl_nic_caps_t;

/* Board caps */
typedef struct {
    uint8_t vrm_supported;
    uint8_t ripple_supported;
    uint8_t pwr_limits_supported;
    uint8_t reserved0;
    cl_thermal_state_t board_therm_state;
    uint8_t power_unstable;
    uint16_t reserved1;
} cl_board_caps_t;

/* Host snapshot (possible/effective + reasons) */
typedef struct {
    cl_cpu_isa_mask_t cpu_isa_possible;
    cl_backend_mask_t backend_possible;
    uint32_t profile_possible_mask;

    cl_cpu_isa_effective_t cpu_isa_effective;
    cl_backend_active_t backend_effective;
    cl_transfer_profile_t profile_effective;

    cl_constraint_flags_t constraint_flags;
    cl_reason_code_t reason_code;

    cl_security_caps_t security;
    cl_mem_caps_t mem;
    cl_nic_caps_t nic;
    cl_board_caps_t board;

    uint32_t reserved2;
} cl_host_caps_t;


<<< END FILE: ./include/cl_manifest/cl_features.h

>>> START FILE: ./include/cl_manifest/cl_ids.h
#pragma once
/* ============================================================================
 * CommanderLink – Identity Contract (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_ids.h
 * ============================================================================
 */

#include <stdint.h>

typedef uint64_t cl_mesh_tag64_t;
typedef uint64_t cl_node_tag64_t;
typedef uint64_t cl_session_id64_t;

typedef struct { uint8_t b[16]; } cl_uuid16_t;

/* Darstellung (Monitor/Forensik), deterministisch */
static inline uint32_t cl_id_short8_u32(uint64_t tag64) {
    uint64_t x = tag64 ^ (tag64 >> 32);
    return (uint32_t)x;
}


<<< END FILE: ./include/cl_manifest/cl_ids.h

>>> START FILE: ./include/cl_manifest/cl_join_policy.h
#pragma once
/* ============================================================================
 * CommanderLink – Join/Trust Policy (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_join_policy.h
 * ============================================================================
 */

#include <stdint.h>
#include "cl_enums.h"
#include "cl_trust.h"

typedef enum { CL_JOIN_LAB_PERMISSIVE=0, CL_JOIN_PARANOID_STRICT=1 } cl_join_mode_t;

#define CL_JOIN_MODE_DEFAULT CL_JOIN_PARANOID_STRICT
#define CL_JOIN_REQUIRE_AUTH 1

#define CL_JOIN_HELLO_TIMEOUT_MS  500u
#define CL_JOIN_RETRY_MAX         3u
#define CL_JOIN_REPLAY_WINDOW_DEFAULT 64u


<<< END FILE: ./include/cl_manifest/cl_join_policy.h

>>> START FILE: ./include/cl_manifest/cl_limits.h
#pragma once
/* ============================================================================
 * CommanderLink – Limits (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_limits.h
 * ============================================================================
 */

#include <stdint.h>

#define CL_MAX_CORES                 512u
#define CL_MAX_NET_IFACES            16u
#define CL_MAX_GPUS                  8u
#define CL_MAX_MEM_CHANNELS          32u
#define CL_MAX_PCIE_LANES            256u

#define CL_MESH_HOT_NEIGHBORS        32u
#define CL_SWARM_MAX_TRACKED_PEERS   16384u
#define CL_ZFS_MAX_DATASETS          4096u

#define CL_DMA_SLOT_BYTES            4096u

#define CL_OOB_GRANT_TTL_MS_DEFAULT        200u
#define CL_INJECT_PREPARE_TTL_MS_DEFAULT   50u

#define CL_OVERLAY_PREFIXLEN_DEFAULT       10u

#define CL_ATOM_BYTES_DEFAULT              64u
#define CL_HEADROOM_DEFAULT_BYTES          64u


<<< END FILE: ./include/cl_manifest/cl_limits.h

>>> START FILE: ./include/cl_manifest/cl_link_modes.h
#pragma once
/* ============================================================================
 * CommanderLink – Link Modes (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_link_modes.h
 * ============================================================================
 *
 * Zweck:
 *   Stabiler Include-Punkt für Link-Modi. Die Wahrheit liegt in cl_enums.h.
 * ============================================================================
 */

#include "cl_enums.h"

#define CL_LINK_MODE_RAW          CL_LINK_RAW
#define CL_LINK_MODE_FLOW         CL_LINK_FLOW
#define CL_LINK_MODE_FLOW_LZ4     CL_LINK_FLOW_LZ4
#define CL_LINK_MODE_FLOW_FEC     CL_LINK_FLOW_FEC
#define CL_LINK_MODE_FLOW_LZ4_FEC CL_LINK_FLOW_LZ4_FEC
#define CL_LINK_MODE_OOB          CL_LINK_OOB
#define CL_LINK_MODE_SYNC         CL_LINK_SYNC


<<< END FILE: ./include/cl_manifest/cl_link_modes.h

>>> START FILE: ./include/cl_manifest/cl_manifest.h
#pragma once
/* ============================================================================
 * CommanderLink – Manifest Frontdoor (FINAL, Paket 2/6)
 * Datei: include/cl_manifest/cl_manifest.h
 * ============================================================================
 */

#include "cl_modeling_rule.h"

#include "cl_enums.h"
#include "cl_limits.h"
#include "cl_ids.h"
#include "cl_features.h"

#include "cl_simd_policy.h"
#include "cl_zero_transform.h"

#include "cl_trust.h"
#include "cl_join_policy.h"

#include "cl_link_modes.h"
#include "cl_overlay.h"
#include "cl_wire.h"
#include "cl_oob.h"
#include "cl_wire_crc.h"

<<< END FILE: ./include/cl_manifest/cl_manifest.h

>>> START FILE: ./include/cl_manifest/cl_modeling_rule.h
#pragma once
/* ============================================================================
 * CommanderLink – Modeling Rule / Verfassung (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_modeling_rule.h
 * ============================================================================
 *
 * Globale Projektregel (bindend):
 *   - „Das Maximum ist das Minimum.“
 *   - Abwesenheit ist ein Zustand, keine Lücke.
 *   - Alles, was lieferbar ist, wird erfasst; alles andere wird als Zustand
 *     UNSUPPORTED/UNKNOWN/DISABLED modelliert – inklusive Source/Quality/Reason.
 *
 * Konsequenzen:
 *   - SHM modelliert das Maximum (possible/effective/state/source/quality).
 *   - Policies/Gates werten alle verfügbaren Daten aus.
 *   - Monitor zeigt das Maximalmodell lückenlos, markiert Einschränkungen explizit.
 *
 * Sicherheitsregel:
 *   - Join/Trust paranoid (Default-deny). Ohne Trust: keine Routes/Grants/Data Plane.
 *
 * Performance-Regel:
 *   - Standard ist maximale Performance unter offenen Gates (Budget/Thermal/VRM/Security).
 *   - Reduktion ist sofort und lokal, nie global vorsorglich.
 * ============================================================================
 */

#include <stdint.h>

#define CL_MODEL_MAX_IS_MIN 1
#define CL_MODEL_STATE_EXPLICIT 1
#define CL_MODEL_APPEND_ONLY 1
#define CL_MODEL_SHM_HOST_ORDER 1
#define CL_MODEL_SHM_NO_PACKED 1

#define CL_MODEL_ZERO_TRANSFORM_STANDARD 1
#define CL_MODEL_ATOM_BYTES 64u


<<< END FILE: ./include/cl_manifest/cl_modeling_rule.h

>>> START FILE: ./include/cl_manifest/cl_oob_wire.h
#pragma once
/* ============================================================================
 * CommanderLink – OOB Wire (UDP/4343) – FINAL
 * Datei: include/cl_manifest/cl_oob_wire.h
 * ============================================================================
 *
 * Regeln:
 *   - Wire ist packed
 *   - Zahlenfelder sind *_le (explizit little-endian)
 *   - Beacon64 ist untrusted (kein auth)
 *   - Hello128 und Grant128 sind paranoid-auth (auth_tag16 Pflicht)
 * ============================================================================
 */

#include <stdint.h>

#include "../cl_common/cl_endian.h"
#include "cl_enums.h"

#define CL_OOB_PORT   4343u
#define CL_OOB_VER_1  1u
#define CL_OOB_MAGIC  0xC10Bu

typedef enum {
    CL_OOB_BEACON    = 1,
    CL_OOB_HELLO     = 2,
    CL_OOB_HELLO_ACK = 3,
    CL_OOB_GRANT     = 4,
    CL_OOB_BYE       = 5
} cl_oob_type_t;

#define CL_OOB_F_ACK_REQ      (1u << 0)
#define CL_OOB_F_AUTH_PRESENT (1u << 1)

/* Header 32B (universal) – FINAL, size-locked */
typedef struct __attribute__((packed)) {
    uint16_t magic_le;        /* CL_OOB_MAGIC */
    uint8_t  ver;             /* CL_OOB_VER_1 */
    uint8_t  type;            /* cl_oob_type_t */
    uint32_t msg_len_le;      /* sizeof(message) */

    uint16_t flags_le;        /* CL_OOB_F_* */
    uint8_t  hdr_crc8;        /* optional: 0 if unused */
    uint8_t  reserved0;       /* must be 0 */

    uint32_t epoch_le;        /* monotonic per sender (replay gate), u32 */

    uint64_t mesh_tag64_le;   /* domain */
    uint64_t node_tag64_le;   /* identity */
} cl_oob_hdr32_t;

_Static_assert(sizeof(cl_oob_hdr32_t) == 32, "oob hdr must be 32B");

typedef struct __attribute__((packed)) {
    cl_oob_hdr32_t h;              /* 32 */

    uint32_t caps_summary32_le;    /* 4 */
    uint16_t mtu_max_le;           /* 2 */
    uint8_t  profile_allowed_mask; /* 1 */
    uint8_t  backend_allowed_mask; /* 1 */

    uint32_t health_bits_le;       /* 4 */
    uint32_t build_id_le;          /* 4 */

    uint64_t mono_ts_ns_le;        /* 8 */

    uint64_t reserved0_le;         /* 8 -> padding to 64 */
} cl_oob_beacon64_t;

_Static_assert(sizeof(cl_oob_beacon64_t) == 64, "beacon 64");


/* ---------------- HELLO128 / HELLOACK128 (auth required) ---------------- */
typedef struct __attribute__((packed)) {
    cl_oob_hdr32_t h;              /* 32 */

    uint32_t caps_full32_le;       /* detailed caps summary */
    uint32_t proto_compat_le;      /* compat flags / schema family */

    uint32_t overlay_ip_le;        /* host order encoded as LE u32 */
    uint8_t  overlay_prefixlen;    /* usually 10 */
    uint8_t  rx_gate;              /* cl_rx_gate_t */
    uint8_t  tx_gate;              /* cl_tx_gate_t */
    uint8_t  trust_policy;         /* cl_join_mode_t / policy selector */

    uint16_t payload_quantum_le;   /* 64 (ZT atom) */
    uint16_t payload_headroom_le;  /* 64 default */
    uint16_t mtu_min_le;           /* path MTU min */
    uint16_t mtu_max_le;           /* path MTU max */

    uint32_t link_speed_mbps_le;   /* best-effort; 0=unknown; u32 reicht bis ~4 Tbps */
    uint16_t ports_count_le;       /* Anzahl physischer Ports (1..N) */
    uint16_t reserved_ports0;      /* muss 0 sein (Reserve/Alignment-Konstanz) */

    uint64_t rx_window_bytes_le;   /* receiver window */
    uint64_t drain_bps_le;         /* receiver drain rate */

    uint32_t grant_ttl_ms_le;      /* default 200ms */
    uint32_t prepare_ttl_ms_le;    /* default 50ms */

    uint32_t reason_code_le;       /* cl_reason_code_t */
    uint32_t constraint_flags_le;  /* cl_constraint_flags_t */

    uint32_t crc_mode_possible_le; /* bitmask over cl_crc_mode_t */
    uint32_t fec_mode_possible_le; /* bitmask over cl_fec_mode_t */

    uint32_t crc_mode_effective_le;/* chosen (optional hint) */
    uint32_t fec_nk_le;            /* high16=N low16=K */

    uint8_t  auth_tag16[16];       /* REQUIRED: HMAC/tag truncated */
} cl_oob_hello128_t;

_Static_assert(sizeof(cl_oob_hello128_t) == 128, "hello 128");
typedef cl_oob_hello128_t cl_oob_hello_ack128_t;

/* ---------------- GRANT128 (auth required) ---------------- */
typedef struct __attribute__((packed)) {
    cl_oob_hdr32_t h;              /* 32 */

    uint64_t grant_id_le;          /* 8 */
    uint64_t refill_epoch_le;      /* 8 */

    uint32_t grant_ttl_ms_le;      /* 4 */
    uint32_t session_id32_le;      /* 4 */

    uint32_t credits_pkts_le;      /* 4 */
    uint32_t credits_bytes_le;     /* 4 */

    uint32_t reason_code_le;       /* 4 */
    uint32_t constraint_flags_le;  /* 4 */

    uint16_t payload_quantum_le;   /* 2 */
    uint16_t payload_headroom_le;  /* 2 */
    uint16_t mtu_effective_le;     /* 2 */
    uint16_t reserved0;            /* 2 */

    uint16_t fec_n_le;             /* 2 */
    uint16_t fec_k_le;             /* 2 */
    uint16_t crc_mode_le;          /* 2 */
    uint16_t fec_mode_le;          /* 2 */

    uint32_t accept_mode_le;       /* 4 */
    uint32_t durable_granularity_le; /* 4 */

    uint8_t  auth_tag16[16];       /* 16 */

    uint8_t  pad[16];              /* 24 -> total 128 */
} cl_oob_grant128_t;

_Static_assert(sizeof(cl_oob_grant128_t) == 128, "grant 128");


<<< END FILE: ./include/cl_manifest/cl_oob_wire.h

>>> START FILE: ./include/cl_manifest/cl_oob.h
#pragma once
#ifdef __cplusplus
extern "C" {
#endif

#include "cl_oob_wire.h"

#ifdef __cplusplus
}
#endif


<<< END FILE: ./include/cl_manifest/cl_oob.h

>>> START FILE: ./include/cl_manifest/cl_overlay.h
#pragma once
/* ============================================================================
 * CommanderLink – Overlay Manifest (v0.1) – FINAL
 * Datei: include/cl_manifest/cl_overlay.h
 * ============================================================================
 *
 * Ziel:
 *   Overlaynetz 100.64.0.0/10, deterministisch, Zero-ARP (Host-Routen /32).
 *
 * Maschinenregeln:
 *   - Host-Order im SHM.
 *   - Fail-Open: Interface nicht persistent, stirbt mit Daemon.
 * ============================================================================
 */

#include <stdint.h>

#include "../cl_common/cl_align.h"
#include "cl_enums.h"

#define CL_OVERLAY_PREFIXLEN            10u
#define CL_OVERLAY_NET_BASE_U32         0x64400000u
#define CL_OVERLAY_NET_MASK_U32         0xFFC00000u
#define CL_OVERLAY_HOST_MASK_U32        0x003FFFFFu

#define CL_OVERLAY_MAX_COLLISION_RETRIES 16u

#if defined(__linux__)
  #define CL_OVERLAY_IF_NAME_DEFAULT "cl0"
#elif defined(__sun__)
  #define CL_OVERLAY_IF_NAME_DEFAULT "cltun0"
#else
  #define CL_OVERLAY_IF_NAME_DEFAULT "tun0"
#endif

typedef enum {
    CL_ROUTE_SYNCED    = 0,
    CL_ROUTE_ORPHAN    = 1,
    CL_ROUTE_PENDING   = 2,
    CL_ROUTE_NONE      = 3,
    CL_ROUTE_COLLISION = 4
} cl_overlay_route_state_t;

static inline uint32_t cl_overlay_calc_ip_host_u32(uint64_t node_tag64,
                                                   uint64_t mesh_tag64,
                                                   uint8_t collision_offset)
{
    uint64_t mixed = node_tag64 ^ mesh_tag64 ^ (node_tag64 >> 22) ^ (mesh_tag64 << 5);
    uint32_t h22 = (uint32_t)((mixed ^ (mixed >> 22) ^ (mixed >> 44)) & CL_OVERLAY_HOST_MASK_U32);
    h22 = (h22 + (uint32_t)collision_offset) & CL_OVERLAY_HOST_MASK_U32;
    if (h22 == 0u) h22 = 1u;
    return (CL_OVERLAY_NET_BASE_U32 | h22);
}


<<< END FILE: ./include/cl_manifest/cl_overlay.h

>>> START FILE: ./include/cl_manifest/cl_simd_policy.h
#pragma once
/* ============================================================================
 * CommanderLink – SIMD/ISA Policy (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_simd_policy.h
 * ============================================================================
 */

#include <stdint.h>
#include "cl_enums.h"
#include "cl_features.h"

typedef enum {
    CL_SIMD_EFF_SCALAR = 0,
    CL_SIMD_EFF_SSE42  = 1,
    CL_SIMD_EFF_AVX2   = 2,
    CL_SIMD_EFF_AVX512 = 3,
    CL_SIMD_EFF_AMX    = 4
} cl_simd_effective_t;

typedef enum {
    CL_AVX512_RISK_UNKNOWN = 0,
    CL_AVX512_RISK_SAFE    = 1,
    CL_AVX512_RISK_OFFSET  = 2
} cl_avx512_risk_t;

typedef uint32_t cl_simd_policy_flags_t;

#define CL_SIMD_PF_NONE                   0u
#define CL_SIMD_PF_ALLOW_AVX2             (1u << 0)
#define CL_SIMD_PF_ALLOW_AVX512           (1u << 1)
#define CL_SIMD_PF_ALLOW_AMX              (1u << 2)
#define CL_SIMD_PF_AVX512_REQUIRE_GENESIS (1u << 8)

static inline cl_simd_effective_t cl_simd_choose_effective(uint32_t cpu_isa_possible_mask,
                                                           cl_avx512_risk_t avx512_risk,
                                                           cl_budget_state_t budget_state,
                                                           uint32_t constraint_flags,
                                                           cl_simd_policy_flags_t policy_flags)
{
    if ((cpu_isa_possible_mask & CL_ISA_SSE42) == 0u) return CL_SIMD_EFF_SCALAR;

    if (budget_state == CL_BUDGET_SHADOW || budget_state == CL_BUDGET_RECLAIM) return CL_SIMD_EFF_SSE42;

    if (constraint_flags & (CL_CF_THERMAL_CAP | CL_CF_BOARD_VRM_CAP | CL_CF_POWER_UNSTABLE)) return CL_SIMD_EFF_SSE42;

    if ((policy_flags & CL_SIMD_PF_ALLOW_AVX2) && (cpu_isa_possible_mask & CL_ISA_AVX2)) {
        if ((policy_flags & CL_SIMD_PF_ALLOW_AVX512) &&
            (cpu_isa_possible_mask & CL_ISA_AVX512) &&
            (avx512_risk == CL_AVX512_RISK_SAFE))
        {
            return CL_SIMD_EFF_AVX512;
        }
        return CL_SIMD_EFF_AVX2;
    }

    return CL_SIMD_EFF_SSE42;
}


<<< END FILE: ./include/cl_manifest/cl_simd_policy.h

>>> START FILE: ./include/cl_manifest/cl_trust.h
#pragma once
/* ============================================================================
 * CommanderLink – Trust / Join State Machine (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_trust.h
 * ============================================================================
 */

#include <stdint.h>
#include "cl_enums.h"

static inline int cl_trust_allows_routes(cl_peer_trust_state_t st) { return st == CL_TRUST_TRUSTED_ACTIVE; }
static inline int cl_trust_allows_grants(cl_peer_trust_state_t st) { return st == CL_TRUST_TRUSTED_ACTIVE; }
static inline int cl_trust_allows_dataplane(cl_peer_trust_state_t st) { return st == CL_TRUST_TRUSTED_ACTIVE; }

typedef enum {
    CL_TR_EVT_NONE = 0,
    CL_TR_EVT_SEEN_BEACON = 1,
    CL_TR_EVT_SEEN_HELLO  = 2,
    CL_TR_EVT_AUTH_OK     = 10,
    CL_TR_EVT_AUTH_FAIL   = 11,
    CL_TR_EVT_REPLAY      = 20,
    CL_TR_EVT_TTL_EXPIRED = 21,
    CL_TR_EVT_TRUSTED     = 30,
    CL_TR_EVT_DENIED      = 31,
    CL_TR_EVT_ROUTE_BLOCKED = 40,
    CL_TR_EVT_GRANT_BLOCKED = 41
} cl_trust_event_id_t;

typedef struct {
    uint64_t last_epoch;
    uint64_t window_mask;
    uint64_t window_base;
} cl_replay_window_t;

static inline void cl_replay_reset(cl_replay_window_t *w) {
    w->last_epoch = 0;
    w->window_mask = 0;
    w->window_base = 0;
}


<<< END FILE: ./include/cl_manifest/cl_trust.h

>>> START FILE: ./include/cl_manifest/cl_wire_crc.h
#pragma once
/* ============================================================================
 * CommanderLink – Wire Integrity (CRC8 Header + CRC32C Trailer) – FINAL
 * Datei: include/cl_manifest/cl_wire_crc.h
 * ============================================================================
 *
 * Ziel:
 *   - CPU soll rechnen, nicht verwalten.
 *   - Starke Integrität nutzt hardware-nahe Primitive, wenn verfügbar.
 *
 * Vertrag:
 *   1) Header Early-Reject:
 *      - CRC8 über CLWP Header (16B), hdr_crc8 Feld vorher 0.
 *
 *   2) Payload Strong Integrity:
 *      - CRC32C (Castagnoli) als Trailer (4B, little-endian)
 *      - Trailer ist nur vorhanden, wenn CL_WF_PAYLOAD_CRC32C gesetzt ist.
 *      - payload_len im Header zählt NUR den Payload (ohne Trailer).
 *      - Auf dem Draht folgt nach payload_len Bytes ggf. crc32c_le (4B).
 *
 *   3) Optional: Batch-CRC32C (High-throughput)
 *      - Wenn CL_WF_BATCH_CRC32C gesetzt ist, trägt der Frame eine Batch-CRC32C
 *        als Trailer (siehe cl_wire_batch_crc_tail16_t).
 *      - Nutzung: große Transfers, amortisierte Integrität.
 *
 * SIMD/HW:
 *   - Auf x86_64 kann CRC32C per SSE4.2 Instruktion gerechnet werden.
 *   - Die Nutzung ist capability-/gate-gebunden (possible/effective).
 * ============================================================================
 */

#include <stdint.h>
#include <stddef.h>
#include <string.h>

#include "cl_wire.h"

/* ----------------------------- CRC8 Vertrag --------------------------------
 *
 * CRC8 ist ausschließlich Early-Reject.
 * Polynom wird hier normativ festgelegt.
 *
 * CRC8-ATM (poly 0x07) ist klein, stabil und ausreichend als "quick check".
 * Starke Integrität ist CRC32C (Trailer).
 */
#define CL_CRC8_POLY_U8   0x07u
#define CL_CRC8_INIT_U8   0x00u
#define CL_CRC8_XOROUT_U8 0x00u

/* Berechnungs-API (Implementation in .c, nicht hier als Heuristik):
 *   - cl_crc8_hdr16() berechnet hdr_crc8 für cl_wire_hdr16_t (hdr_crc8=0).
 */
uint8_t cl_crc8_hdr16(const cl_wire_hdr16_t *h);

/* ---------------------------- CRC32C Trailer ------------------------------ */

/* CRC32C (Castagnoli) */
#define CL_CRC32C_INIT_U32   0xFFFFFFFFu
#define CL_CRC32C_XOROUT_U32 0xFFFFFFFFu

/* 4B Trailer – little-endian */
typedef struct __attribute__((packed)) cl_wire_crc32c_tail4 {
    uint32_t crc32c_le;
} cl_wire_crc32c_tail4_t;

_Static_assert(sizeof(cl_wire_crc32c_tail4_t) == 4, "crc32c tail muss 4B sein");

/* Optionaler Batch-CRC Trailer – 16B (konstant, maschinenfreundlich)
 *
 * Anwendung:
 *   - Ein Frame mit CL_WF_BATCH_CRC32C trägt am Ende dieses Trailer-Struct.
 *   - seq_end48 beschreibt den letzten seq im Batch (inkl.).
 *   - batch_id ist der Batch-Kontext.
 *   - crc32c schützt die aggregierte Batch-Payload (vertraglich definiert).
 *
 * Hinweis:
 *   - Diese 16B sind bewusst konstant (keine variablen Strukturen).
 */
typedef struct __attribute__((packed)) cl_wire_batch_crc_tail16 {
    uint16_t magic_le;      /* eigener Trailer-Magic */
    uint16_t batch_id_le;   /* passt zum Header batch_id */
    uint8_t  seq_end48_le[6];
    uint32_t crc32c_le;     /* CRC32C über vereinbarte Batch-Daten */
    uint16_t reserved0;     /* muss 0 sein */
} cl_wire_batch_crc_tail16_t;

#define CL_WIRE_BATCH_CRC_MAGIC_U16 0xC3C3u

_Static_assert(sizeof(cl_wire_batch_crc_tail16_t) == 16, "batch crc tail muss 16B sein");

/* --------------------- CRC32C: Hardware-naher Update-Pfad ------------------
 *
 * Diese Inlines sind rein mechanisch:
 *   - keine Policy, keine Autodetektion
 *   - nur: wenn Compiler+CPU SSE4.2 erlaubt, dann kann man _mm_crc32_* nutzen.
 *
 * Hinweis:
 *   - CPUID/Gate-Entscheidung gehört in HAL/CORE/FLOW (possible/effective),
 *     nicht in diesen Header.
 */
#if defined(__SSE4_2__)
#include <nmmintrin.h> /* _mm_crc32_u8/u64 */

static inline uint32_t cl_crc32c_sse42_u8(uint32_t crc, const uint8_t *p, size_t n) {
    /* crc ist laufender Zustand (init typ. CL_CRC32C_INIT_U32) */
    size_t i = 0;

    /* 8-byte chunks */
    while (i + 8 <= n) {
        uint64_t v;
        memcpy(&v, p + i, sizeof(v));
        crc = (uint32_t)_mm_crc32_u64((uint64_t)crc, v);
        i += 8;
    }

    /* tail */
    while (i < n) {
        crc = _mm_crc32_u8(crc, p[i]);
        i++;
    }

    return crc;
}

#endif /* __SSE4_2__ */

/* CRC32C API (Implementation in .c, policy-/gate-gebunden):
 *   - cl_crc32c_update() rechnet CRC32C über bytes
 *   - Implementation darf SSE4.2 nutzen, wenn possible/effective.
 */
uint32_t cl_crc32c_update(uint32_t crc, const void *data, size_t len);

/* -------------------------- Trailer-Verträge -------------------------------
 *
 * Payload CRC32C Trailer (CL_WF_PAYLOAD_CRC32C):
 *   wire frame layout:
 *     [cl_wire_hdr16_t][payload bytes (payload_len)][cl_wire_crc32c_tail4_t]
 *
 * Batch CRC32C Trailer (CL_WF_BATCH_CRC32C):
 *   wire frame layout:
 *     [cl_wire_hdr16_t][payload bytes (payload_len)][cl_wire_batch_crc_tail16_t]
 *
 * Achtung:
 *   - payload_len zählt NICHT den Trailer mit.
 *   - Receiver muss anhand flags den Trailer erwarten und prüfen.
 */


<<< END FILE: ./include/cl_manifest/cl_wire_crc.h

>>> START FILE: ./include/cl_manifest/cl_wire.h
#pragma once
/* ============================================================================
 * CommanderLink – CLWP Wire Header (16B) – FINAL Endausbau
 * Datei: include/cl_manifest/cl_wire.h
 * ============================================================================
 *
 * Grundsatz:
 *   - Wire ist ein physikalisches Artefakt (nicht "C-API").
 *   - Wire ist explizit little-endian.
 *   - Header ist exakt 16 Byte und packed.
 *
 * Vertrag (CLWP):
 *   - 16-bit Magic (LE)
 *   - 8-bit ver_mode: high nibble = version, low nibble = mode
 *   - 8-bit flags
 *   - 48-bit seq (LE, 6 bytes)
 *   - 16-bit batch_id (LE)
 *   - 16-bit payload_len (LE)  -> Länge des Payloads OHNE Trailer
 *   - 8-bit hdr_crc8           -> Early-Reject (Header-CRC)
 *   - 8-bit reserved           -> muss 0 sein
 *
 * Hinweis:
 *   - Starke Integrität erfolgt NICHT im Header (sonst müsste der Header wachsen),
 *     sondern über Payload-Trailer (CRC32C) gemäß cl_wire_crc.h.
 * ============================================================================
 */

#include <stdint.h>
#include <string.h> /* memcpy */

/* ----------------------------- Konstanten -------------------------------- */

#define CL_WIRE_VER_1 1u

/* 16-bit Wire Magic (auf dem Draht LE kodiert) */
#define CL_WIRE_MAGIC_U16 0xC1C1u

/* Flags (bitweise, 8-bit) */
#define CL_WF_PAYLOAD_CRC32C   (1u << 0) /* Payload hat CRC32C Trailer (4B)          */
#define CL_WF_BATCH_CRC32C     (1u << 1) /* Frame trägt/abschließt Batch-CRC32C     */
#define CL_WF_COMPRESSED       (1u << 2) /* Payload komprimiert (z.B. LZ4)          */
#define CL_WF_FEC              (1u << 3) /* Payload ist FEC-geschützt / shard       */
#define CL_WF_URGENT           (1u << 4) /* Priorität im Budget (trotzdem budgetiert) */
#define CL_WF_SYNC             (1u << 5) /* Synchronisationsframe                   */
#define CL_WF_OOB              (1u << 6) /* OOB im Data-Plane-Kanal (nicht Discovery) */
#define CL_WF_RSVD             (1u << 7) /* reserviert (muss 0 sein)                */

/* ver/mode nibble packing */
#define CL_WIRE_VER_GET(vm)        (((vm) >> 4) & 0x0Fu)
#define CL_WIRE_MODE_GET(vm)       ((vm) & 0x0Fu)
#define CL_WIRE_VER_MODE(ver,mode) ((((ver)&0x0Fu) << 4) | ((mode)&0x0Fu))

/* Modes (low nibble) – Vertrag (semantisch, nicht backend-spezifisch) */
typedef enum {
    CL_WM_RAW           = 0, /* Zero-Transform: Payload ist "as-is"            */
    CL_WM_FLOW          = 1, /* FLOW ohne zusätzliche Transform-Trailer        */
    CL_WM_FLOW_LZ4      = 2, /* FLOW mit LZ4 (Payload-Format in FLOW-Contract) */
    CL_WM_FLOW_FEC      = 3, /* FLOW mit FEC                                    */
    CL_WM_FLOW_LZ4_FEC  = 4, /* FLOW mit LZ4 + FEC                               */
    CL_WM_OOB           = 5, /* OOB-Frame (nicht Beacon/Discovery)              */
    CL_WM_SYNC          = 6  /* SYNC/Control Frames                              */
} cl_wire_mode_t;

/* --------------------------- CLWP Header 16B ------------------------------ */

typedef struct __attribute__((packed)) cl_wire_hdr16 {
    uint16_t magic_le;        /* CL_WIRE_MAGIC_U16, LE */
    uint8_t  ver_mode;        /* ver/mode nibble */
    uint8_t  flags;           /* CL_WF_* */

    uint8_t  seq48_le[6];     /* 48-bit seq, LE (least-significant byte first) */

    uint16_t batch_id_le;     /* batch group, LE */
    uint16_t payload_len_le;  /* payload length (excludes any trailer), LE */

    uint8_t  hdr_crc8;        /* CRC8 over header (siehe unten) */
    uint8_t  reserved0;       /* muss 0 sein */
} cl_wire_hdr16_t;

_Static_assert(sizeof(cl_wire_hdr16_t) == 16, "cl_wire_hdr16_t muss exakt 16B sein");

/* ------------------------- Seq48 load/store --------------------------------
 * Physik:
 *   - seq48 wird als 6 Bytes little-endian gespeichert.
 *   - Zugriff erfolgt über memcpy, um Strict-Aliasing sauber zu halten.
 */
static inline uint64_t cl_wire_seq48_load(const uint8_t seq48_le[6]) {
    uint64_t v = 0;
    /* Little-endian: Byte 0 ist LSB */
    v |= (uint64_t)seq48_le[0] << 0;
    v |= (uint64_t)seq48_le[1] << 8;
    v |= (uint64_t)seq48_le[2] << 16;
    v |= (uint64_t)seq48_le[3] << 24;
    v |= (uint64_t)seq48_le[4] << 32;
    v |= (uint64_t)seq48_le[5] << 40;
    return v;
}

static inline void cl_wire_seq48_store(uint8_t seq48_le[6], uint64_t seq) {
    /* nur low 48 bits gültig */
    seq48_le[0] = (uint8_t)((seq >> 0) & 0xFFu);
    seq48_le[1] = (uint8_t)((seq >> 8) & 0xFFu);
    seq48_le[2] = (uint8_t)((seq >> 16) & 0xFFu);
    seq48_le[3] = (uint8_t)((seq >> 24) & 0xFFu);
    seq48_le[4] = (uint8_t)((seq >> 32) & 0xFFu);
    seq48_le[5] = (uint8_t)((seq >> 40) & 0xFFu);
}

/* ------------------------- Header CRC8 Vertrag -----------------------------
 *
 * Ziel:
 *   - hdr_crc8 ist ausschließlich Early-Reject, nicht "starke Integrität".
 *   - Starke Integrität erfolgt über CRC32C Trailer (cl_wire_crc.h).
 *
 * Definition (normativ):
 *   - hdr_crc8 wird über die 16B Header-Bytes berechnet,
 *     wobei hdr_crc8 selbst als 0 gesetzt wird.
 *   - reserved0 muss 0 sein.
 *
 * CRC8-Polynom:
 *   - Der konkrete CRC8-Algorithmus ist implementation-defined,
 *     ABER MUSS global einheitlich sein (manifestiert in cl_wire_crc.h).
 */


<<< END FILE: ./include/cl_manifest/cl_wire.h

>>> START FILE: ./include/cl_manifest/cl_zero_transform.h
#pragma once
/* ============================================================================
 * CommanderLink – Zero-Transformation Standard (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_zero_transform.h
 * ============================================================================
 */

#include <stdint.h>

#define CL_ATOM_BYTES 64u
#define CL_HEADROOM_DEFAULT_BYTES 64u

#define CL_ZT_FORBID_SHIFT_REPACK 1
#define CL_ZT_FORBID_HOT_MEMCPY   1
#define CL_ZT_FORBID_HOT_ENDIAN   1
#define CL_ZT_FORBID_HOT_ATOMICS  1

/* Wire payload muss NICHT zwingend multiple-of-64 sein (Alltagstauglichkeit) */
#define CL_ZT_WIRE_PAYLOAD_MUST_BE_MULTIPLE_OF_64 0


<<< END FILE: ./include/cl_manifest/cl_zero_transform.h

>>> START FILE: ./include/cl_monitor/cl_monitor.h
#ifndef CL_MONITOR_H
#define CL_MONITOR_H

#include <stdint.h>

typedef enum {
    CL_MON_TAB_DASH = 0,
    CL_MON_TAB_INV  = 1,
    CL_MON_TAB_CPU  = 2,
    CL_MON_TAB_MEM  = 3,
    CL_MON_TAB_NIC  = 4,
    CL_MON_TAB_MESH = 5,
    CL_MON_TAB_DMA  = 6,
    CL_MON_TAB_ZFS  = 7,
    CL_MON_TAB_PCIE = 8,
    CL_MON_TAB_GPU  = 9,
    CL_MON_TAB_ORA  = 10,
    CL_MON_TAB_AUD  = 11
} cl_mon_tab_t;

/* Startet den Monitor (ncurses loop).
 * Rückgabe: exit code.
 */
int cl_monitor_run(void);

#endif


<<< END FILE: ./include/cl_monitor/cl_monitor.h

>>> START FILE: ./include/cl_runtime/cl_gates.h
#pragma once
/* ============================================================================
 * CommanderLink – Globale Gates (Systemzustände & physikalische Schranken)
 *
 * Datei:        include/cl_runtime/cl_gates.h
 *
 * Beschreibung:
 *   Dieses Header definiert die globalen Gates von CommanderLink.
 *
 *   Gates sind KEINE Policy.
 *   Gates sind KEINE Heuristik.
 *   Gates sind KEINE Entscheidung.
 *
 *   Gates sind die materialisierte physikalische Realität des Systems:
 *     - thermische Grenzen
 *     - elektrische Grenzen (VRM/Power)
 *     - Budget- und Interaktivitätszwänge
 *     - Sicherheits- und Trust-Zustände
 *
 *   Alle Runtime-Segmente referenzieren diese Gates.
 *   Kein Segment darf eigene Gate-Semantik erfinden.
 *
 *   Architektur:
 *     - x86_64, little-endian Host
 *     - 64-bit Gate-Masken
 *     - atomar lesbar/schreibbar
 *
 *   WICHTIG:
 *     Dieses Header enthält bewusst KEINE Logik.
 *     Auswertung, Reaktion und Policy liegen außerhalb.
 * ========================================================================== */

#ifndef CL_GATES_H
#define CL_GATES_H

#include <stdint.h>

/* --------------------------------------------------------------------------
 * Architekturannahmen (explizit)
 * -------------------------------------------------------------------------- */
#if !defined(__x86_64__) && !defined(_M_X64)
#error "CommanderLink ist x86_64-first. cl_gates.h setzt x86_64 voraus."
#endif

/* --------------------------------------------------------------------------
 * Gate-Typen: Grundsätzliches Modell
 *
 * - Gates werden als Bitmasken in uint64_t geführt.
 * - Mehrere Gates können gleichzeitig aktiv sein.
 * - Gates sind rein deskriptiv.
 *
 * Begriffe:
 *   possible  : physikalisch / logisch möglich
 *   effective : aktuell wirksam (nach allen Überlagerungen)
 *
 * Beispiel:
 *   AVX-512 possible, aber wegen Thermal-Gate nicht effective.
 * -------------------------------------------------------------------------- */

/* --------------------------------------------------------------------------
 * Gate-Klassen (logische Gruppierung, KEINE Bitwerte)
 * -------------------------------------------------------------------------- */
typedef enum cl_gate_class {
    CL_GATE_CLASS_THERMAL = 0,   /* Temperatur / thermische Limits        */
    CL_GATE_CLASS_POWER,        /* Strom, VRM, Package Power             */
    CL_GATE_CLASS_BUDGET,       /* Zeit-/CPU-/IO-Budget                  */
    CL_GATE_CLASS_INTERACTIVE,  /* Nutzer-Interaktivität                 */
    CL_GATE_CLASS_TRUST,        /* Join / Trust / Security               */
    CL_GATE_CLASS_PLATFORM,     /* Plattform- / Umgebungsrestriktionen   */
    CL_GATE_CLASS_INTERNAL      /* interne Schutzmechanismen             */
} cl_gate_class_t;

/* --------------------------------------------------------------------------
 * Gate-Bits (physikalische Zustände)
 *
 * Bitlayout:
 *   - Niedrige Bits: harte physikalische Schranken
 *   - Mittlere Bits: weiche / adaptive Schranken
 *   - Hohe Bits: logische / sicherheitsrelevante Zustände
 * -------------------------------------------------------------------------- */
typedef uint64_t cl_gate_mask_t;

/* --- Thermische Gates ----------------------------------------------------- */
#define CL_GATE_THERMAL_SOFT        (1ULL << 0)   /* Temperatur hoch, Drossel empfohlen */
#define CL_GATE_THERMAL_HARD        (1ULL << 1)   /* Temperatur kritisch, Drossel Pflicht */

/* --- Power / VRM Gates ---------------------------------------------------- */
#define CL_GATE_POWER_SOFT          (1ULL << 2)   /* Power Budget angespannt             */
#define CL_GATE_POWER_HARD          (1ULL << 3)   /* Power Budget überschritten          */
#define CL_GATE_VRM_LIMIT           (1ULL << 4)   /* VRM meldet Limit / Instabilität     */

/* --- Budget Gates --------------------------------------------------------- */
#define CL_GATE_BUDGET_EXCEEDED     (1ULL << 5)   /* Laufzeit-Budget überschritten       */
#define CL_GATE_BUDGET_RECLAIM      (1ULL << 6)   /* Reclaim aktiv (Bulk freigegeben)    */

/* --- Interaktivität ------------------------------------------------------- */
#define CL_GATE_INTERACTIVE_ACTIVE  (1ULL << 7)   /* Nutzer-/Systeminteraktivität aktiv  */

/* --- Trust / Security ----------------------------------------------------- */
#define CL_GATE_TRUST_NONE          (1ULL << 16)  /* kein Trust (Default-Deny)           */
#define CL_GATE_TRUST_ESTABLISHED   (1ULL << 17)  /* Trust ausgehandelt                  */
#define CL_GATE_TRUST_ACTIVE        (1ULL << 18)  /* Trust aktiv, Data Plane erlaubt     */

#define CL_GATE_SECURITY_DEGRADED   (1ULL << 19)  /* Security nicht voll gewährleistet   */

/* --- Plattform / Umgebung ------------------------------------------------ */
#define CL_GATE_PLATFORM_VM         (1ULL << 24)  /* Ausführung in VM                    */
#define CL_GATE_PLATFORM_LIMITED    (1ULL << 25)  /* reduzierte Telemetrie / Caps        */

/* --- Interne Schutzmechanismen ------------------------------------------- */
#define CL_GATE_WATCHDOG_TRIGGERED  (1ULL << 32)  /* Watchdog hat ausgelöst              */
#define CL_GATE_INTERNAL_ERROR      (1ULL << 33)  /* interner Inkonsistenzschutz         */

/* --------------------------------------------------------------------------
 * Gate-Masken (Zusammenfassungen)
 * -------------------------------------------------------------------------- */

/* Alle Gates, die harte Drosselung erzwingen */
#define CL_GATE_MASK_HARD_LIMITS ( \
    CL_GATE_THERMAL_HARD      |   \
    CL_GATE_POWER_HARD        |   \
    CL_GATE_VRM_LIMIT         |   \
    CL_GATE_WATCHDOG_TRIGGERED )

/* Gates, die Interaktivität schützen */
#define CL_GATE_MASK_INTERACTIVE ( \
    CL_GATE_INTERACTIVE_ACTIVE |  \
    CL_GATE_BUDGET_RECLAIM )

/* Gates, die Data Plane grundsätzlich verbieten */
#define CL_GATE_MASK_NO_DATAPLANE ( \
    CL_GATE_TRUST_NONE        |    \
    CL_GATE_SECURITY_DEGRADED |    \
    CL_GATE_WATCHDOG_TRIGGERED )

/* --------------------------------------------------------------------------
 * Gate-Zustandscontainer
 *
 * Wird in Segmenten verwendet, um possible/effective sauber zu trennen.
 * Größe: 16 Byte (2 × u64), cacheline-neutral.
 * -------------------------------------------------------------------------- */
typedef struct cl_gate_state {
    cl_gate_mask_t possible;   /* was physikalisch / logisch möglich ist */
    cl_gate_mask_t effective;  /* was aktuell wirksam ist                */
} cl_gate_state_t;

_Static_assert(sizeof(cl_gate_state_t) == 16,
               "cl_gate_state_t muss exakt 16 Byte groß sein");

/* --------------------------------------------------------------------------
 * Semantik-Hinweise (KEIN Code!)
 *
 * - possible darf nur erweitert werden, niemals implizit eingeschränkt.
 * - effective ist das Ergebnis aller aktuell aktiven Gates.
 * - Kein Modul darf Gates „wegdiskutieren“.
 * - Monitor zeigt possible vs effective explizit getrennt an.
 * -------------------------------------------------------------------------- */

#endif /* CL_GATES_H */


<<< END FILE: ./include/cl_runtime/cl_gates.h

>>> START FILE: ./include/cl_runtime/cl_quality.h
#pragma once
/* ============================================================================
 * CommanderLink – Source/Quality (Runtime) – FINAL
 * Datei: include/cl_runtime/cl_quality.h
 * ============================================================================
 *
 * Zweck:
 *   - Herkunft und Güte von Telemetrie (Maximalmodell).
 *   - Monitor zeigt Source/Quality lückenlos.
 *   - Oracle/Flow entscheiden anhand Quality, ob Werte kontrollwirksam sind.
 * ============================================================================
 */

#include <stdint.h>

typedef enum {
    CL_SRC_UNSPECIFIED = 0,
    CL_SRC_DIRECT_HW   = 1,
    CL_SRC_OS_IFACE    = 2,
    CL_SRC_TOOL        = 3,
    CL_SRC_INFERRED    = 4,
    CL_SRC_SIMULATED   = 5
} cl_source_t;

typedef enum {
    CL_QUAL_UNSUPPORTED = 0,
    CL_QUAL_ESTIMATED   = 1,
    CL_QUAL_BEST_EFFORT = 2,
    CL_QUAL_DIRECT      = 3
} cl_quality_t;

static inline int cl_quality_control_ok(cl_quality_t q) {
    return (q == CL_QUAL_DIRECT) || (q == CL_QUAL_BEST_EFFORT);
}


<<< END FILE: ./include/cl_runtime/cl_quality.h

>>> START FILE: ./include/cl_runtime/cl_runtime.h
#pragma once
/* ============================================================================
 * CommanderLink – Runtime Frontdoor
 * Datei: include/cl_runtime/cl_runtime.h
 * ============================================================================
 *
 * Zweck:
 *   Diese Datei ist die EINZIGE offizielle Eintrittsstelle in die
 *   CommanderLink Runtime-Wahrheit.
 *
 *   Wer dieses Header includiert, erklärt:
 *     - ich lese Laufzeit-Zustand (SHM)
 *     - ich erwarte keine Policy
 *     - ich erwarte keine Logik
 *
 *   Die Runtime beschreibt:
 *     - WAS zur Laufzeit existiert
 *     - WIE es physikalisch im Speicher liegt
 *     - WIE es beobachtet werden darf
 *
 *   Die Runtime beschreibt NICHT:
 *     - WANN etwas geschieht
 *     - WARUM etwas entschieden wird
 *     - WIE Initialisierung erfolgt
 *
 *   Architektur:
 *     - x86_64 first
 *     - Host-Endianness
 *     - Cacheline-exakt
 *     - ABI-stabil
 *
 *   Plattformen:
 *     - Linux
 *     - FreeBSD / GhostBSD
 *     - OmniOS / illumos
 *
 *   KEINE Policy. KEINE Heuristik. KEINE Logik.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

/* --------------------------------------------------------------------------
 * 1) Fundamentale Runtime-Typen (ohne Abhängigkeiten)
 * -------------------------------------------------------------------------- */

/* Gates = physikalische Schranken */
#include "cl_gates.h"

/* Beobachtungsqualität / Quelle */
#include "cl_quality.h"

/* --------------------------------------------------------------------------
 * 2) Manifest-nahe Definitionen (symbolische Wahrheit)
 * -------------------------------------------------------------------------- */

/* Enums & IDs (reine Zustandskodierung) */
#include "../cl_manifest/cl_enums.h"
#include "../cl_manifest/cl_ids.h"

/* --------------------------------------------------------------------------
 * 3) Runtime-Ordnung & Verkabelung
 * -------------------------------------------------------------------------- */

/* Table of Contents (physikalische SHM-Struktur) */
#include "cl_toc.h"

/* SHM-Layout & Speicherklassen */
#include "cl_shm_layout.h"

/* Runtime-Schema (Pflicht / Optional / Feature-gebunden) */
#include "cl_schema.h"

/* BOOTEN VON CL */
#include "cl_service_seg_256.h"

/* --------------------------------------------------------------------------
 * 4) Runtime-Segmente (SHM-Wahrheit)
 * -------------------------------------------------------------------------- */

/* Kernsegmente - INVENTAR */
#include "cl_seg_cpu_1024.h"
#include "cl_seg_budget_256.h"
#include "cl_seg_mem_256.h"
#include "cl_seg_time_256.h"
#include "cl_seg_board_512.h"

/* Netzwerk / Transfer */
#include "cl_seg_nic_512.h"
#include "cl_seg_link_256.h"
#include "cl_seg_overlay_256.h"
#include "cl_seg_mesh_neighbor_256.h"
#include "cl_seg_mesh_peer_256.h"
#include "cl_seg_dma_4096.h"

/* System / Stabilität */
#include "cl_seg_watchdog_256.h"
#include "cl_seg_pcie_256.h"

/* Storage */
#include "cl_seg_zfs_4096.h"

/* Analyse / Langzeit */
#include "cl_seg_oracle_256.h"
#include "cl_seg_history_4096.h"
#include "cl_seg_forensics_4096.h"

/* Datenpaket */


/* --------------------------------------------------------------------------
 * 5) Runtime-Meta (rein beschreibend)
 * -------------------------------------------------------------------------- */

/*
 * cl_runtime_caps_t beschreibt, welche Teile der Runtime
 * in einer konkreten Instanz existieren KÖNNEN.
 *
 * Dies ist KEINE Initialisierung, KEINE Policy, KEINE Logik.
 * Es ist eine deklarative Zusammenfassung für:
 *   - Monitor
 *   - Tools
 *   - Minimal-Boot
 */
typedef struct cl_runtime_caps {

    /* Grundlegende Verfügbarkeit */
    uint8_t has_cpu;
    uint8_t has_memory;
    uint8_t has_budget;

    /* Netzwerk */
    uint8_t has_nic;
    uint8_t has_mesh;
    uint8_t has_dma;

    /* Storage */
    uint8_t has_zfs;

    /* Analyse */
    uint8_t has_oracle;
    uint8_t has_history;
    uint8_t has_forensics;

} cl_runtime_caps_t;

/*
 * Hinweis:
 *   cl_runtime_caps_t wird NICHT von der Runtime gesetzt.
 *   Es ist eine deklarative Beschreibung dessen,
 *   was prinzipiell Teil der Runtime sein kann.
 */



<<< END FILE: ./include/cl_runtime/cl_runtime.h

>>> START FILE: ./include/cl_runtime/cl_schema.h
#pragma once
/* ============================================================================
 * CommanderLink – Schema/ABI Contract (Runtime) – FINAL
 * Datei: include/cl_runtime/cl_schema.h
 * ============================================================================
 *
 * Zweck:
 *   - Einmalige, zentrale Definition der Runtime-Schema-Version.
 *   - Endianness Magic (Host sanity).
 *   - Page-Größe/Alignment (Root-Page).
 *
 * Maschinenregel:
 *   - SHM ist Host-Order.
 *   - endian_magic muss beim Attach geprüft werden.
 *   - Schema bump nur bei semantisch relevanten Layout-Änderungen.
 * ============================================================================
 */

#include <stdint.h>

#define CL_SCHEMA_VERSION_U32  0x00000111u
#define CL_ENDIAN_MAGIC_U32    0x12345678u
#define CL_SHM_PAGE_BYTES      4096u

#define CL_ABI_CHECKSUM_NONE   0ull



<<< END FILE: ./include/cl_runtime/cl_schema.h

>>> START FILE: ./include/cl_runtime/cl_seg_board_512.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Board/VRM/Power (512B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_board_512.h
 * ============================================================================
 *
 * Maximalmodell:
 * - Board/VRM/Power sind Safety Cutoff Inputs, nicht Hot-Pacing Inputs.
 * - Alle Werte haben state/source/quality.
 * - Hersteller/Name/Serial ist in COLD enthalten (Monitor-Anforderung).
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT A 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) board_therm_state; /* cl_thermal_state_t */
        _Atomic(uint32_t) board_cap_flags;   /* constraint bits (VRM/POWER/THERM) */

        _Atomic(uint32_t) vrm_temp_c_x10;
        _Atomic(uint32_t) pch_temp_c_x10;

        _Atomic(uint32_t) pwr_package_mw;
        _Atomic(uint32_t) pwr_limit_mw;

        _Atomic(uint32_t) vrm_ripple_mv_x10;
        _Atomic(uint32_t) power_unstable;    /* 0/1 */

        _Atomic(uint64_t) last_update_ns;
    };
    uint8_t raw[64];
} cl_board_hot_64a_t;

CL_STATIC_ASSERT(sizeof(cl_board_hot_64a_t) == 64, "board hot a 64");

/* HOT B 64 (smoothed outputs + events) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) vrm_temp_avg_c_x10;
        _Atomic(uint32_t) pwr_pkg_avg_mw;
        _Atomic(uint32_t) ripple_avg_mv_x10;
        _Atomic(uint32_t) vrm_trend_permille;

        _Atomic(uint64_t) cap_events_total;
        _Atomic(uint64_t) power_events_total;
        _Atomic(uint64_t) thermal_events_total;

        uint64_t reserved0;
    };
    uint8_t raw[64];
} cl_board_hot_64b_t;

CL_STATIC_ASSERT(sizeof(cl_board_hot_64b_t) == 64, "board hot b 64");

/* WARM A 64 (fans/rails) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) fan_rpm_0;
        _Atomic(uint32_t) fan_rpm_1;
        _Atomic(uint32_t) fan_rpm_2;
        _Atomic(uint32_t) fan_rpm_3;

        _Atomic(uint32_t) v12_mv;
        _Atomic(uint32_t) v5_mv;

        _Atomic(uint32_t) vrm_supported;
        _Atomic(uint32_t) ripple_supported;

        uint64_t reserved0;
    };
    uint8_t raw[64];
} cl_board_warm_64a_t;

CL_STATIC_ASSERT(sizeof(cl_board_warm_64a_t) == 64, "board warm a 64");

/* WARM B 64 (feature states) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint16_t) vrm_state;     /* cl_feature_state_t */
        _Atomic(uint16_t) ripple_state;  /* cl_feature_state_t */
        _Atomic(uint16_t) pwr_state;     /* cl_feature_state_t */
        _Atomic(uint16_t) therm_state;   /* cl_feature_state_t */

        _Atomic(uint32_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
        _Atomic(uint64_t) reserved4;
    };
    uint8_t raw[64];
} cl_board_warm_64b_t;

CL_STATIC_ASSERT(sizeof(cl_board_warm_64b_t) == 64, "board warm b 64");

/* COLD 64 (Inventory strings: vendor/model/serial) */
typedef union CL_ALIGNAS(8) {
    struct {
        char vendor[16];
        char model[16];
        char serial[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;

        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_board_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_board_cold_64_t) == 64, "board cold 64");

/* RSV lines */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_board_rsv_64_t;

typedef struct CL_ALIGNAS(512) {
    cl_board_hot_64a_t  hot_a;
    cl_board_hot_64b_t  hot_b;
    cl_board_warm_64a_t warm_a;
    cl_board_warm_64b_t warm_b;
    cl_board_cold_64_t  cold;
    cl_board_rsv_64_t   rsv0;
    cl_board_rsv_64_t   rsv1;
    cl_board_rsv_64_t   rsv2;
} cl_board_seg_512_t;

CL_STATIC_ASSERT(sizeof(cl_board_seg_512_t) == 512, "board seg 512");


<<< END FILE: ./include/cl_runtime/cl_seg_board_512.h

>>> START FILE: ./include/cl_runtime/cl_seg_budget_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Budget (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_budget_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - zeigt verfügbares RAM, staging caps, pressure, reclaim events
 * - zeigt, ob CL gerade aggressiv Ressourcen nutzt oder zurückzieht
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) budget_state;          /* cl_budget_state_t */
        _Atomic(uint32_t) interactive_hint;      /* 0/1 */

        _Atomic(uint32_t) cpu_pressure_permille; /* 0..1000 */
        _Atomic(uint32_t) mem_pressure_permille; /* 0..1000 */

        _Atomic(uint64_t) total_ram_bytes;       /* best-effort */
        _Atomic(uint64_t) free_ram_bytes;        /* best-effort */

        _Atomic(uint64_t) bulk_bytes_current;
        _Atomic(uint64_t) bulk_bytes_cap;
    };
    uint8_t raw[64];
} cl_budget_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_budget_hot_64_t) == 64, "budget hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) reclaim_events;
        _Atomic(uint64_t) shadow_events;
        _Atomic(uint64_t) user_activity_events;

        _Atomic(uint64_t) mem_reclaim_ns;

        _Atomic(uint32_t) io_pressure_permille;  /* best-effort */
        _Atomic(uint32_t) storage_pressure_permille; /* disk sink/backlog */

        _Atomic(uint64_t) last_pressure_ts_ns;
        _Atomic(uint64_t) reserved0;
    };
    uint8_t raw[64];
} cl_budget_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_budget_warm_64_t) == 64, "budget warm 64");

/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;

        uint32_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
        uint64_t reserved6;
    };
    uint8_t raw[64];
} cl_budget_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_budget_cold_64_t) == 64, "budget cold 64");

/* RSV 64 (append-only space) */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_budget_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_budget_hot_64_t  hot;
    cl_budget_warm_64_t warm;
    cl_budget_cold_64_t cold;
    cl_budget_rsv_64_t  rsv;
} cl_budget_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_budget_seg_256_t) == 256, "budget seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_budget_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_cpu_1024.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: CPU Core (1024B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_cpu_1024.h
 * ============================================================================
 *
 * Record = 16 Cachelines à 64B.
 * Maximalmodell:
 * - ISA possible/effective/state
 * - Thermik/Throttle/Headroom (state+reason)
 * - Hersteller/Modell/µcode (COLD strings)
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "../cl_manifest/cl_features.h"
#include "cl_quality.h"

/* HOT 0 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) tsc_val;
        _Atomic(uint64_t) last_update_ns;

        _Atomic(uint32_t) local_seq;
        _Atomic(uint32_t) load_permille;

        _Atomic(uint32_t) temp_c_x10;
        _Atomic(uint32_t) throttling;       /* 0/1 */

        _Atomic(uint32_t) headroom_permille;/* best-effort */
        _Atomic(uint32_t) reason_code;      /* cl_reason_code_t */

        _Atomic(uint32_t) constraint_flags; /* thermal/power/budget */
        _Atomic(uint32_t) reserved0;
    };
    uint8_t raw[64];
} cl_cpu_hot_64a_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_hot_64a_t)==64, "cpu hot 64a");

/* HOT 1 (ISA) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) isa_possible_mask;  /* cl_cpu_isa_mask_t */
        _Atomic(uint32_t) isa_effective;      /* cl_cpu_isa_effective_t */

        _Atomic(uint16_t) isa_state;          /* cl_feature_state_t */
        _Atomic(uint16_t) avx512_risk;        /* cl_avx512_risk_t (manifest) */
        _Atomic(uint16_t) simd_effective;     /* cl_simd_effective_t (manifest) */
        _Atomic(uint16_t) reserved0;

        _Atomic(uint64_t) inst_retired;
        _Atomic(uint64_t) cycles;

        _Atomic(uint64_t) uops_issued;
        _Atomic(uint64_t) uops_stalled;
    };
    uint8_t raw[64];
} cl_cpu_hot_64b_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_hot_64b_t)==64, "cpu hot 64b");

/* WARM lines 2..7 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) l1d_misses;
        _Atomic(uint64_t) itlb_misses;
        _Atomic(uint64_t) dtlb_misses;
        _Atomic(uint64_t) llc_misses;

        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
    };
    uint8_t raw[64];
} cl_cpu_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_warm_64_t)==64, "cpu warm 64");

/* COLD 8 (IDs) */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t vendor_id;
        uint32_t device_id;
        uint32_t model_id;
        uint32_t stepping;

        uint32_t numa_node;
        uint32_t reserved0;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
        uint32_t reserved2;

        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_cpu_cold_64a_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_cold_64a_t)==64, "cpu cold 64a");

/* COLD 9 (strings vendor/model) Teil 1*/
typedef union CL_ALIGNAS(8) {
    struct {
        char vendor_str[16];   /* "GenuineIntel" etc */
        char model_str_a[16];  /* Modelname Teil A */
        char model_str_b[16];  /* Modelname Teil B */

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_cpu_cold_64b_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_cold_64b_t)==64, "cpu cold 64b");

/* COLD 10 (strings) TEIL 2 */
typedef union CL_ALIGNAS(8) {
    struct {
        char model_str_c[32];  /* Modelname Teil C (weitere 32 Zeichen) */
        char ucode_str[16];    /* Microcode/Revision kurz */
        
        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_cpu_cold_64c_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_cold_64c_t)==64, "cpu cold 64c");

/* COLD 11..15 reserved/topology */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_cpu_cold_64r_t;
CL_STATIC_ASSERT(sizeof(cl_cpu_cold_64r_t)==64, "cpu cold r 64");

/* Record 1024 */
typedef struct CL_ALIGNAS(1024) {
    cl_cpu_hot_64a_t hot_a;           /* 0 */
    cl_cpu_hot_64b_t hot_b;           /* 1 */
    cl_cpu_warm_64_t warm[6];         /* 2..7 */
    cl_cpu_cold_64a_t cold_a;         /* 8 */
    cl_cpu_cold_64b_t cold_b;         /* 9 */
    cl_cpu_cold_64c_t cold_c;         /* 9 */
    cl_cpu_cold_64r_t cold_r[5];      /* 11..15 */
} cl_cpu_seg_1024_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_seg_1024_t)==1024, "cpu seg 1024");


<<< END FILE: ./include/cl_runtime/cl_seg_cpu_1024.h

>>> START FILE: ./include/cl_runtime/cl_seg_dma_4096.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: DMA Meta (4096B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_dma_4096.h
 * ============================================================================
 *
 * Zweck:
 *   - RX/TX Ring Meta, Slot Meta; Payload liegt backend-spezifisch außerhalb SHM.
 *
 * Maximalmodell:
 *   - alignment/headroom/atom geometry sichtbar
 *   - crc/fec counters sichtbar
 *
 * Layout:
 *   4096B = 64 Cachelines:
 *     RX hdr: 4 lines (256B)
 *     TX hdr: 4 lines (256B)
 *     Slot meta: 56 lines
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* Slot state */
typedef enum { CL_DMA_SLOT_FREE=0, CL_DMA_SLOT_BUSY=1, CL_DMA_SLOT_READY=2 } cl_dma_slot_state_t;

/* Ring header line 64B */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) ring_size;
        _Atomic(uint32_t) ring_mask;
        _Atomic(uint32_t) head;
        _Atomic(uint32_t) tail;

        _Atomic(uint64_t) slots_ready;
        _Atomic(uint64_t) slots_busy;

        _Atomic(uint32_t) alignment_bytes;     /* expected 64 */
        _Atomic(uint32_t) headroom_bytes;      /* expected 64 */

        _Atomic(uint32_t) payload_quantum_bytes; /* 64 */
        _Atomic(uint32_t) reserved0;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
        uint32_t reserved2;
    };
    uint8_t raw[64];
} cl_dma_ring_hdr_64_t;

CL_STATIC_ASSERT(sizeof(cl_dma_ring_hdr_64_t)==64, "dma ring hdr 64");

/* Slot meta line 64B */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) seq;
        _Atomic(uint64_t) ts_ns;
        _Atomic(uint64_t) opaque_ref64;  /* UMEM offset / netmap token / ptr */
        _Atomic(uint64_t) reserved0;

        _Atomic(uint32_t) state;         /* cl_dma_slot_state_t */
        _Atomic(uint32_t) payload_len;

        _Atomic(uint32_t) crc32c;        /* optional: per-slot/atom CRC summary */
        _Atomic(uint32_t) reserved1;

        _Atomic(uint64_t) reserved2;
    };
    uint8_t raw[64];
} cl_dma_slot_meta_64_t;

CL_STATIC_ASSERT(sizeof(cl_dma_slot_meta_64_t)==64, "dma slot meta 64");

/* Segment 4096 */
typedef struct CL_ALIGNAS(4096) {
    cl_dma_ring_hdr_64_t rx_hdr[4];
    cl_dma_ring_hdr_64_t tx_hdr[4];
    cl_dma_slot_meta_64_t slot[56];
} cl_dma_seg_4096_t;

CL_STATIC_ASSERT(sizeof(cl_dma_seg_4096_t)==4096, "dma seg 4096");


<<< END FILE: ./include/cl_runtime/cl_seg_dma_4096.h

>>> START FILE: ./include/cl_runtime/cl_seg_forensics_4096.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Forensics (4096B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_forensics_4096.h
 * ============================================================================
 *
 * Zweck:
 *   - Ringbuffer seltener, hochrelevanter Events.
 *   - Maximalmodell: commit_epoch + grant_id + reason/constraints immer dabei.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* Forensics Event IDs (append-only) */
typedef enum {
    CL_FX_NONE = 0,

    /* Discovery / Join */
    CL_FX_BEACON_SEEN = 100,
    CL_FX_HELLO_SENT = 101,
    CL_FX_HELLO_ACK_RX = 102,
    CL_FX_AUTH_FAIL = 110,
    CL_FX_REPLAY_DETECTED = 111,
    CL_FX_VERSION_MISMATCH = 112,
    CL_FX_MESH_MISMATCH = 113,
    CL_FX_IP_COLLISION = 114,
    CL_FX_TRUSTED_ACTIVE = 120,
    CL_FX_DENIED = 121,

    /* Grants / Credits */
    CL_FX_GRANT_RX = 200,
    CL_FX_GRANT_EXPIRED = 201,
    CL_FX_CREDIT_STARVATION = 202,

    /* Autopath */
    CL_FX_BACKEND_UPGRADE = 300,
    CL_FX_BACKEND_DOWNGRADE = 301,
    CL_FX_TCP_FALLBACK = 302
} cl_forensics_event_id_t;

/* Event 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) ts_ns;
        _Atomic(uint64_t) commit_epoch;
        _Atomic(uint64_t) grant_id;
        _Atomic(uint64_t) param1;

        _Atomic(uint32_t) event_id;
        _Atomic(uint32_t) reason_code;

        _Atomic(uint32_t) constraint_flags;
        _Atomic(uint32_t) aux;

        _Atomic(uint64_t) param2;
        _Atomic(uint64_t) param3;
    };
    uint8_t raw[64];
} cl_forensics_event_64_t;

CL_STATIC_ASSERT(sizeof(cl_forensics_event_64_t)==64, "forensics event 64");

/* Header 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) head;
        _Atomic(uint32_t) tail;
        _Atomic(uint32_t) mask;      /* 63 */
        _Atomic(uint32_t) dropped;

        _Atomic(uint64_t) last_event_ns;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;

        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
    };
    uint8_t raw[64];
} cl_forensics_hdr_64_t;

CL_STATIC_ASSERT(sizeof(cl_forensics_hdr_64_t)==64, "forensics hdr 64");

typedef struct CL_ALIGNAS(4096) {
    cl_forensics_hdr_64_t hdr;
    cl_forensics_event_64_t ev[63];
} cl_forensics_seg_4096_t;

CL_STATIC_ASSERT(sizeof(cl_forensics_seg_4096_t)==4096, "forensics seg 4096");


<<< END FILE: ./include/cl_runtime/cl_seg_forensics_4096.h

>>> START FILE: ./include/cl_runtime/cl_seg_history_4096.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: History (4096B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_history_4096.h
 * ============================================================================
 *
 * Zweck:
 *   - Oracle Trenddaten (eine Metrik pro Segmentinstanz).
 *   - Maximalmodell: Trends werden als Werte+Quelle/Qualität abgebildet.
 *
 * Layout:
 *   Header 64B + 63 Points à 64B.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "cl_quality.h"

/* Metric IDs (extend-only) */
typedef enum {
    CL_HIST_TX_BPS = 1,
    CL_HIST_RX_BPS = 2,
    CL_HIST_LOSS_PPM = 3,
    CL_HIST_JITTER_P99_US = 4,
    CL_HIST_CPU_PRESSURE = 5,
    CL_HIST_MEM_PRESSURE = 6,
    CL_HIST_STORAGE_SINK = 7,
    CL_HIST_THERMAL = 8
} cl_hist_metric_id_t;

/* Header 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) metric_id;
        _Atomic(uint32_t) write_idx;
        _Atomic(uint32_t) count;
        _Atomic(uint32_t) reserved0;

        _Atomic(uint64_t) last_ts_ns;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
        uint32_t reserved2;

        uint64_t reserved3;
        uint64_t reserved4;
    };
    uint8_t raw[64];
} cl_hist_hdr_64_t;

CL_STATIC_ASSERT(sizeof(cl_hist_hdr_64_t)==64, "hist hdr 64");

/* Point 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) ts_ns;
        _Atomic(uint64_t) value;
        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
        _Atomic(uint64_t) reserved4;
        _Atomic(uint64_t) reserved5;
    };
    uint8_t raw[64];
} cl_hist_point_64_t;

CL_STATIC_ASSERT(sizeof(cl_hist_point_64_t)==64, "hist point 64");

typedef struct CL_ALIGNAS(4096) {
    cl_hist_hdr_64_t hdr;
    cl_hist_point_64_t pts[63];
} cl_history_seg_4096_t;

CL_STATIC_ASSERT(sizeof(cl_history_seg_4096_t)==4096, "history seg 4096");


<<< END FILE: ./include/cl_runtime/cl_seg_history_4096.h

>>> START FILE: ./include/cl_runtime/cl_seg_link_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Link Summary (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_link_256.h
 * ============================================================================
 *
 * Record = 4 Cachelines à 64B:
 *   HOT   : effektiver Pfad/Backend/Mode/Profile + pacing/tick/mtu/batch + reasons
 *   WARM A: commit epochs + throughput totals + starvation + partials
 *   WARM B: Zero-Transform Geometrie + Accept + FEC/CRC/PHV + Compression + States
 *   COLD  : desired targets (policy) + src/qual
 *
 * Maximalmodell:
 *   - possible/effective/state für Integrity (CRC/FEC) und Zero-Transform
 *   - keine impliziten Defaults
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) path_state;        /* cl_path_state_t */
        _Atomic(uint32_t) backend_active;    /* cl_backend_active_t */
        _Atomic(uint32_t) backend_detail;    /* cl_backend_detail_t */
        _Atomic(uint32_t) profile_effective; /* cl_transfer_profile_t */

        _Atomic(uint32_t) mode_active;       /* cl_link_mode_t */
        _Atomic(uint32_t) constraint_flags;  /* cl_constraint_flags_t */
        _Atomic(uint32_t) reason_code;       /* cl_reason_code_t */
        _Atomic(uint32_t) global_health;     /* CL_HEALTH_* summary */

        _Atomic(uint32_t) pacing_actual_bps; /* smoothed */
        _Atomic(uint32_t) pacing_target_bps;

        _Atomic(uint32_t) tick_budget_us;

        _Atomic(uint16_t) mtu_effective;
        _Atomic(uint16_t) batch_target;

        /* last 4 bytes */
        _Atomic(uint32_t) batch_eff_permille; /* 0..1000 */
    };
    uint8_t raw[64];
} cl_link_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_link_hot_64_t) == 64, "link hot 64");

/* WARM A 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_commit_epoch;

        _Atomic(uint64_t) bytes_sent_1s;
        _Atomic(uint64_t) pkts_sent_1s;

        _Atomic(uint64_t) bytes_sent_total;
        _Atomic(uint64_t) pkts_sent_total;

        _Atomic(uint64_t) inject_partial_cnt;
        _Atomic(uint64_t) prepare_expired_cnt;
        _Atomic(uint64_t) credit_starvation_ns;
    };
    uint8_t raw[64];
} cl_link_warm_64a_t;

CL_STATIC_ASSERT(sizeof(cl_link_warm_64a_t) == 64, "link warm a 64");

/* WARM B 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        /* Zero-Transform / Atom-Geometry (Truth) */
        _Atomic(uint32_t) payload_quantum_bytes;   /* default 64 */
        _Atomic(uint32_t) payload_headroom_bytes;  /* negotiated/setup */

        /* Transfer Semantik */
        _Atomic(uint32_t) accept_mode;             /* cl_accept_mode_t */
        _Atomic(uint32_t) durable_granularity_bytes;

        /* Integrity: possible/effective/state */
        _Atomic(uint32_t) crc_mode_possible;       /* bitmask over cl_crc_mode_t */
        _Atomic(uint32_t) fec_mode_possible;       /* bitmask over cl_fec_mode_t */

        _Atomic(uint32_t) crc_mode_effective;      /* cl_crc_mode_t */
        _Atomic(uint32_t) fec_mode_effective;      /* cl_fec_mode_t */

        /* FEC parameters */
        _Atomic(uint16_t) fec_n;                   /* atoms per block */
        _Atomic(uint16_t) fec_k;                   /* parity atoms */
        _Atomic(uint16_t) crc_state;               /* cl_feature_state_t (fits u16) */
        _Atomic(uint16_t) fec_state;               /* cl_feature_state_t */

        /* Predict-Verify Gate state (optional) */
        _Atomic(uint16_t) phv_state;               /* cl_feature_state_t */
        uint16_t reserved0;

        /* Compression ladder (effective) */
        _Atomic(uint32_t) comp_mode;               /* cl_comp_mode_t */
    };
    uint8_t raw[64];
} cl_link_warm_64b_t;

CL_STATIC_ASSERT(sizeof(cl_link_warm_64b_t) == 64, "link warm b 64");

/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t profile_desired;
        uint32_t backend_desired;
        uint32_t mode_desired;
        uint32_t reserved0;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;

        uint32_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_link_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_link_cold_64_t) == 64, "link cold 64");

typedef struct CL_ALIGNAS(256) {
    cl_link_hot_64_t   hot;
    cl_link_warm_64a_t warm_a;
    cl_link_warm_64b_t warm_b;
    cl_link_cold_64_t  cold;
} cl_link_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_link_seg_256_t) == 256, "link seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_link_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_mem_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Memory (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_mem_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - total/free/used/ecc
 * - memory bandwidth hints (best-effort)
 * - DIMM mode strings optional via reserved/bulk later
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) total_bytes;
        _Atomic(uint64_t) used_bytes;
        _Atomic(uint64_t) free_bytes;
        _Atomic(uint64_t) ecc_err_cnt;

        _Atomic(uint32_t) pressure_permille;
        _Atomic(uint32_t) reason_code;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
    };
    uint8_t raw[64];
} cl_mem_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_mem_hot_64_t)==64, "mem hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) bw_read_bps;
        _Atomic(uint64_t) bw_write_bps;

        _Atomic(uint32_t) timing_tcl;
        _Atomic(uint32_t) timing_trcd;
        _Atomic(uint32_t) timing_trp;
        _Atomic(uint32_t) timing_tras;

        _Atomic(uint32_t) channel_state; /* cl_feature_state_t */
        _Atomic(uint32_t) reserved0;

        _Atomic(uint64_t) last_update_ns;
    };
    uint8_t raw[64];
} cl_mem_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_mem_warm_64_t)==64, "mem warm 64");

/* COLD 64 (inventory strings) */
typedef union CL_ALIGNAS(8) {
    struct {
        char dimm_mode[16];    /* "DDR4-2133" / "XMP" etc best-effort */
        char channel_mode[16]; /* "DUAL" "SINGLE" etc */
        char reserved_str[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;

        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_mem_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_mem_cold_64_t)==64, "mem cold 64");

/* RSV 64 */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_mem_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_mem_hot_64_t  hot;
    cl_mem_warm_64_t warm;
    cl_mem_cold_64_t cold;
    cl_mem_rsv_64_t  rsv;
} cl_mem_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_mem_seg_256_t)==256, "mem seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_mem_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_mesh_neighbor_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Mesh Neighbor HOT (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_mesh_neighbor_256.h
 * ============================================================================
 *
 * 32 Hot Neighbor Records (CL_MESH_HOT_NEIGHBORS) sind Ziel.
 * Maximalmodell: trust/state/negotiated/why + source/quality.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "../cl_manifest/cl_ids.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_seen_ns;

        _Atomic(uint32_t) trust_state;     /* cl_peer_trust_state_t */
        _Atomic(uint32_t) peer_state;      /* cl_peer_state_t */

        uint32_t peer_overlay_ip;
        uint32_t mtu_negotiated;

        uint32_t backend_active;           /* cl_backend_active_t */
        uint32_t profile_effective;        /* cl_transfer_profile_t */

        uint32_t loss_ppm;
        uint32_t jitter_p99_us;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
    };
    uint8_t raw[64];
} cl_mesh_neighbor_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_neighbor_hot_64_t) == 64, "mesh neighbor hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t ports_count;
        uint32_t link_speed_mbps;
        uint64_t rx_window_bytes;
        uint64_t drain_bps;

        uint32_t constraint_flags;
        uint32_t reason_code;

        uint16_t payload_quantum_bytes;
        uint16_t payload_headroom_bytes;
        uint16_t fec_n;
        uint16_t fec_k;

        uint32_t crc_mode_effective;
        uint32_t fec_mode_effective;
    };
    uint8_t raw[64];
} cl_mesh_neighbor_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_neighbor_warm_64_t) == 64, "mesh neighbor warm 64");

/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        cl_node_tag64_t node_tag64;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;

        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_mesh_neighbor_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_neighbor_cold_64_t) == 64, "mesh neighbor cold 64");

/* RSV 64 */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_mesh_neighbor_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_mesh_neighbor_hot_64_t  hot;
    cl_mesh_neighbor_warm_64_t warm;
    cl_mesh_neighbor_cold_64_t cold;
    cl_mesh_neighbor_rsv_64_t  rsv;
} cl_mesh_neighbor_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_neighbor_seg_256_t) == 256, "mesh neighbor seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_mesh_neighbor_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_mesh_peer_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Mesh Peer (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_mesh_peer_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - Trust (state + last_event + denied_reason)
 * - Negotiation (geometry + integrity)
 * - Credits (pkts/bytes) + durable progress
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "../cl_manifest/cl_ids.h"
#include "../cl_manifest/cl_trust.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_seen_ns;
        _Atomic(uint64_t) last_oob_rx_ns;

        _Atomic(uint32_t) trust_state;       /* cl_peer_trust_state_t */
        _Atomic(uint32_t) peer_state;        /* cl_peer_state_t */

        _Atomic(uint32_t) peer_overlay_ip;
        _Atomic(uint32_t) route_state;       /* cl_overlay_route_state_t (numeric) */

        _Atomic(uint32_t) constraint_flags;
        _Atomic(uint32_t) reason_code;

        _Atomic(uint32_t) trust_last_event;   /* cl_trust_event_id_t */
        _Atomic(uint32_t) trust_denied_reason;/* cl_reason_code_t subset */

        uint64_t reserved0;
    };
    uint8_t raw[64];
} cl_mesh_peer_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_hot_64_t) == 64, "mesh peer hot 64");

/* WARM A 64 (negotiated) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) rx_window_bytes;
        _Atomic(uint64_t) drain_bps;

        _Atomic(uint32_t) mtu_negotiated;
        _Atomic(uint32_t) ports_count;

        _Atomic(uint32_t) profile_allowed_mask;
        _Atomic(uint32_t) backend_allowed_mask;

        _Atomic(uint32_t) payload_quantum_bytes;
        _Atomic(uint32_t) payload_headroom_bytes;
    };
    uint8_t raw[64];
} cl_mesh_peer_warm_64a_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_warm_64a_t) == 64, "mesh peer warm a 64");

/* WARM B 64 (credits + accept/integrity progress) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) grant_id;
        _Atomic(uint64_t) refill_epoch;

        _Atomic(uint32_t) grant_ttl_ms;
        _Atomic(uint32_t) grant_age_ms;

        _Atomic(uint64_t) credits_pkts;
        _Atomic(uint64_t) credits_bytes;

        _Atomic(uint32_t) accept_mode;        /* cl_accept_mode_t */
        _Atomic(uint32_t) durable_lag_bytes;

        _Atomic(uint64_t) durable_commit_epoch;
        _Atomic(uint64_t) reserved0;
    };
    uint8_t raw[64];
} cl_mesh_peer_warm_64b_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_warm_64b_t) == 64, "mesh peer warm b 64");

/* WARM C 64 (Join/Replay/Rate-Limit – gedämpft, monitor-sichtbar) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) last_oob_epoch_seen;  /* lower 32 bits of last accepted epoch */
        _Atomic(uint32_t) replay_hits_total;

        _Atomic(uint32_t) join_attempts_total;
        _Atomic(uint32_t) join_rejects_total;

        _Atomic(uint32_t) rate_limited_total;
        _Atomic(uint32_t) reserved0;

        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
        _Atomic(uint64_t) reserved4;
        _Atomic(uint64_t) reserved5;
    };
    uint8_t raw[64];
} cl_mesh_peer_warm_64c_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_warm_64c_t) == 64, "mesh peer warm c 64");


/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        cl_mesh_tag64_t mesh_tag64;
        cl_node_tag64_t node_tag64;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;

        uint64_t reserved2;
        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_mesh_peer_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_cold_64_t) == 64, "mesh peer cold 64");

typedef struct CL_ALIGNAS(256) {
    cl_mesh_peer_hot_64_t   hot;
    cl_mesh_peer_warm_64a_t warm_a;
    cl_mesh_peer_warm_64b_t warm_b;
    cl_mesh_peer_cold_64_t  cold;
} cl_mesh_peer_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_seg_256_t) == 256, "mesh peer seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_mesh_peer_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_nic_512.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: NIC (512B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_nic_512.h
 * ============================================================================
 *
 * Record = 8 Cachelines.
 * Maximalmodell:
 * - Ports/Queues/Caps possible/effective/state
 * - DOM/SFP inventory strings (vendor/part/serial) + thresholds
 * - Loss/Jitter/Burst + reasons
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) rx_bps;
        _Atomic(uint64_t) tx_bps;

        _Atomic(uint32_t) local_seq;
        _Atomic(uint32_t) link_speed_mbps;

        _Atomic(uint16_t) mtu_effective;
        _Atomic(uint16_t) mtu_max;
        _Atomic(uint16_t) mtu_min;
        _Atomic(uint16_t) ports_count;

        _Atomic(uint32_t) queues_count;
        _Atomic(uint32_t) reason_code;

        _Atomic(uint32_t) constraint_flags;
        _Atomic(uint32_t) reserved0;
    };
    uint8_t raw[64];
} cl_nic_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_nic_hot_64_t)==64, "nic hot 64");

/* WARM A 64 (queues/drops) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) rx_queue_fill_permille;
        _Atomic(uint32_t) tx_queue_fill_permille;
        _Atomic(uint32_t) rx_dropped;
        _Atomic(uint32_t) tx_dropped;
        _Atomic(uint32_t) rx_overruns;
        _Atomic(uint32_t) tx_overruns;
        _Atomic(uint32_t) reorder_events;
        _Atomic(uint32_t) burst_max;          /* max consecutive losses (warm) */

        _Atomic(uint32_t) crc_fail_1s;        /* atoms/packets */
        _Atomic(uint32_t) crc_fail_total;

        _Atomic(uint32_t) fec_recover_1s;
        _Atomic(uint32_t) fec_recover_total;
    };
    uint8_t raw[64];
} cl_nic_warm_64a_t;

CL_STATIC_ASSERT(sizeof(cl_nic_warm_64a_t)==64, "nic warm a 64");

/* WARM B 64 (DOM/thermal) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) dom_temp_c_x10;
        _Atomic(uint32_t) dom_warn_c_x10;
        _Atomic(uint32_t) dom_crit_c_x10;
        _Atomic(uint32_t) dom_alarm_bits;

        _Atomic(uint32_t) thermal_state;        /* cl_thermal_state_t */
        _Atomic(uint32_t) pacing_scale_permille;/* 1000/950/700/0 */

        _Atomic(uint16_t) dom_state;            /* cl_feature_state_t */
        _Atomic(uint16_t) reserved0;
        _Atomic(uint32_t) reserved1;

        _Atomic(uint32_t) loss_ppm;
        _Atomic(uint32_t) jitter_p99_us;
    };
    uint8_t raw[64];
} cl_nic_warm_64b_t;

CL_STATIC_ASSERT(sizeof(cl_nic_warm_64b_t)==64, "nic warm b 64");

/* WARM C 64 (aggregation + backend/profile) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) group_id;
        _Atomic(uint32_t) active_ports_mask;

        _Atomic(uint32_t) backend_state;
        _Atomic(uint32_t) backend_active;

        _Atomic(uint32_t) profile_effective;
        _Atomic(uint32_t) constraint_flags;

        _Atomic(uint32_t) reason_code;
        _Atomic(uint32_t) reserved0;

        _Atomic(uint64_t) link_down_events;
        _Atomic(uint64_t) mtu_reneg_events;
    };
    uint8_t raw[64];
} cl_nic_warm_64c_t;

CL_STATIC_ASSERT(sizeof(cl_nic_warm_64c_t)==64, "nic warm c 64");

/* COLD A 64 (PCI identity + names) */
typedef union CL_ALIGNAS(8) {
    struct {
        uint16_t pci_vendor_id;
        uint16_t pci_device_id;
        uint16_t pci_domain;
        uint16_t reserved0;

        uint8_t pci_bus;
        uint8_t pci_dev;
        uint8_t pci_func;
        uint8_t reserved1;

        char iface_name[16];
        char driver_name[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved2;

        uint32_t reserved3;
        uint64_t reserved4;
    };
    uint8_t raw[64];
} cl_nic_cold_64a_t;

CL_STATIC_ASSERT(sizeof(cl_nic_cold_64a_t)==64, "nic cold a 64");

/* COLD B 64 (caps/state) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) caps_zerocopy;
        _Atomic(uint32_t) caps_rdma;

        _Atomic(uint16_t) bypass_state;   /* cl_feature_state_t */
        _Atomic(uint16_t) rdma_state;     /* cl_feature_state_t */
        _Atomic(uint16_t) rss_state;      /* cl_feature_state_t */
        _Atomic(uint16_t) flow_dir_state; /* cl_feature_state_t */

        _Atomic(uint32_t) backend_possible_mask; /* bitmask cl_backend_active_t */
        _Atomic(uint32_t) reserved0;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;

        uint32_t reserved2;
        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_nic_cold_64b_t;

CL_STATIC_ASSERT(sizeof(cl_nic_cold_64b_t)==64, "nic cold b 64");

/* COLD C 64 (SFP strings) */
typedef union CL_ALIGNAS(8) {
    struct {
        char sfp_vendor[16];
        char sfp_part[16];
        char sfp_serial[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;

        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_nic_cold_64c_t;

CL_STATIC_ASSERT(sizeof(cl_nic_cold_64c_t)==64, "nic cold c 64");

/* Record 512 */
typedef struct CL_ALIGNAS(512) {
    cl_nic_hot_64_t    hot;
    cl_nic_warm_64a_t  warm_a;
    cl_nic_warm_64b_t  warm_b;
    cl_nic_warm_64c_t  warm_c;
    cl_nic_cold_64a_t  cold_a;
    cl_nic_cold_64b_t  cold_b;
    cl_nic_cold_64c_t  cold_c;
    /* reserved line for future */
    uint8_t            rsv[64];
} cl_nic_seg_512_t;

CL_STATIC_ASSERT(sizeof(cl_nic_seg_512_t)==512, "nic seg 512");


<<< END FILE: ./include/cl_runtime/cl_seg_nic_512.h

>>> START FILE: ./include/cl_runtime/cl_seg_oracle_256.h
#pragma once
/* ============================================================================
 * CommanderLink – ORACLE Segment (Runtime) – FINAL v1
 * Datei: include/cl_runtime/cl_seg_oracle_256.h
 * ============================================================================
 *
 * Zweck:
 *   - Single Source of Truth für "Warum skaliert CL gerade so?" (Oracle Output)
 *   - Liefert Monitor/Daemon:
 *       * effektive Entscheidung (Backend/Compression/CRC/FEC/Worker)
 *       * Primärgrund (Reason) + Constraints
 *       * Telemetrie (Rates, Backlog, Kostenindikatoren)
 *
 * Maschinenregeln (No-UB / Physik-Regel):
 *   - Alle Felder, die während Laufzeit beschrieben und parallel gelesen werden,
 *     sind _Atomic (C11), damit es keine Data Races / UB gibt.
 *   - Writer-Publish:
 *       1) warm/hot Felder (relaxed stores)
 *       2) oracle_epoch++ als "Publish Barrier" (store-release)
 *   - Reader-Snapshot:
 *       1) e0 = oracle_epoch (load-acquire)
 *       2) Felder lesen (relaxed loads)
 *       3) e1 = oracle_epoch (load-acquire)
 *       4) nur gültig, wenn e0 == e1
 *
 * Layout:
 *   - 256B pro Record, exakt.
 *   - Hot 64B (sehr häufig), Warm 128B (häufig), Cold 64B (immutable config).
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"

/* ----------------------------------------------------------------------------
 * HOT (64B) – "Effektive Entscheidung + Primärgrund"
 * ---------------------------------------------------------------------------- */
typedef union CL_ALIGNAS(64) {
    struct {
        _Atomic uint64_t oracle_epoch;            /* monotone publish epoch */
        _Atomic uint64_t last_decision_ns;        /* monotone timestamp (ns) */

        _Atomic uint32_t scale_reason_u32;        /* cl_reason_code_t (primary) */
        _Atomic uint32_t constraint_flags_u32;    /* cl_constraint_flags_t (bitmask) */

        _Atomic uint32_t bottleneck_u32;          /* enum (NETWORK/CPU/DISK/OTHER) */
        _Atomic uint32_t worker_roles_mask_u32;   /* bitmask: RX/TX/COMP/CRC/FEC/WRITER */

        _Atomic uint16_t workers_phys_u16;        /* active physical cores */
        _Atomic uint16_t workers_ht_u16;          /* active SMT/HT threads */
        _Atomic uint16_t workers_total_u16;       /* phys + ht */

        _Atomic uint16_t isa_active_mask_u16;     /* bitmask: SSE4/AVX2/AVX512/... */
        _Atomic uint16_t backend_active_u16;      /* cl_backend_active_t */
        _Atomic uint16_t comp_level_u16;          /* compression ladder level */
        _Atomic uint16_t crc_mode_u16;            /* cl_crc_mode_t */
        _Atomic uint16_t fec_mode_u16;            /* cl_fec_mode_t */
        _Atomic uint16_t fec_n_u16;               /* N (data atoms) */
        _Atomic uint16_t fec_k_u16;               /* K (parity atoms) */

        uint8_t reserved_pad[12];                /* pad -> 64B */
    };
    uint8_t raw[64];
} cl_oracle_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_oracle_hot_64_t) == 64, "oracle hot muss 64B sein");

/* ----------------------------------------------------------------------------
 * WARM (128B) – Telemetrie & Kostenindikatoren (No-UB: alles atomic)
 * ---------------------------------------------------------------------------- */
typedef union CL_ALIGNAS(64) {
    struct {
        /* Totals (monotone counters) */
        _Atomic uint64_t rx_bytes_total;          /* payload bytes received */
        _Atomic uint64_t tx_bytes_total;          /* payload bytes sent */

        /* Rates (best-effort estimates) */
        _Atomic uint64_t rx_payload_bps;          /* app/payload throughput */
        _Atomic uint64_t tx_payload_bps;
        _Atomic uint64_t rx_wire_bps;             /* wire rate estimate */
        _Atomic uint64_t tx_wire_bps;

        /* Sink/Drain */
        _Atomic uint64_t disk_drain_bps;          /* storage drain rate estimate */

        /* Compression accounting */
        _Atomic uint64_t comp_in_bytes;           /* uncompressed bytes */
        _Atomic uint64_t comp_out_bytes;          /* compressed bytes */

        /* Cost proxy */
        _Atomic uint64_t cpu_cycles_per_byte;     /* cost indicator (oracle derived) */

        /* Ratios / backlog / modes */
        _Atomic uint32_t comp_ratio_permille;     /* e.g. 2450 => 2.45x */
        _Atomic uint32_t entropy_grade_u32;       /* oracle entropy class */
        _Atomic uint32_t rx_backlog_chunks;       /* backlog indicators */
        _Atomic uint32_t tx_backlog_chunks;

        /* Hardware states (oracle view) */
        _Atomic uint32_t thermal_state_u32;       /* cl_thermal_state_t */
        _Atomic uint32_t vrm_state_u32;           /* vendor/board normalized state */
        _Atomic uint32_t throttle_flags_u32;      /* cpu/nic throttle bits (normalized) */
        _Atomic uint32_t reserved0_u32;

        _Atomic int16_t  cpu_temp_c_x10;          /* 10x Celsius */
        _Atomic int16_t  nic_temp_c_x10;          /* 10x Celsius */
        uint8_t          reserved_pad[4];         /* align to 8 */

        _Atomic uint64_t reserved1_u64;           /* reserved for future */
    };
    uint8_t raw[128];
} cl_oracle_warm_128_t;

CL_STATIC_ASSERT(sizeof(cl_oracle_warm_128_t) == 128, "oracle warm muss 128B sein");

/* ----------------------------------------------------------------------------
 * COLD (64B) – Policy-/Konfig-Parameter (immutable after genesis)
 * ---------------------------------------------------------------------------- */
typedef union CL_ALIGNAS(64) {
    struct {
        uint32_t oracle_tick_ms;                  /* decision interval */
        uint32_t worker_max_phys;                 /* cap: physical workers */
        uint32_t worker_max_ht;                   /* cap: ht workers */

        uint32_t isa_allowed_mask_u32;            /* allowed ISA features */
        uint32_t backend_allowed_mask_u32;        /* allowed backends */
        uint32_t comp_allowed_mask_u32;           /* allowed compression modes */
        uint32_t crc_allowed_mask_u32;            /* allowed CRC modes */
        uint32_t fec_allowed_mask_u32;            /* allowed FEC modes */

        uint64_t reserved0_u64;
        uint64_t reserved1_u64;
        uint64_t reserved2_u64;
        uint64_t reserved3_u64;
    };
    uint8_t raw[64];
} cl_oracle_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_oracle_cold_64_t) == 64, "oracle cold muss 64B sein");

/* ----------------------------------------------------------------------------
 * ORACLE SEGMENT (256B)
 * ---------------------------------------------------------------------------- */
typedef union CL_ALIGNAS(64) {
    struct {
        cl_oracle_hot_64_t  hot;   /*  0.. 63 */
        cl_oracle_warm_128_t warm; /* 64..191 */
        cl_oracle_cold_64_t cold;  /* 192..255 */
    };
    uint8_t raw[256];
} cl_oracle_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_oracle_seg_256_t) == 256, "oracle seg muss 256B sein");


<<< END FILE: ./include/cl_runtime/cl_seg_oracle_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_overlay_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Overlay (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_overlay_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - Overlay ist Truth für Monitor: IP, ifname, prefix, state, routes, collision.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) overlay_state;     /* cl_feature_state_t */
        _Atomic(uint32_t) route_state;       /* cl_feature_state_t (global) */

        _Atomic(uint32_t) overlay_ip_host_u32;
        _Atomic(uint32_t) prefixlen;

        _Atomic(uint32_t) mtu_effective;
        _Atomic(uint32_t) active_routes;

        _Atomic(uint32_t) collision_offset;
        _Atomic(uint32_t) failopen_events;

        _Atomic(uint64_t) last_update_ns;
    };
    uint8_t raw[64];
} cl_overlay_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_overlay_hot_64_t) == 64, "overlay hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) routes_added_total;
        _Atomic(uint32_t) routes_removed_total;
        _Atomic(uint32_t) orphan_routes_total;
        _Atomic(uint32_t) collision_events_total;

        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
    };
    uint8_t raw[64];
} cl_overlay_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_overlay_warm_64_t) == 64, "overlay warm 64");

/* COLD 64 (if name) */
typedef union CL_ALIGNAS(8) {
    struct {
        char if_name[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;

        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_overlay_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_overlay_cold_64_t) == 64, "overlay cold 64");

typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_overlay_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_overlay_hot_64_t  hot;
    cl_overlay_warm_64_t warm;
    cl_overlay_cold_64_t cold;
    cl_overlay_rsv_64_t  rsv;
} cl_overlay_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_overlay_seg_256_t) == 256, "overlay seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_overlay_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_pcie_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: PCIe Summary (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_pcie_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - throughput + error counters
 * - vendor/device + human label (best-effort)
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) tx_bps;
        _Atomic(uint64_t) rx_bps;

        _Atomic(uint32_t) lcrc_err;
        _Atomic(uint32_t) tlp_retry;

        _Atomic(uint32_t) reason_code;
        _Atomic(uint32_t) constraint_flags;

        _Atomic(uint64_t) last_update_ns;
    };
    uint8_t raw[64];
} cl_pcie_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_pcie_hot_64_t)==64, "pcie hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) eye_margin_db_x100;
        _Atomic(uint32_t) lane_state; /* cl_feature_state_t */
        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
        _Atomic(uint64_t) reserved4;
        _Atomic(uint64_t) reserved5;
    };
    uint8_t raw[64];
} cl_pcie_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_pcie_warm_64_t)==64, "pcie warm 64");

/* COLD 64 (IDs + name) */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t vendor_id;
        uint32_t device_id;

        uint16_t domain;
        uint8_t bus;
        uint8_t dev;
        uint8_t func;
        uint8_t reserved0[3];

        char name[32]; /* best-effort short label */

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
    };
    uint8_t raw[64];
} cl_pcie_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_pcie_cold_64_t)==64, "pcie cold 64");

/* RSV 64 */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_pcie_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_pcie_hot_64_t  hot;
    cl_pcie_warm_64_t warm;
    cl_pcie_cold_64_t cold;
    cl_pcie_rsv_64_t  rsv;
} cl_pcie_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_pcie_seg_256_t)==256, "pcie seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_pcie_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_time_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Timebase (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_time_256.h
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) mono_now_ns;
        _Atomic(uint64_t) wall_now_ns;
        _Atomic(uint64_t) boot_id_ns;
        uint64_t reserved0;
        uint64_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
    };
    uint8_t raw[64];
} cl_time_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_time_hot_64_t) == 64, "time hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(int64_t)  clock_offset_ns;
        _Atomic(uint32_t) time_quality_ppb;
        uint32_t reserved0;
        uint64_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_time_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_time_warm_64_t) == 64, "time warm 64");

/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_time_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_time_cold_64_t) == 64, "time cold 64");

typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_time_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_time_hot_64_t  hot;
    cl_time_warm_64_t warm;
    cl_time_cold_64_t cold;
    cl_time_rsv_64_t  rsv;
} cl_time_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_time_seg_256_t) == 256, "time seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_time_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_watchdog_256.h
#pragma once
/*
 * ============================================================================
 * CommanderLink – WATCHDOG Segment (256B)
 * Datei: include/cl_runtime/cl_seg_watchdog_256.h
 * ============================================================================
 *
 * ZWECK
 *   - Selbstheilung: erkennt Stall/Panic und löst CL-Restart aus.
 *   - OS bleibt stabil (Fail-open): non-persistent Overlay, keine Default-Route.
 *
 * PHYSIK / ABI
 *   - Segment ist exakt 256B.
 *   - 4 Cacheline-Normflächen (64B) -> HOT_A, HOT_B, WARM, COLD.
 *   - Keine packed-Strukturen im SHM.
 *
 * OWNERSHIP
 *   - Writer: CORE aggregiert Zustände; Module schreiben nur ihre Tickmarker.
 *   - Reader: Monitor2 / Oracle.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "cl_quality.h"

/* -------------------------------------------------------------------------- */
/* Module IDs (für Stall/Restart Reason) – append-only                         */
/* -------------------------------------------------------------------------- */
typedef enum {
    CL_WD_MOD_NONE   = 0,
    CL_WD_MOD_HAL    = 1,
    CL_WD_MOD_CORE   = 2,
    CL_WD_MOD_FLOW   = 3,
    CL_WD_MOD_LINK   = 4,
    CL_WD_MOD_ORACLE = 5
} cl_wd_module_t;

/* -------------------------------------------------------------------------- */
/* Watchdog State                                                             */
/* -------------------------------------------------------------------------- */
typedef enum {
    CL_WD_OK    = 0,
    CL_WD_WARN  = 1,
    CL_WD_STALL = 2,
    CL_WD_PANIC = 3
} cl_wd_state_t;

/* -------------------------------------------------------------------------- */
/* Watchdog Reason Codes (append-only)                                        */
/* -------------------------------------------------------------------------- */
typedef enum {
    CL_WD_R_NONE = 0,

    /* Zeitbasierter Stall */
    CL_WD_R_STALL_HAL,
    CL_WD_R_STALL_CORE,
    CL_WD_R_STALL_FLOW,
    CL_WD_R_STALL_LINK,
    CL_WD_R_STALL_ORACLE,

    /* Integritäts-/Konsistenzverletzung (harte Gründe) */
    CL_WD_R_EPOCH_REGRESSION,
    CL_WD_R_GRANT_REPLAY,
    CL_WD_R_CREDITS_NEGATIVE,
    CL_WD_R_BACKEND_PANIC,
    CL_WD_R_INVARIANT_BREACH
} cl_wd_reason_t;

/* ============================================================================
 * HOT_A 64B: Liveness Marker (letztes Lebenszeichen je Modul)
 * ============================================================================
 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) hal_tick_ns;
        _Atomic(uint64_t) core_tick_ns;
        _Atomic(uint64_t) flow_tick_ns;
        _Atomic(uint64_t) link_tick_ns;
        _Atomic(uint64_t) oracle_tick_ns;

        uint8_t  src;
        uint8_t  qual;
        uint16_t reserved0;
        uint32_t reserved1;
    };
    uint8_t raw[64];
} cl_wd_hot_64a_t;

CL_STATIC_ASSERT(sizeof(cl_wd_hot_64a_t) == 64, "watchdog hot_a 64");

/* ============================================================================
 * HOT_B 64B: Progress Marker (Fortschritt, nicht nur Liveness)
 * ============================================================================
 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_progress_ns;      /* monotonic ns */
        _Atomic(uint64_t) last_commit_epoch;     /* Link commit epoch */
        _Atomic(uint64_t) last_root_seq_cnt;     /* Root seq snapshot */

        _Atomic(uint32_t) wd_state;              /* cl_wd_state_t */
        _Atomic(uint32_t) wd_reason;             /* cl_wd_reason_t */

        _Atomic(uint32_t) restart_count_total;   /* seit Boot */
        _Atomic(uint32_t) last_stall_module;     /* cl_wd_module_t */

        uint8_t  src;
        uint8_t  qual;
        uint16_t reserved0;
        uint32_t reserved1;
    };
    uint8_t raw[64];
} cl_wd_hot_64b_t;

CL_STATIC_ASSERT(sizeof(cl_wd_hot_64b_t) == 64, "watchdog hot_b 64");

/* ============================================================================
 * WARM 64B: Restart Summary (persistente Liste kommt über Log + Forensics)
 * ============================================================================
 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_restart_ns;
        _Atomic(uint32_t) last_restart_reason;     /* cl_wd_reason_t */
        _Atomic(uint32_t) last_restart_module;     /* cl_wd_module_t */

        _Atomic(uint64_t) last_restart_commit_epoch;

        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;

        uint8_t  src;
        uint8_t  qual;
        uint16_t reserved2;
        uint32_t reserved3;
    };
    uint8_t raw[64];
} cl_wd_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_wd_warm_64_t) == 64, "watchdog warm 64");

/* ============================================================================
 * COLD 64B: Policy/Thresholds (sichtbar, konservativ)
 * ============================================================================
 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t stall_ns_threshold;   /* z.B. 2_000_000_000 (2s) */
        uint32_t warn_ns_threshold;    /* z.B. 250_000_000 (250ms) */

        uint32_t max_restart_per_min;  /* Rate limit */
        uint32_t cooldown_s;           /* Sperrzeit nach Restart */

        uint32_t log_enabled;          /* 1=watchdog log schreiben */
        uint32_t reserved0;

        uint8_t  src;
        uint8_t  qual;
        uint16_t reserved1;
        uint32_t reserved2;

        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_wd_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_wd_cold_64_t) == 64, "watchdog cold 64");

/* ============================================================================
 * Segment 256B
 * ============================================================================
 */
typedef struct CL_ALIGNAS(256) {
    cl_wd_hot_64a_t hot_a;
    cl_wd_hot_64b_t hot_b;
    cl_wd_warm_64_t warm;
    cl_wd_cold_64_t cold;
} cl_watchdog_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_watchdog_seg_256_t) == 256, "watchdog seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_watchdog_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_zfs_4096.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: ZFS Meta (4096B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_zfs_4096.h
 * ============================================================================
 *
 * Zweck:
 *   - ZFS Presence/Health + ARC Summary + Bulk-Offsets zu Pools/VDEVs/Datasets.
 *
 * Maximalmodell:
 *   - Wenn ZFS nicht verfügbar: zfs_present=0, state=UNSUPPORTED/UNKNOWN.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

#define CL_ZFS_H_OK        (1u << 0)
#define CL_ZFS_H_DEGRADED  (1u << 1)
#define CL_ZFS_H_FAULTED   (1u << 2)
#define CL_ZFS_H_SCRUBBING (1u << 3)

/* Header 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) zfs_present;
        _Atomic(uint32_t) zfs_health_bits;

        _Atomic(uint16_t) zfs_state;           /* cl_feature_state_t */
        _Atomic(uint16_t) snapshots_enabled;   /* 0/1 */
        _Atomic(uint32_t) reserved0;

        _Atomic(uint32_t) pools_count;
        _Atomic(uint32_t) vdevs_count;

        _Atomic(uint32_t) datasets_count;
        _Atomic(uint32_t) zvols_count;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
        uint32_t reserved2;

        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_zfs_hdr_64_t;

CL_STATIC_ASSERT(sizeof(cl_zfs_hdr_64_t)==64, "zfs hdr 64");

/* ARC 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) arc_size;
        _Atomic(uint64_t) arc_max;
        _Atomic(uint64_t) arc_hits;
        _Atomic(uint64_t) arc_misses;
        _Atomic(uint64_t) l2_size;
        _Atomic(uint64_t) l2_hits;
        _Atomic(uint64_t) l2_misses;
        _Atomic(uint64_t) reserved0;
    };
    uint8_t raw[64];
} cl_zfs_arc_64_t;

CL_STATIC_ASSERT(sizeof(cl_zfs_arc_64_t)==64, "zfs arc 64");

/* Bulk offsets 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) off_pools;
        _Atomic(uint64_t) off_vdevs;
        _Atomic(uint64_t) off_datasets;
        _Atomic(uint64_t) off_zvols;

        _Atomic(uint64_t) size_pools_bytes;
        _Atomic(uint64_t) size_vdevs_bytes;
        _Atomic(uint64_t) size_datasets_bytes;
        _Atomic(uint64_t) size_zvols_bytes;
    };
    uint8_t raw[64];
} cl_zfs_bulk_64_t;

CL_STATIC_ASSERT(sizeof(cl_zfs_bulk_64_t)==64, "zfs bulk 64");

typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_zfs_rsv_64_t;

typedef struct CL_ALIGNAS(4096) {
    cl_zfs_hdr_64_t  hdr;
    cl_zfs_arc_64_t  arc;
    cl_zfs_bulk_64_t bulk;
    cl_zfs_rsv_64_t  rsv[61];
} cl_zfs_seg_4096_t;

CL_STATIC_ASSERT(sizeof(cl_zfs_seg_4096_t)==4096, "zfs seg 4096");


<<< END FILE: ./include/cl_runtime/cl_seg_zfs_4096.h

>>> START FILE: ./include/cl_runtime/cl_service_seg_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Service-State (256B) – FINAL
 * Datei: include/cl_runtime/cl_service_seg_256.h
 * ============================================================================
 *
 * Zweck:
 *   SSOT für Boot-/Supervisor-Zustand.
 *   ZERO-konform: keine Telemetrie, keine Policy – nur Prozessstatus.
 *
 * Writer:
 *   - clboot / später cld: expected/running/pid/crash/exit/signal
 *   - jeder Prozess (core0/hal0/link0/flow0/oracle0): heartbeat_ns
 *
 * Layout:
 *   256B = 4 Cachelines à 64B
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"

/* Service IDs (Slot-Index; SSOT) */
typedef enum cl_service_id {
    CL_SVC_CORE0   = 0,
    CL_SVC_HAL0    = 1,
    CL_SVC_LINK0   = 2,
    CL_SVC_FLOW0   = 3,
    CL_SVC_ORACLE0 = 4,
    CL_SVC_MONITOR = 5, /* optional */
    CL_SVC_MAX     = 6
} cl_service_id_t;

/* 32B Slot: bewusst klein, deterministisch */
typedef struct CL_ALIGNAS(8) cl_service_slot_32 {
    _Atomic(uint32_t) expected;          /* 0/1 */
    _Atomic(uint32_t) running;           /* 0/1 */
    _Atomic(uint32_t) pid;               /* Prozess-ID */
    _Atomic(uint32_t) crash_count;       /* Restart-Zähler */

    _Atomic(uint64_t) last_heartbeat_ns; /* Prozess schreibt (MONOTONIC ns) */

    _Atomic(int32_t)  last_exit_code;    /* Supervisor schreibt */
    _Atomic(int32_t)  last_signal;       /* Supervisor schreibt */
} cl_service_slot_32_t;

CL_STATIC_ASSERT(sizeof(cl_service_slot_32_t) == 32, "service slot muss 32B sein");

/* CL0: Globaler Boot/Redirect-Status */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) boot_epoch;         /* bump je clboot/cld start */
        _Atomic(uint64_t) boot_id_ns;         /* monotone boot id */

        _Atomic(uint32_t) desired_redirect;   /* clboot/clctl Wunsch */
        _Atomic(uint32_t) effective_redirect; /* LINK setzt effektiv */

        _Atomic(uint32_t) last_error_code;    /* supervisor error */
        _Atomic(uint32_t) service_count;      /* = CL_SVC_MAX */

        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
    };
    uint8_t raw[64];
} cl_service_global_64_t;

CL_STATIC_ASSERT(sizeof(cl_service_global_64_t) == 64, "service global muss 64B sein");

/* CL1: Slots 0–1 */
typedef union CL_ALIGNAS(8) {
    struct { cl_service_slot_32_t s0; cl_service_slot_32_t s1; };
    uint8_t raw[64];
} cl_service_slots01_64_t;

CL_STATIC_ASSERT(sizeof(cl_service_slots01_64_t) == 64, "service slots01 muss 64B sein");

/* CL2: Slots 2–3 */
typedef union CL_ALIGNAS(8) {
    struct { cl_service_slot_32_t s2; cl_service_slot_32_t s3; };
    uint8_t raw[64];
} cl_service_slots23_64_t;

CL_STATIC_ASSERT(sizeof(cl_service_slots23_64_t) == 64, "service slots23 muss 64B sein");

/* CL3: Slots 4–5 */
typedef union CL_ALIGNAS(8) {
    struct { cl_service_slot_32_t s4; cl_service_slot_32_t s5; };
    uint8_t raw[64];
} cl_service_slots45_64_t;

CL_STATIC_ASSERT(sizeof(cl_service_slots45_64_t) == 64, "service slots45 muss 64B sein");

/* Segment 256B */
typedef struct CL_ALIGNAS(256) cl_service_seg_256 {
    cl_service_global_64_t  g0;
    cl_service_slots01_64_t g1;
    cl_service_slots23_64_t g2;
    cl_service_slots45_64_t g3;
} cl_service_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_service_seg_256_t) == 256, "service seg muss 256B sein");


<<< END FILE: ./include/cl_runtime/cl_service_seg_256.h

>>> START FILE: ./include/cl_runtime/cl_shm_layout.h
#pragma once
/* ============================================================================
 * CommanderLink – Core SHM Root Layout (Runtime) – FINAL
 * Datei: include/cl_runtime/cl_shm_layout.h
 * ============================================================================
 *
 * Ziel:
 *   Root ist die Notfall-Wahrheit: minimal, deterministisch, 4096B.
 *
 * Maschinenregel:
 *   - raw[4096] Normfläche.
 *   - Host-Order.
 *   - 64-bit-first Feldreihenfolge.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_ids.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_schema.h"

#define CL_CORE_SHM_NAME   "/cl_core_root"
#define CL_BULK_SHM_NAME   "/cl_bulk"

#define CL_ROOT_MAGIC_U32          0x54524C43u /* "CLRT" in Host-Order */
#define CL_ROOT_FLAG_FAILFAST_ABI  (1u << 0)


typedef union CL_ALIGNAS(CL_SHM_PAGE_BYTES) {
    struct {
        /* 64-bit first */
        uint64_t abi_layout_checksum;

        _Atomic(uint64_t) seq_cnt;
        _Atomic(uint64_t) uptime_ns;
        _Atomic(uint64_t) bulk_epoch;

        uint64_t boot_id_ns;
        cl_mesh_tag64_t mesh_tag64;
        cl_node_tag64_t node_tag64;

        uint64_t toc_offset;
        uint64_t toc_size;

		/* 32-bit */
        uint32_t root_magic;      /* CL_ROOT_MAGIC_U32 */
        uint32_t root_flags;      /* CL_ROOT_FLAG_*    */

        uint32_t schema_version;
        uint32_t endian_magic;

        _Atomic(uint32_t) global_health;
        _Atomic(uint32_t) budget_state;

        _Atomic(uint32_t) path_state;
        _Atomic(uint32_t) backend_active;
        _Atomic(uint32_t) mode_active;
        _Atomic(uint32_t) profile_active;

        _Atomic(uint32_t) rx_gate;
        _Atomic(uint32_t) tx_gate;

        _Atomic(uint32_t) constraint_flags;
        _Atomic(uint32_t) reason_code;

        _Atomic(uint32_t) bulk_present;

        uint32_t overlay_ip_host_u32;
        uint32_t overlay_failopen_events;
        uint16_t overlay_routes;
        uint16_t mtu_effective;

        /* 8-bit */
        _Atomic(uint8_t) active_index;
        uint8_t overlay_prefixlen;
        uint8_t overlay_enabled;
        uint8_t reserved_u8;

        /* Trust quick view */
        _Atomic(uint32_t) trust_policy_required;
        _Atomic(uint32_t) trusted_peer_count;
    };
    uint8_t raw[CL_SHM_PAGE_BYTES];
} cl_root_4096_t;

CL_STATIC_ASSERT(sizeof(cl_root_4096_t) == CL_SHM_PAGE_BYTES, "root must be 4096B");

/* Back-compat */
typedef cl_root_4096_t cl_root_t;


<<< END FILE: ./include/cl_runtime/cl_shm_layout.h

>>> START FILE: ./include/cl_runtime/cl_toc.h
#pragma once
/* ============================================================================
 * CommanderLink – Runtime TOC (Table of Contents) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_toc.h
 * ============================================================================
 *
 * Vertrag:
 *   - TOC ist die physikalische Verkabelung der Runtime-SHM.
 *   - TOC ist rein beschreibend (keine Policy, keine Logik).
 *
 * Layout:
 *   - cl_toc_header_t: exakt 64B (1 Cacheline)
 *   - cl_toc_entry_t : exakt 64B (1 Cacheline)
 *   - cl_toc_t       : Header + entries[CL_TOC_MAX_ENTRIES]
 *
 * Semantik:
 *   - Segment-ID: CL_<NAME>_SEG_<stride>
 *   - Segmentgröße steht im TOC (stride_bytes), nicht im Segment-ID-Namen.
 *     (Der Name trägt den stride nur als symbolische Eindeutigkeit.)
 * ============================================================================
 */

#include <stdint.h>

#include "cl_gates.h"

/* --------------------------------------------------------------------------
 * Architekturannahme
 * -------------------------------------------------------------------------- */
#if !defined(__x86_64__) && !defined(_M_X64)
#error "CommanderLink TOC ist x86_64-first"
#endif

/* --------------------------------------------------------------------------
 * TOC Version / Limits
 * -------------------------------------------------------------------------- */
#define CL_TOC_VERSION      1u
#define CL_TOC_MAX_ENTRIES  128u

/* --------------------------------------------------------------------------
 * Segment-IDs (SSOT für TOC type)
 *
 * Hinweis:
 *   Diese IDs sind für TOC/Tools/Monitor.
 *   Die semantische Rolle bleibt wichtiger als die Zahl selbst.
 * -------------------------------------------------------------------------- */
typedef enum cl_seg_type {

    /* 256 */
    CL_LINK_SEG_256            = 0x0100,
    CL_BUDGET_SEG_256          = 0x0101,
    CL_MEM_SEG_256             = 0x0102,
    CL_OVERLAY_SEG_256         = 0x0103,
    CL_WATCHDOG_SEG_256        = 0x0104,
    CL_PCIE_SEG_256            = 0x0105,
    CL_TIME_SEG_256            = 0x0106,
    CL_MESH_NEIGHBOR_SEG_256   = 0x0107,
    CL_MESH_PEER_SEG_256       = 0x0108,
    CL_ORACLE_SEG_256          = 0x0109,
    CL_SERVICE_SEG_256         = 0x010A,

    /* 512 */
    CL_NIC_SEG_512             = 0x0200,
    CL_BOARD_SEG_512           = 0x0201,

    /* 1024 */
    CL_CPU_SEG_1024            = 0x0300,

    /* 4096 */
    CL_DMA_SEG_4096            = 0x0400,
    CL_HISTORY_SEG_4096        = 0x0401,
    CL_FORENSICS_SEG_4096      = 0x0402,
    CL_ZFS_SEG_4096            = 0x0403
} cl_seg_type_t;

/* --------------------------------------------------------------------------
 * TOC Flags (physikalische Eigenschaften, keine Policy)
 * -------------------------------------------------------------------------- */
typedef uint32_t cl_toc_flags_t;

/* Speicherklasse */
#define CL_TOC_FLAG_RESIDENT        (1u << 0)  /* Core-SHM                         */
#define CL_TOC_FLAG_RECLAIMABLE     (1u << 1)  /* Bulk-SHM                         */

/* Bedeutung */
#define CL_TOC_FLAG_CRITICAL        (1u << 2)
#define CL_TOC_FLAG_OBSERVABLE      (1u << 3)

/* Änderungsfrequenz */
#define CL_TOC_FLAG_HOT             (1u << 4)
#define CL_TOC_FLAG_WARM            (1u << 5)
#define CL_TOC_FLAG_COLD            (1u << 6)

/* Instanzierung */
#define CL_TOC_FLAG_FIXED_COUNT     (1u << 7)
#define CL_TOC_FLAG_VARIABLE_COUNT  (1u << 8)

/* Rolle */
#define CL_TOC_FLAG_DATA            (1u << 9)
#define CL_TOC_FLAG_CONTROL         (1u << 10)
#define CL_TOC_FLAG_FORENSICS       (1u << 11)

/* --------------------------------------------------------------------------
 * Source/Access/Presence/Layout
 * -------------------------------------------------------------------------- */
typedef uint16_t cl_toc_source_t;
#define CL_TOC_SOURCE_DIRECT        (1u << 0)
#define CL_TOC_SOURCE_BEST_EFFORT   (1u << 1)
#define CL_TOC_SOURCE_ESTIMATED     (1u << 2)
#define CL_TOC_SOURCE_UNSUPPORTED   (1u << 3)

typedef uint16_t cl_toc_access_t;
#define CL_TOC_ACCESS_READ          (1u << 0)
#define CL_TOC_ACCESS_WRITE         (1u << 1)
#define CL_TOC_ACCESS_ATOMIC        (1u << 2)

typedef uint16_t cl_toc_presence_t;
#define CL_TOC_PRESENT              (1u << 0)
#define CL_TOC_RECLAIMED            (1u << 1)
#define CL_TOC_PARTIAL              (1u << 2)

typedef uint16_t cl_toc_layout_t;
#define CL_TOC_LAYOUT_CACHELINE     (1u << 0)
#define CL_TOC_LAYOUT_ARRAY         (1u << 1)

/* --------------------------------------------------------------------------
 * TOC Entry – exakt 64B
 * -------------------------------------------------------------------------- */
typedef struct cl_toc_entry {

    uint16_t       type;           /* cl_seg_type_t */
    uint16_t       version;        /* Segment-spezifische Version */
    uint32_t       flags;          /* cl_toc_flags_t */

    uint32_t       stride_bytes;   /* 256/512/1024/4096 */
    uint32_t       count;          /* Instanzen */

    uint64_t       offset_bytes;   /* Offset relativ zum jeweiligen SHM-Beginn */

    uint16_t       source_flags;   /* cl_toc_source_t  */
    uint16_t       access_flags;   /* cl_toc_access_t  */
    uint16_t       presence_flags; /* cl_toc_presence_t */
    uint16_t       layout_flags;   /* cl_toc_layout_t */

    cl_gate_mask_t gates_possible;
    cl_gate_mask_t gates_effective;

    uint64_t       epoch;

    uint64_t       reserved0;      /* macht 64B exakt */

} cl_toc_entry_t;

_Static_assert(sizeof(cl_toc_entry_t) == 64, "cl_toc_entry_t muss exakt 64B sein");

/* --------------------------------------------------------------------------
 * TOC Header – exakt 64B
 * -------------------------------------------------------------------------- */
typedef struct cl_toc_header {

    uint32_t version;        /* CL_TOC_VERSION */
    uint32_t entry_count;    /* Anzahl gültiger Entries */

    uint64_t total_bytes;    /* Core oder Core+Bulk (konkret, nicht geraten) */
    uint64_t build_id;       /* ABI-/Build-Fingerprint */
    uint64_t epoch;          /* TOC epoch */

    uint64_t reserved[4];    /* macht 64B exakt */

} cl_toc_header_t;

_Static_assert(sizeof(cl_toc_header_t) == 64, "cl_toc_header_t muss exakt 64B sein");

/* --------------------------------------------------------------------------
 * Gesamter TOC
 * -------------------------------------------------------------------------- */
typedef struct cl_toc {

    cl_toc_header_t header;
    cl_toc_entry_t  entries[CL_TOC_MAX_ENTRIES];

} cl_toc_t;


<<< END FILE: ./include/cl_runtime/cl_toc.h

>>> START FILE: ./Makefile
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI, read-only; run with sudo in dev)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncursesw
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncursesw
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  LIBCURSES := -lcurses
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

MONITOR_SRC := src/monitor/monitor.c \
               src/monitor/monitor_ui.c \
               src/monitor/monitor_state.c \
               src/monitor/monitor_input.c \
               src/monitor/monitor_shm.c \
               src/monitor/tabs/tab_dashboard.c
               
# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/clmonitor

# ---------------------------------------------------------------------------
# Monitor link libs (OS-spezifisch, override möglich)
# ---------------------------------------------------------------------------
MONITOR_LDLIBS ?=
ifeq ($(OS),linux)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS ?= -lcurses
endif

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs
	
# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor (SSOT UI)
# ---------------------------------------------------------------------------
$(BUILD_DIR)/src/%.o: src/%.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(CFLAGS) -o $@ $(MONITOR_OBJ) $(LIBCURSES) $(MONITOR_LDLIBS) $(LDFLAGS)
	
monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service boot path): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor with sudo: $(MONITOR_BIN)"
	@sudo $(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S    = $(UNAME_S)"
	@echo "  OS         = $(OS)"
	@echo "  CC         = $(CC)"
	@echo "  CFLAGS     = $(CFLAGS)"
	@echo "  BIN_DIR    = $(BIN_DIR)"
	@echo "  BUILD_DIR  = $(BUILD_DIR)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)" -lncursesw

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0"
	@echo "  make monitor    Build cl_monitor"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-cld      Boot via cld (destroy->init->clboot)"
	@echo "  make run-monitor  Run monitor via sudo"
	@echo ""
	@echo "Monitor libs:"
	@echo "  Override with: gmake MONITOR_LDLIBS=-lncursesw monitor"


<<< END FILE: ./Makefile

>>> START FILE: ./README.md
commanderlink/
├── include/
│   ├── cl_manifest/
│   │   ├── cl_limits.h
│   │   ├── cl_ids.h
│   │   ├── cl_features.h
│   │   ├── cl_link_modes.h
│   │   ├── cl_wire.h
│   │   ├── cl_oob.h
│   │   └── cl_manifest.h
│   ├── cl_common/
│   │   ├── cl_atomic.h
│   │   ├── cl_endian.h
│   │   ├── cl_crc8.h
│   │   ├── cl_time.h
│   │   └── cl_tags.h
│   ├── cl_runtime/
│   │   ├── cl_toc.h
│   │   ├── cl_global.h
│   │   ├── cl_quality.h
│   │   ├── cl_segments_cpu.h
│   │   ├── cl_segments_nic.h
│   │   ├── cl_segments_mem.h
│   │   ├── cl_segments_pcie.h
│   │   ├── cl_segments_board.h
│   │   ├── cl_segments_time.h
│   │   ├── cl_segments_link.h
│   │   ├── cl_segments_budget.h
│   │   ├── cl_segments_mesh.h
│   │   ├── cl_segments_dma.h
│   │   └── cl_segments_zfs.h
│   ├── cl_hal/
│   │   └── cl_hal.h
│   ├── cl_core/
│   │   └── cl_core.h
│   ├── cl_flow/
│   │   └── cl_flow.h
│   ├── cl_link/
│   │   └── cl_link.h
│   ├── cl_oracle/
│   │   └── cl_oracle.h
│   └── cl_monitor/
│       └── cl_monitor.h
├── src/ (leer oder später)
└── tools/ (leer oder später)

src/monitor/
├── monitor_main.c          # main loop, init ncurses, dispatch tabs
├── monitor_state.c         # UI state (active tab, focus, selection, filter)
├── monitor_state.h
├── monitor_shm.c           # attach core/bulk shm, map pointers, bulk present
├── monitor_shm.h
├── monitor_toc.c           # helpers: find segment by type, compute record ptrs
├── monitor_toc.h
├── monitor_draw.c          # box/lines/colors/helpers, autoscaling layout grid
├── monitor_draw.h
├── monitor_keymap.c        # key handling (F1..F12, arrows, /, s, tab, h)
├── monitor_keymap.h
├── monitor_fmt.c           # formatting helpers (bps, ppm, us, ids short, Q|S)
├── monitor_fmt.h
├── tabs/
│   ├── tab_dashboard.c     # F1
│   ├── tab_inventory.c     # F2
│   ├── tab_cpu.c           # F3
│   ├── tab_memory.c        # F4
│   ├── tab_nic.c           # F5
│   ├── tab_mesh.c          # F6
│   ├── tab_dma.c           # F7
│   ├── tab_zfs.c           # F8
│   ├── tab_pcie.c          # F9
│   ├── tab_gpu.c           # F10
│   ├── tab_oracle.c        # F11
│   └── tab_audit.c         # F12
└── tabs/tab_common.h       # shared tab helpers

Erweiterung: 

commanderlink/
├─ src/
│  ├─ core/                     ← ZENTRALE SYSTEMWAHRHEIT
│  │  ├─ cl_gates.h              ← HIER!
│  │  ├─ cl_segment_types.h
│  │  ├─ cl_toc.h
│  │  ├─ cl_budget.h
│  │  └─ cl_timebase.h
│  │
│  ├─ seg/                      ← RUNTIME-SEGMENTE (SHM)
│  │  ├─ seg_cpu_1024.h
│  │  ├─ seg_memory_256.h
│  │  ├─ seg_nic_512.h
│  │  ├─ seg_pcie_256.h
│  │  ├─ seg_budget_256.h
│  │  ├─ seg_overlay_256.h
│  │  ├─ seg_watchdog_256.h
│  │  ├─ seg_mesh_neighbor_256.h
│  │  └─ seg_dma_4096.h
│  │
│  ├─ wire/                     ← DRAHTREALITÄT
│  │  ├─ cl_wire_common.h
│  │  ├─ cl_wire_clwp.h
│  │  ├─ cl_wire_oob.h
│  │  ├─ cl_wire_modes.h
│  │  └─ cl_wire_limits.h
│  │
│  ├─ runtime/                  ← AKTIVE LOGIK (später)
│  │  ├─ flow/
│  │  ├─ link/
│  │  └─ hal/
│  │
│  ├─ monitor/                  ← PASSIVER LESER
│  ├─ tools/
│  └─ tests/
│
├─ docs/
│  ├─ laws/
│  └─ contracts/
│
└─ Makefile


<<< END FILE: ./README.md

>>> START FILE: ./src/clboot/clboot.c
/*
 * ============================================================================
 * CommanderLink – clboot (Orchestrator/Supervisor) – FINAL Endausbau
 * Datei: src/clboot/clclboot.c
 * ============================================================================
 *
 * Zweck:
 *   - Bootet das CommanderLink-System wie ein Systemdienst:
 *       1) sicherstellen: SHM existiert (clinit)
 *       2) Services starten: core0 -> hal0 -> link0 -> flow0 -> oracle0
 *       3) Supervisor: Heartbeats prüfen, Self-Healing (Restart + Backoff)
 *
 * ZERO-LAW:
 *   - clboot setzt keine Telemetrie und keine Transport-Policy.
 *   - clboot schreibt nur Service-State (SSOT für Boot/Supervision).
 *
 * CPU/Caps:
 *   - clboot liest CPU-count + ISA (SSE4.2/AVX2/AVX-512 best-effort)
 *   - erstellt einen initialen Runplan (Pinning-Sets), deterministisch.
 *   - dynamische Aggressivität bleibt CORE/FLOW/LINK.
 *
 * Hinweis:
 *   - Redirect wird NICHT von clboot "hart" aktiviert.
 *   - clboot setzt nur desired_redirect (optional).
 *   - effective_redirect setzt LINK, gated durch Trust+Dataplane Ready.
 * ============================================================================
 */

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <stddef.h>
#include <stdalign.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <time.h>
#include <signal.h>

#if defined(__FreeBSD__)
#include <sys/param.h>
#include <sys/cpuset.h>
#include <sys/types.h>
#include <sys/sysctl.h>
#endif

#if defined(__linux__)
#include <sched.h>
#endif

#include "cl_runtime/cl_runtime.h"
#include "cl_runtime/cl_service_seg_256.h"

/* ---------------- Zeit ---------------- */
static uint64_t now_ns(void) {
    struct timespec ts;
#if defined(CLOCK_MONOTONIC)
    clock_gettime(CLOCK_MONOTONIC, &ts);
#else
    clock_gettime(CLOCK_REALTIME, &ts);
#endif
    return (uint64_t)ts.tv_sec * 1000000000ull + (uint64_t)ts.tv_nsec;
}

/* ---------------- OS tag (bin/<os>/) ---------------- */
static const char* detect_os_tag(void) {
#if defined(__FreeBSD__)
    return "bsd";
#elif defined(__linux__)
    return "linux";
#elif defined(__sun)
    return "omnios";
#else
    return "unknown";
#endif
}

/* ---------------- CPUID (x86_64) ---------------- */
#if defined(__x86_64__) || defined(_M_X64)
static void cpuid(uint32_t leaf, uint32_t subleaf,
                  uint32_t *eax, uint32_t *ebx, uint32_t *ecx, uint32_t *edx)
{
#if defined(__clang__) || defined(__GNUC__)
    uint32_t a, b, c, d;
    __asm__ volatile("cpuid"
                     : "=a"(a), "=b"(b), "=c"(c), "=d"(d)
                     : "a"(leaf), "c"(subleaf));
    *eax = a; *ebx = b; *ecx = c; *edx = d;
#else
    *eax = *ebx = *ecx = *edx = 0;
#endif
}

static uint64_t xgetbv0(void) {
#if defined(__clang__) || defined(__GNUC__)
    uint32_t eax, edx;
    __asm__ volatile(".byte 0x0f, 0x01, 0xd0" : "=a"(eax), "=d"(edx) : "c"(0));
    return ((uint64_t)edx << 32) | eax;
#else
    return 0;
#endif
}
#endif

typedef struct cl_boot_caps {
    uint32_t cpu_online;
    uint8_t  has_sse42;
    uint8_t  has_avx2;
    uint8_t  has_avx512;
} cl_boot_caps_t;

static cl_boot_caps_t read_host_caps(void) {
    cl_boot_caps_t c;
    memset(&c, 0, sizeof(c));

#if defined(__FreeBSD__)
    int ncpu = 1;
    size_t len = sizeof(ncpu);
    if (sysctlbyname("hw.ncpu", &ncpu, &len, NULL, 0) == 0 && ncpu > 0) {
        c.cpu_online = (uint32_t)ncpu;
    } else {
        c.cpu_online = 1u;
    }
#else
    long n = sysconf(_SC_NPROCESSORS_ONLN);
    c.cpu_online = (n > 0) ? (uint32_t)n : 1u;
#endif

#if defined(__x86_64__) || defined(_M_X64)
    uint32_t a,b,cc,d;

    /* SSE4.2: CPUID.01H:ECX.SSE4_2[20] */
    cpuid(1, 0, &a, &b, &cc, &d);
    c.has_sse42 = (uint8_t)((cc >> 20) & 1u);

    /* AVX2: CPUID.07H:EBX.AVX2[5] + OSXSAVE/XCR0 */
    uint8_t osxsave = (uint8_t)((cc >> 27) & 1u);
    uint8_t avx = (uint8_t)((cc >> 28) & 1u);

    cpuid(7, 0, &a, &b, &cc, &d);
    uint8_t avx2 = (uint8_t)((b >> 5) & 1u);

    uint64_t xcr0 = osxsave ? xgetbv0() : 0;
    uint8_t xmm_ymm_enabled = (uint8_t)(((xcr0 & 0x6u) == 0x6u) ? 1u : 0u);

    c.has_avx2 = (uint8_t)(avx && avx2 && xmm_ymm_enabled);

    /* AVX-512: CPUID.07H:EBX.AVX512F[16] + XCR0 (ZMM state) */
    uint8_t avx512f = (uint8_t)((b >> 16) & 1u);
    uint8_t zmm_enabled = (uint8_t)(((xcr0 & 0xE6u) == 0xE6u) ? 1u : 0u);

    c.has_avx512 = (uint8_t)(avx512f && zmm_enabled);
#endif

    return c;
}

/* ---------------- SHM attach (core RW) ---------------- */
static int map_shm_rw(const char *name, void **out_base, size_t *out_sz) {
    int fd = shm_open(name, O_RDWR, 0);
    if (fd < 0) return -1;

    struct stat st;
    if (fstat(fd, &st) != 0) { close(fd); return -2; }
    if (st.st_size <= 0) { close(fd); return -3; }

    void *p = mmap(NULL, (size_t)st.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    close(fd);
    if (p == MAP_FAILED) return -4;

    *out_base = p;
    *out_sz = (size_t)st.st_size;
    return 0;
}

static void unmap_shm(void *base, size_t sz) {
    if (base && sz) (void)munmap(base, sz);
}

/* ---------------- TOC lookup: service seg ---------------- */
static int find_service_seg(const cl_root_t *root, const cl_toc_t *toc, uint64_t *out_off) {
    (void)root;

    for (uint32_t i = 0; i < toc->header.entry_count && i < CL_TOC_MAX_ENTRIES; i++) {
        const cl_toc_entry_t *e = &toc->entries[i];
        if ((uint16_t)e->type == (uint16_t)CL_SERVICE_SEG_256) {
            if (e->stride_bytes != 256u || e->count != 1u) return -2;
            *out_off = (uint64_t)e->offset_bytes;
            return 0;
        }
    }
    return -1;
}

/* ---------------- Pinning (initial, deterministisch) ---------------- */
static void pin_self_to_cpu0(void) {
#if defined(__linux__)
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    (void)sched_setaffinity(0, sizeof(set), &set);
#elif defined(__FreeBSD__)
    cpuset_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    (void)cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(set), &set);
#endif
}

/* ---------------- Spawn helper ---------------- */
typedef struct cl_proc {
    const char *name;
    cl_service_id_t sid;
    pid_t pid;
    uint64_t next_restart_ns;
    uint32_t backoff_pow; /* 0.. */
} cl_proc_t;

static pid_t spawn_process(const char *path, const char *name) {
    pid_t pid = fork();
    if (pid < 0) return -1;
    if (pid == 0) {
        /* Child: exec */
        execl(path, name, (char*)NULL);
        _exit(127);
    }
    return pid;
}

/* ---------------- Service slot access ---------------- */
static cl_service_slot_32_t* svc_slot(cl_service_seg_256_t *s, cl_service_id_t id) {
    switch (id) {
        case CL_SVC_CORE0:   return &s->g1.s0;
        case CL_SVC_HAL0:    return &s->g1.s1;
        case CL_SVC_LINK0:   return &s->g2.s2;
        case CL_SVC_FLOW0:   return &s->g2.s3;
        case CL_SVC_ORACLE0: return &s->g3.s4;
        case CL_SVC_MONITOR: return &s->g3.s5;
        default: return NULL;
    }
}

/* ---------------- Self-healing policy (deterministisch) ---------------- */
static uint64_t backoff_ns(uint32_t pow) {
    /* 0->0s, 1->1s, 2->2s, 3->4s, ... cap 10s */
    uint64_t s = 0;
    if (pow == 0) s = 0;
    else if (pow == 1) s = 1000000000ull;
    else if (pow == 2) s = 2000000000ull;
    else if (pow == 3) s = 4000000000ull;
    else if (pow == 4) s = 8000000000ull;
    else s = 10000000000ull;
    return s;
}

/* ---------------- Main ---------------- */
int main(int argc, char **argv) {
    (void)argc; (void)argv;

    /* Deterministisches Pinning für den Supervisor selbst */
    pin_self_to_cpu0();

    /* Host-Caps erfassen (rein informativ/bootplan) */
    cl_boot_caps_t caps = read_host_caps();
    printf("clboot: cpu_online=%u sse4.2=%u avx2=%u avx512=%u\n",
           caps.cpu_online, caps.has_sse42, caps.has_avx2, caps.has_avx512);

    /* 1) SHM sicherstellen: clinit muss vorher gelaufen sein.
     *    (Endausbau: clboot kann clinit bei Bedarf automatisch starten.)
     */
    void *core_base = NULL;
    size_t core_sz = 0;
    int rc = map_shm_rw(CL_CORE_SHM_NAME, &core_base, &core_sz);
    if (rc != 0) {
        printf("FAIL: cannot map core shm (%s): rc=%d errno=%d (%s)\n",
               CL_CORE_SHM_NAME, rc, errno, strerror(errno));
        return 2;
    }

    cl_root_t *root = (cl_root_t*)core_base;
    cl_toc_t  *toc  = (cl_toc_t*)((uint8_t*)core_base + (size_t)root->toc_offset);

    /* Service segment finden */
    uint64_t svc_off = 0;
    rc = find_service_seg(root, toc, &svc_off);
    if (rc != 0) {
        printf("FAIL: service segment not found in TOC (rc=%d)\n", rc);
        unmap_shm(core_base, core_sz);
        return 3;
    }

    cl_service_seg_256_t *svc = (cl_service_seg_256_t*)((uint8_t*)core_base + (size_t)svc_off);

    /* Service-Segment initialisieren (ZERO-konform: nur Orchestrationsdaten) */
    atomic_fetch_add(&svc->g0.boot_epoch, 1);
    atomic_store(&svc->g0.boot_id_ns, now_ns());
    atomic_store(&svc->g0.service_count, (uint32_t)CL_SVC_MAX);

    /* expected=1, running=0 initial */
    for (int i = 0; i < (int)CL_SVC_MAX; i++) {
        cl_service_slot_32_t *sl = svc_slot(svc, (cl_service_id_t)i);
        if (!sl) continue;
        atomic_store(&sl->expected, 1u);
        atomic_store(&sl->running, 0u);
        atomic_store(&sl->pid, 0u);
        atomic_store(&sl->crash_count, 0u);
        atomic_store(&sl->last_heartbeat_ns, 0u);
        atomic_store(&sl->last_exit_code, 0);
        atomic_store(&sl->last_signal, 0);
    }

    /* Binaries / Reihenfolge */
    const char *os = detect_os_tag();

    char path_core[256], path_hal[256], path_link[256], path_flow[256], path_oracle[256];
    snprintf(path_core,   sizeof(path_core),   "bin/%s/core0",   os);
    snprintf(path_hal,    sizeof(path_hal),    "bin/%s/hal0",    os);
    snprintf(path_link,   sizeof(path_link),   "bin/%s/link0",   os);
    snprintf(path_flow,   sizeof(path_flow),   "bin/%s/flow0",   os);
    snprintf(path_oracle, sizeof(path_oracle), "bin/%s/oracle0", os);

    cl_proc_t procs[] = {
        { "core0",   CL_SVC_CORE0,   -1, 0, 0 },
        { "hal0",    CL_SVC_HAL0,    -1, 0, 0 },
        { "link0",   CL_SVC_LINK0,   -1, 0, 0 },
        { "flow0",   CL_SVC_FLOW0,   -1, 0, 0 },
        { "oracle0", CL_SVC_ORACLE0, -1, 0, 0 }
    };

    const char *paths[] = { path_core, path_hal, path_link, path_flow, path_oracle };

    /* Startphase: strikt in Reihenfolge starten (1 Versuch, dann Supervisor übernimmt) */
    for (size_t i = 0; i < sizeof(procs)/sizeof(procs[0]); i++) {
        pid_t pid = spawn_process(paths[i], procs[i].name);
        cl_service_slot_32_t *sl = svc_slot(svc, procs[i].sid);

        if (pid < 0) {
            printf("WARN: spawn %s failed: errno=%d (%s)\n", procs[i].name, errno, strerror(errno));
            atomic_store(&sl->running, 0u);
            atomic_store(&sl->pid, 0u);
            atomic_store(&sl->last_exit_code, -1);
            atomic_store(&sl->last_signal, 0);
            procs[i].pid = -1;
            procs[i].backoff_pow = 1;
            procs[i].next_restart_ns = now_ns() + backoff_ns(procs[i].backoff_pow);
            continue;
        }

        procs[i].pid = pid;
        atomic_store(&sl->running, 1u);
        atomic_store(&sl->pid, (uint32_t)pid);

        /* Startup grace: heartbeat darf zunächst 0 sein; Supervisor prüft später */
        procs[i].backoff_pow = 0;
        procs[i].next_restart_ns = 0;
    }

    /* Supervisor loop (Endausbau: deterministisch, kein busy loop) */
    const uint64_t heartbeat_timeout_ns = 5ull * 1000000000ull; /* 5s */
    const uint64_t poll_ns = 250ull * 1000000ull;              /* 250ms */

    for (;;) {
        /* reap children non-blocking */
        int status = 0;
        pid_t dead = waitpid(-1, &status, WNOHANG);
        if (dead > 0) {
            for (size_t i = 0; i < sizeof(procs)/sizeof(procs[0]); i++) {
                if (procs[i].pid == dead) {
                    cl_service_slot_32_t *sl = svc_slot(svc, procs[i].sid);

                    atomic_store(&sl->running, 0u);
                    atomic_store(&sl->pid, 0u);

                    if (WIFEXITED(status)) {
                        atomic_store(&sl->last_exit_code, (int32_t)WEXITSTATUS(status));
                        atomic_store(&sl->last_signal, 0);
                    } else if (WIFSIGNALED(status)) {
                        atomic_store(&sl->last_exit_code, -1);
                        atomic_store(&sl->last_signal, (int32_t)WTERMSIG(status));
                    }

                    atomic_fetch_add(&sl->crash_count, 1u);

                    /* schedule restart */
                    procs[i].pid = -1;
                    if (procs[i].backoff_pow < 10) procs[i].backoff_pow++;
                    procs[i].next_restart_ns = now_ns() + backoff_ns(procs[i].backoff_pow);
                    break;
                }
            }
        }

        uint64_t tnow = now_ns();

        /* heartbeat check + restarts */
        for (size_t i = 0; i < sizeof(procs)/sizeof(procs[0]); i++) {
            cl_service_slot_32_t *sl = svc_slot(svc, procs[i].sid);

            uint32_t expected = atomic_load(&sl->expected);
            if (!expected) continue;

            if (procs[i].pid > 0) {
                uint64_t hb = atomic_load(&sl->last_heartbeat_ns);

                /* Wenn heartbeat noch 0 ist, geben wir eine deterministische Grace-Phase (Timeout gilt erst ab hb>0) */
                if (hb > 0 && (tnow - hb) > heartbeat_timeout_ns) {
                    /* Timeout: hart kill + restart */
                    printf("WARN: %s heartbeat timeout; killing pid=%d\n", procs[i].name, (int)procs[i].pid);
                    (void)kill(procs[i].pid, SIGKILL);
                    /* waitpid wird im nächsten Loop reapen */
                }
            } else {
                /* not running: restart wenn fällig */
                if (procs[i].next_restart_ns != 0 && tnow >= procs[i].next_restart_ns) {
                    pid_t pid = spawn_process(paths[i], procs[i].name);
                    if (pid > 0) {
                        procs[i].pid = pid;
                        atomic_store(&sl->running, 1u);
                        atomic_store(&sl->pid, (uint32_t)pid);
                        procs[i].next_restart_ns = 0;
                    } else {
                        /* retry with same backoff schedule bump */
                        if (procs[i].backoff_pow < 10) procs[i].backoff_pow++;
                        procs[i].next_restart_ns = tnow + backoff_ns(procs[i].backoff_pow);
                    }
                }
            }
        }

        /* sleep */
        struct timespec ts;
        ts.tv_sec = (time_t)(poll_ns / 1000000000ull);
        ts.tv_nsec = (long)(poll_ns % 1000000000ull);
        nanosleep(&ts, NULL);
    }

    /* unreachable */
    /* unmap_shm(core_base, core_sz); */
    /* return 0; */
}


<<< END FILE: ./src/clboot/clboot.c

>>> START FILE: ./src/cld/cld.c
#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

static const char* detect_os_tag(void) {
#if defined(__FreeBSD__)
    return "bsd";
#elif defined(__linux__)
    return "linux";
#elif defined(__sun)
    return "omnios";
#else
    return "unknown";
#endif
}

static int run_wait(const char *path, char *const argv[]) {
    pid_t pid = fork();
    if (pid < 0) {
        printf("cld: fork failed: errno=%d (%s)\n", errno, strerror(errno));
        return -1;
    }
    if (pid == 0) {
        execv(path, argv);
        _exit(127);
    }

    int st = 0;
    if (waitpid(pid, &st, 0) < 0) {
        printf("cld: waitpid failed: errno=%d (%s)\n", errno, strerror(errno));
        return -2;
    }
    if (WIFEXITED(st)) return (int)WEXITSTATUS(st);
    if (WIFSIGNALED(st)) return 128 + (int)WTERMSIG(st);
    return -3;
}

int main(int argc, char **argv) {
    (void)argc; (void)argv;

    const char *os = detect_os_tag();

    char clinit_path[256];
    char clboot_path[256];
    snprintf(clinit_path, sizeof(clinit_path), "bin/%s/clinit", os);
    snprintf(clboot_path, sizeof(clboot_path), "bin/%s/clboot", os);

    /* ---------------------------------------------------------------------
     * BOOT MODE (SSOT):
     *   Immer Genesis: destroy -> init -> boot
     * --------------------------------------------------------------------- */

    /* 1) Destroy (idempotent) */
    {
        char *args[] = { (char*)clinit_path, (char*)"--destroy", NULL };
        int rc = run_wait(clinit_path, args);
        /* destroy darf ENOENT intern warnen, aber wir lassen rc!=0 nicht fatal werden */
        (void)rc;
    }

    /* 2) Init (Core-only; ZERO-konform) */
    {
        char *args[] = { (char*)clinit_path, NULL };
        int rc = run_wait(clinit_path, args);
        if (rc != 0) {
            printf("cld: clinit failed rc=%d\n", rc);
            return 2;
        }
    }

    /* 3) Boot (Supervisor) – ersetzt cld Prozess */
    {
        char *args[] = { (char*)clboot_path, NULL };
        execv(clboot_path, args);
        printf("cld: exec clboot failed: errno=%d (%s)\n", errno, strerror(errno));
        return 3;
    }
}


<<< END FILE: ./src/cld/cld.c

>>> START FILE: ./src/clinit/clinit.c
/*
 * ============================================================================
 * CommanderLink – clinit (SHM Bootstrap) – ZERO-konform – FINAL
 * Datei: src/clinit/clinit.c
 * ============================================================================
 *
 * ZIEL (ZERO-LAW):
 *   clinit darf keinerlei semantische Werte "setzen".
 *   clinit ist kein Sensor (HAL) und keine Logik (FLOW/LINK).
 *   clinit gießt ausschließlich das Fundament:
 *     - Core-SHM + optional Bulk-SHM anlegen
 *     - Root schreiben (Magic/Schema/Endian/ABI/TOC-Offsets)
 *     - TOC schreiben (Typ/Flags/Stride/Count/Offset)
 *     - ABI/TOC Gate prüfen (Fail-fast, keine stille Drift)
 *
 * KEINE Telemetrie.
 * KEINE Schätzwerte.
 * KEINE Default-Interpretation.
 * Alle Segmentdaten bleiben 0/UNKNOWN bis HAL läuft.
 *
 * ---------------------------------------------------------------------------
 * BOOT-ROADMAP (SSOT):
 *
 *   1) clinit  (dieses Tool)
 *      - SHM anlegen: /cl_core_root (+ optional /cl_bulk)
 *      - Root + TOC schreiben
 *      - ABI/TOC Gate -> "gültiger SHM-Vertrag"
 *
 *   2) Monitor2 (UI, read-only, ohne root)
 *      - shm_open(O_RDONLY) Core
 *      - Root prüfen: magic/schema/endian/abi_checksum
 *      - TOC anzeigen (Segmentliste)
 *      - zeigt "alles 0/UNKNOWN" korrekt, solange HAL aus ist
 *
 *   3) HAL (Wahrnehmung)
 *      - liest Hardware/OS
 *      - schreibt Shadow/Segments (Source/Quality/Epoch)
 *      - KEINE Policy
 *
 *   4) CORE (Herzschlag)
 *      - validiert Shadow
 *      - atomarer Shadow->Active Flip (active_index)
 *      - Gates/Budget/Trust als Wahrheitspfad
 *
 *   5) FLOW (Logik)
 *      - liest Active
 *      - berechnet deterministisch Pacing/Credits/Negotiation
 *      - schreibt Intents
 *
 *   6) LINK (Motorik)
 *      - setzt Intents um (Backend/DMA/Wire)
 *      - liefert Link-Physik zurück
 *
 *   7) ORACLE (Gedächtnis)
 *      - Trends/Hysterese/Evergreens
 *      - greift nicht direkt in Hot-Pfad ein
 *
 * ---------------------------------------------------------------------------
 * CLI:
 *   clinit            -> Core-only (bulk_present=0)
 *   clinit --bulk     -> Core + Bulk (bulk_present=1)
 *   clinit --destroy  -> shm_unlink(core/bulk) und exit
 *
 * ============================================================================
 */

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <stddef.h>
#include <stdalign.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>

#include "cl_runtime/cl_runtime.h" /* -Iinclude */

/* Service-State Segment (Boot/Supervisor SSOT) */
#include "cl_runtime/cl_service_seg_256.h"
/* --------------------------------------------------------------------------
 * Zeitbasis (nur für boot_id_ns; keine Telemetrie)
 * -------------------------------------------------------------------------- */
static uint64_t now_ns(void) {
    struct timespec ts;
#if defined(CLOCK_MONOTONIC)
    clock_gettime(CLOCK_MONOTONIC, &ts);
#else
    clock_gettime(CLOCK_REALTIME, &ts);
#endif
    return (uint64_t)ts.tv_sec * 1000000000ull + (uint64_t)ts.tv_nsec;
}

/* --------------------------------------------------------------------------
 * Alignment helper
 * -------------------------------------------------------------------------- */
static size_t align_up(size_t v, size_t a) {
    if (a == 0) return v;
    size_t r = v % a;
    return r ? (v + (a - r)) : v;
}

/* --------------------------------------------------------------------------
 * ABI-Fingerprint (FNV-1a 64)
 * MUSS exakt identisch zur Fingerprint-Definition im ABI-Report sein.
 * -------------------------------------------------------------------------- */
static uint64_t fnv1a64_init(void) { return 1469598103934665603ull; }
static uint64_t fnv1a64_u64(uint64_t h, uint64_t v) {
    for (int i = 0; i < 8; i++) {
        uint8_t b = (uint8_t)((v >> (i * 8)) & 0xffu);
        h ^= (uint64_t)b;
        h *= 1099511628211ull;
    }
    return h;
}
static uint64_t fnv1a64_u32(uint64_t h, uint32_t v) { return fnv1a64_u64(h, (uint64_t)v); }
static uint64_t fnv1a64_sz(uint64_t h, size_t v) { return fnv1a64_u64(h, (uint64_t)v); }

static uint64_t cl_compute_abi_fingerprint(void) {
    uint64_t h = fnv1a64_init();

    h = fnv1a64_u32(h, (uint32_t)CL_SCHEMA_VERSION_U32);
    h = fnv1a64_u32(h, (uint32_t)CL_ENDIAN_MAGIC_U32);
    h = fnv1a64_u32(h, (uint32_t)CL_SHM_PAGE_BYTES);

    h = fnv1a64_sz(h, sizeof(cl_root_t));
    h = fnv1a64_sz(h, sizeof(cl_toc_header_t));
    h = fnv1a64_sz(h, sizeof(cl_toc_entry_t));
    h = fnv1a64_u32(h, (uint32_t)CL_TOC_MAX_ENTRIES);
    h = fnv1a64_u32(h, (uint32_t)CL_TOC_VERSION);

    /* Segmentgrößen (nur Layout-Wahrheit, keine Inhalte) */
    h = fnv1a64_sz(h, sizeof(cl_cpu_seg_1024_t));
    h = fnv1a64_sz(h, sizeof(cl_budget_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_mem_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_link_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_time_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_overlay_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_watchdog_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_pcie_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_mesh_neighbor_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_mesh_peer_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_oracle_seg_256_t));

    h = fnv1a64_sz(h, sizeof(cl_nic_seg_512_t));
    h = fnv1a64_sz(h, sizeof(cl_board_seg_512_t));

    h = fnv1a64_sz(h, sizeof(cl_dma_seg_4096_t));
    h = fnv1a64_sz(h, sizeof(cl_history_seg_4096_t));
    h = fnv1a64_sz(h, sizeof(cl_forensics_seg_4096_t));
    h = fnv1a64_sz(h, sizeof(cl_zfs_seg_4096_t));

    /* Alignments */
    h = fnv1a64_sz(h, (size_t)alignof(cl_root_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_cpu_seg_1024_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_dma_seg_4096_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_zfs_seg_4096_t));

    /* Root offsets (kritisch) */
    h = fnv1a64_sz(h, offsetof(cl_root_t, abi_layout_checksum));
    h = fnv1a64_sz(h, offsetof(cl_root_t, toc_offset));
    h = fnv1a64_sz(h, offsetof(cl_root_t, toc_size));
    h = fnv1a64_sz(h, offsetof(cl_root_t, schema_version));
    h = fnv1a64_sz(h, offsetof(cl_root_t, endian_magic));
    h = fnv1a64_sz(h, offsetof(cl_root_t, root_magic));
    h = fnv1a64_sz(h, offsetof(cl_root_t, root_flags));
    h = fnv1a64_sz(h, offsetof(cl_root_t, bulk_present));
    h = fnv1a64_sz(h, offsetof(cl_root_t, bulk_epoch));

    /* TOC entry offsets (kritisch) */
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, type));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, stride_bytes));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, count));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, offset_bytes));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, source_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, access_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, presence_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, layout_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, gates_possible));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, gates_effective));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, epoch));

    return h;
}

/* --------------------------------------------------------------------------
 * POSIX SHM helpers
 *
 * Hinweis (Endausbau):
 *   Monitor soll ohne root lesen können.
 *   Dafür braucht es 0660 + Gruppe (z.B. "cl") und User in dieser Gruppe.
 *   Hier setzen wir 0660 deterministisch. Gruppen-/Owner-Politik wird später
 *   im Dienststart (root) gesetzt (TODO unten).
 * -------------------------------------------------------------------------- */
static void warn_unlink(const char *name) {
    if (shm_unlink(name) != 0) {
        if (errno != ENOENT) {
            printf("WARN: shm_unlink(%s) failed: errno=%d (%s)\n", name, errno, strerror(errno));
        }
    }
}

static int shm_create_map_rw(const char *name, size_t sz, void **out_base, int *out_fd) {
    warn_unlink(name);

    int fd = shm_open(name, O_CREAT | O_RDWR, 0660);
    if (fd < 0) return -1;

    /* umask neutralisieren */
    (void)fchmod(fd, 0660);

    /* TODO (Endausbau): wenn als root gestartet, Gruppe auf "cl" setzen:
     *   - gid via getgrnam("cl") (oder manifestierter gid)
     *   - fchown(fd, 0, gid_cl)
     * Damit kann Monitor ohne root lesen (0660).
     */

    if (ftruncate(fd, (off_t)sz) != 0) {
        close(fd);
        return -2;
    }

    void *p = mmap(NULL, sz, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) {
        close(fd);
        return -3;
    }

    *out_base = p;
    *out_fd = fd;
    return 0;
}

static void shm_unmap_close(void *base, size_t sz, int fd) {
    if (base && sz) (void)munmap(base, sz);
    if (fd >= 0) close(fd);
}

/* --------------------------------------------------------------------------
 * TOC helpers (ZERO: nur Geometrie)
 * -------------------------------------------------------------------------- */
static void toc_init(cl_toc_t *toc, uint64_t total_bytes, uint64_t build_id) {
    memset(toc, 0, sizeof(*toc));
    toc->header.version = CL_TOC_VERSION;
    toc->header.entry_count = 0;
    toc->header.total_bytes = total_bytes;
    toc->header.build_id = build_id;
    toc->header.epoch = 1;
}

static void toc_add(cl_toc_t *toc,
                    uint16_t type,
                    uint16_t version,
                    uint32_t flags,
                    uint32_t stride_bytes,
                    uint32_t count,
                    uint64_t offset_bytes,
                    uint16_t source_flags,
                    uint16_t access_flags,
                    uint16_t presence_flags,
                    uint16_t layout_flags)
{
    if (toc->header.entry_count >= CL_TOC_MAX_ENTRIES) return;

    cl_toc_entry_t *e = &toc->entries[toc->header.entry_count++];
    memset(e, 0, sizeof(*e));

    e->type = type;
    e->version = version;
    e->flags = flags;

    e->stride_bytes = stride_bytes;
    e->count = count;
    e->offset_bytes = offset_bytes;

    e->source_flags = source_flags;
    e->access_flags = access_flags;
    e->presence_flags = presence_flags;
    e->layout_flags = layout_flags;

    /* ZERO: keine inhaltlichen Gates hier; bleiben 0 bis HAL/CORE */
    e->gates_possible = 0;
    e->gates_effective = 0;

    /* ZERO: epoch = 0 (UNINITIALIZED) – Validität kommt später aus CORE */
    e->epoch = 0;
}

/* --------------------------------------------------------------------------
 * ABI/TOC Gate (hard; keine stillen SHMs)
 * -------------------------------------------------------------------------- */
static int is_allowed_stride(uint32_t s) {
    return (s == 256u) || (s == 512u) || (s == 1024u) || (s == 4096u);
}
static int check_bounds_u64(uint64_t off, uint64_t len, uint64_t total) {
    if (off > total) return 0;
    if (len > total) return 0;
    if (off + len > total) return 0;
    return 1;
}
static int gate_root_toc(const cl_root_t *r, const cl_toc_t *toc, uint64_t core_total,
                         uint64_t bulk_total, int bulk_present)
{
    if (r->root_magic != CL_ROOT_MAGIC_U32) return 100;
    if (r->schema_version != CL_SCHEMA_VERSION_U32) return 101;
    if (r->endian_magic != CL_ENDIAN_MAGIC_U32) return 102;

    uint64_t want = cl_compute_abi_fingerprint();
    if (r->abi_layout_checksum != want) return 103;

    if (!check_bounds_u64(r->toc_offset, r->toc_size, core_total)) return 104;
    if (r->toc_size < sizeof(cl_toc_header_t)) return 105;

    if (toc->header.version != CL_TOC_VERSION) return 106;
    if (toc->header.entry_count > CL_TOC_MAX_ENTRIES) return 107;

    uint64_t need = (uint64_t)sizeof(cl_toc_header_t) +
                    (uint64_t)toc->header.entry_count * (uint64_t)sizeof(cl_toc_entry_t);
    if (need > r->toc_size) return 108;

    for (uint32_t i = 0; i < toc->header.entry_count; i++) {
        const cl_toc_entry_t *e = &toc->entries[i];
        uint32_t stride = (uint32_t)e->stride_bytes;
        uint32_t count  = (uint32_t)e->count;
        uint64_t off    = (uint64_t)e->offset_bytes;

        if (!is_allowed_stride(stride)) return 120;
        if ((off % (uint64_t)stride) != 0u) return 121;

        uint64_t seg_bytes = (uint64_t)stride * (uint64_t)count;

        const int in_bulk = ((e->flags & CL_TOC_FLAG_RECLAIMABLE) != 0u);
        if (!in_bulk) {
            if (!check_bounds_u64(off, seg_bytes, core_total)) return 122;
        } else {
            if (bulk_present) {
                if (!check_bounds_u64(off, seg_bytes, bulk_total)) return 123;
            }
        }
    }
    return 0;
}

/* --------------------------------------------------------------------------
 * CLI
 * -------------------------------------------------------------------------- */
static void usage(const char *argv0) {
    printf("Usage:\n");
    printf("  %s            Create CORE SHM only\n", argv0);
    printf("  %s --bulk     Create CORE + BULK SHM\n", argv0);
    printf("  %s --destroy  shm_unlink CORE/BULK and exit\n", argv0);
}

int main(int argc, char **argv) {
    int want_bulk = 0;
    int destroy = 0;

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--bulk") == 0) want_bulk = 1;
        else if (strcmp(argv[i], "--destroy") == 0) destroy = 1;
        else if (strcmp(argv[i], "--help") == 0) { usage(argv[0]); return 0; }
        else { usage(argv[0]); return 1; }
    }

    if (destroy) {
        warn_unlink(CL_CORE_SHM_NAME);
        warn_unlink(CL_BULK_SHM_NAME);
        printf("OK: destroyed %s and %s\n", CL_CORE_SHM_NAME, CL_BULK_SHM_NAME);
        return 0;
    }

    const uint64_t abi_fp  = cl_compute_abi_fingerprint();
    const uint64_t boot_ns = now_ns();

    /* Core layout: Root(4096) + TOC(4096) + Segmente */
    const size_t root_off = 0;
    const size_t toc_off  = CL_SHM_PAGE_BYTES;
    const size_t toc_sz   = CL_SHM_PAGE_BYTES;

    size_t off = toc_off + toc_sz;
    off = align_up(off, 256);

    /* Minimal Counts (ZERO: nur Geometrie; spätere Erweiterung über clctl) */
    const uint32_t cpu_count = 1;
    const uint32_t nic_count = 1;
    const uint32_t neighbor_count = 32;

    /* Offsets: stride-aligned; sizes = stride*count */
    size_t off_link     = align_up(off, 256);  off = off_link     + 256;
    size_t off_budget   = align_up(off, 256);  off = off_budget   + 256;
    size_t off_mem      = align_up(off, 256);  off = off_mem      + 256;
    size_t off_overlay  = align_up(off, 256);  off = off_overlay  + 256;
    size_t off_watchdog = align_up(off, 256);  off = off_watchdog + 256;
    size_t off_time     = align_up(off, 256);  off = off_time     + 256;
    size_t off_pcie     = align_up(off, 256);  off = off_pcie     + 256;
    size_t off_oracle   = align_up(off, 256);  off = off_oracle   + 256;
    size_t off_service  = align_up(off, 256);  off = off_service  + 256;

    size_t off_cpu      = align_up(off, 1024); off = off_cpu      + (size_t)cpu_count * 1024;
    size_t off_nic      = align_up(off, 512);  off = off_nic      + (size_t)nic_count * 512;
    size_t off_board    = align_up(off, 512);  off = off_board    + 512;

    size_t off_neighbor = align_up(off, 256);  off = off_neighbor + (size_t)neighbor_count * 256;
    size_t off_zfs      = align_up(off, 4096); off = off_zfs      + 4096;

    const size_t core_total = align_up(off, 4096);

    /* Bulk layout (optional): ZERO: nur Geometrie, Inhalte bleiben 0 */
    size_t bulk_total = 0;
    size_t bulk_off_dma = 0, bulk_off_hist = 0, bulk_off_for = 0;

    if (want_bulk) {
        size_t boff = 0;
        boff = align_up(boff, 4096);
        bulk_off_dma  = align_up(boff, 4096); boff = bulk_off_dma  + 4096;
        bulk_off_hist = align_up(boff, 4096); boff = bulk_off_hist + 4096;
        bulk_off_for  = align_up(boff, 4096); boff = bulk_off_for  + 4096;
        bulk_total = align_up(boff, 4096);
    }

    void *core_base = NULL;
    int core_fd = -1;
    int rc = shm_create_map_rw(CL_CORE_SHM_NAME, core_total, &core_base, &core_fd);
    if (rc != 0) {
        printf("FAIL: create/map core shm (%s): rc=%d errno=%d (%s)\n",
               CL_CORE_SHM_NAME, rc, errno, strerror(errno));
        return 2;
    }

    void *bulk_base = NULL;
    int bulk_fd = -1;
    if (want_bulk) {
        rc = shm_create_map_rw(CL_BULK_SHM_NAME, bulk_total, &bulk_base, &bulk_fd);
        if (rc != 0) {
            printf("FAIL: create/map bulk shm (%s): rc=%d errno=%d (%s)\n",
                   CL_BULK_SHM_NAME, rc, errno, strerror(errno));
            shm_unmap_close(core_base, core_total, core_fd);
            return 3;
        }
    } else {
        warn_unlink(CL_BULK_SHM_NAME);
    }

    /* ZERO: Datenbereiche sind nur Null; keine Telemetrie */
    memset(core_base, 0, core_total);
    if (want_bulk) memset(bulk_base, 0, bulk_total);

    cl_root_t *root = (cl_root_t*)((uint8_t*)core_base + root_off);
    cl_toc_t  *toc  = (cl_toc_t*)((uint8_t*)core_base + toc_off);

    /* Root: Notfall-Wahrheit (minimal, deterministisch) */
    root->abi_layout_checksum = abi_fp;

    atomic_store(&root->seq_cnt, 1u);
    atomic_store(&root->uptime_ns, 0u);
    atomic_store(&root->bulk_epoch, 0u);

    root->boot_id_ns = boot_ns;

    /* ZERO: Identitäten werden später durch Provisioning/HAL gesetzt */
    root->mesh_tag64 = 0;
    root->node_tag64 = 0;

    root->toc_offset = (uint64_t)toc_off;
    root->toc_size   = (uint64_t)toc_sz;

    root->root_magic = CL_ROOT_MAGIC_U32;
    root->root_flags = CL_ROOT_FLAG_FAILFAST_ABI;

    root->schema_version = CL_SCHEMA_VERSION_U32;
    root->endian_magic   = CL_ENDIAN_MAGIC_U32;

    atomic_store(&root->bulk_present, want_bulk ? 1u : 0u);

    /* TOC: reine Geometrie */
    toc_init(toc, (uint64_t)(core_total + bulk_total), abi_fp);

    toc_add(toc, (uint16_t)CL_LINK_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL,
            256, 1, (uint64_t)off_link,
            CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_BUDGET_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL,
            256, 1, (uint64_t)off_budget,
            CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_MEM_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_DATA,
            256, 1, (uint64_t)off_mem,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_OVERLAY_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_CONTROL,
            256, 1, (uint64_t)off_overlay,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_WATCHDOG_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL | CL_TOC_FLAG_FORENSICS,
            256, 1, (uint64_t)off_watchdog,
            CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_TIME_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_CONTROL,
            256, 1, (uint64_t)off_time,
            CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_PCIE_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_DATA,
            256, 1, (uint64_t)off_pcie,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_ORACLE_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_COLD | CL_TOC_FLAG_DATA,
            256, 1, (uint64_t)off_oracle,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_SERVICE_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL | CL_TOC_FLAG_CRITICAL,
            256, 1, (uint64_t)off_service,
            CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);


    toc_add(toc, (uint16_t)CL_CPU_SEG_1024, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA | CL_TOC_FLAG_FIXED_COUNT,
            1024, cpu_count, (uint64_t)off_cpu,
            CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_NIC_SEG_512, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA | CL_TOC_FLAG_FIXED_COUNT,
            512, nic_count, (uint64_t)off_nic,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_BOARD_SEG_512, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_DATA,
            512, 1, (uint64_t)off_board,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_MESH_NEIGHBOR_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA | CL_TOC_FLAG_FIXED_COUNT,
            256, neighbor_count, (uint64_t)off_neighbor,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE | CL_TOC_LAYOUT_ARRAY);

    toc_add(toc, (uint16_t)CL_ZFS_SEG_4096, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_COLD | CL_TOC_FLAG_DATA,
            4096, 1, (uint64_t)off_zfs,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    if (want_bulk) {
        toc_add(toc, (uint16_t)CL_DMA_SEG_4096, 1,
                CL_TOC_FLAG_RECLAIMABLE | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA,
                4096, 1, (uint64_t)bulk_off_dma,
                CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

        toc_add(toc, (uint16_t)CL_HISTORY_SEG_4096, 1,
                CL_TOC_FLAG_RECLAIMABLE | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_COLD | CL_TOC_FLAG_FORENSICS,
                4096, 1, (uint64_t)bulk_off_hist,
                CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
                CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

        toc_add(toc, (uint16_t)CL_FORENSICS_SEG_4096, 1,
                CL_TOC_FLAG_RECLAIMABLE | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_COLD | CL_TOC_FLAG_FORENSICS,
                4096, 1, (uint64_t)bulk_off_for,
                CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
                CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);
    }

    msync(core_base, core_total, MS_SYNC);
    if (want_bulk) msync(bulk_base, bulk_total, MS_SYNC);

    /* ABI/TOC Gate */
    int gate = gate_root_toc(root, toc, (uint64_t)core_total, (uint64_t)bulk_total, want_bulk);
    if (gate != 0) {
        printf("FAIL: clinit gate failed: code=%d\n", gate);
        shm_unmap_close(core_base, core_total, core_fd);
        if (want_bulk) shm_unmap_close(bulk_base, bulk_total, bulk_fd);
        return 10;
    }

    /* Prints: nur lokale Kopien, ZERO-konform */
    const uint32_t toc_entries = toc->header.entry_count;
    const uint64_t core_sz_out = (uint64_t)core_total;
    const uint64_t bulk_sz_out = (uint64_t)bulk_total;
    const uint64_t abi_out     = abi_fp;

    shm_unmap_close(core_base, core_total, core_fd);
    if (want_bulk) shm_unmap_close(bulk_base, bulk_total, bulk_fd);

    printf("OK: clinit created core=%s size=%" PRIu64 "\n", CL_CORE_SHM_NAME, core_sz_out);
    if (want_bulk) printf("OK: clinit created bulk=%s size=%" PRIu64 "\n", CL_BULK_SHM_NAME, bulk_sz_out);
    printf("ABI checksum: 0x%016" PRIx64 "\n", abi_out);
    printf("TOC entries: %u\n", (unsigned)toc_entries);

    return 0;
}


<<< END FILE: ./src/clinit/clinit.c

>>> START FILE: ./src/core/core0.c
/* ============================================================================
 * CommanderLink – CORE0 (Endausbau, SSOT-konform, Authority-Richter)
 * Datei: src/core/core0.c
 * ============================================================================
 *
 * KERNVERTRAG (SSOT):
 * - SHM ist Wahrheit; TOC verkabelt Segmente.
 * - Validität pro Segment = TOC entry.epoch (epoch==0 => UNINITIALIZED).
 * - CORE publisht deterministisch über Release-Store auf entry.epoch (Cut-Point).
 * - CORE ist Authority für:
 *     * gates_possible / gates_effective (TOC + global)
 *     * Watchdog state/reason (Latching, Priorität, Recovery)
 *     * Root Quick-Views als Spiegel/Abkürzung (keine zweite Wahrheit)
 * - CORE setzt KEIN Redirect (LINK-only), setzt KEINE OS-Routen, keine Sideeffects.
 *
 * ENDAUSBAU-PRINZIP:
 * - Keine "memset(0)" auf fremde Telemetriesegmente.
 * - Auswertung: CPU/NIC/BOARD/BUDGET/TIME/MESH_PEER/LINK.
 * - Worst-Case: Bei fehlender Telemetrie => konservativ (Gates schließen, Trust none).
 *
 * Hinweis:
 * - Diese Datei nutzt exakt die Typen aus deinem Dump:
 *   cl_root_4096_t, cl_toc_header_t, cl_toc_entry_t, Segmenttypen aus cl_runtime.h.
 */

#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <signal.h>
#include <stdatomic.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>

#include "cl_runtime/cl_runtime.h"   /* Frontdoor */
#include "cl_runtime/cl_toc.h"       /* cl_toc_header_t / cl_toc_entry_t / IDs */
#include "cl_runtime/cl_shm_layout.h"
#include "cl_runtime/cl_gates.h"
#include "cl_runtime/cl_service_seg_256.h"
#include "cl_runtime/cl_seg_watchdog_256.h"
#include "cl_runtime/cl_seg_time_256.h"
#include "cl_runtime/cl_seg_cpu_1024.h"
#include "cl_runtime/cl_seg_nic_512.h"
#include "cl_runtime/cl_seg_board_512.h"
#include "cl_runtime/cl_seg_budget_256.h"
#include "cl_runtime/cl_seg_link_256.h"
#include "cl_runtime/cl_seg_mesh_peer_256.h"

/* -------------------------------------------------------------------------- */

#ifndef CL_NS_PER_S
#define CL_NS_PER_S 1000000000ull
#endif

#ifndef CL_CORE_DEFAULT_TICK_MS
#define CL_CORE_DEFAULT_TICK_MS 50u
#endif

/* Root Page ist 4096B (Schema) */
#ifndef CL_ROOT_BYTES
#define CL_ROOT_BYTES 4096u
#endif

/* -------------------------------------------------------------------------- */
/* Signal Handling                                                            */
/* -------------------------------------------------------------------------- */

static volatile sig_atomic_t g_stop = 0;

static void core0_on_signal(int signo) {
    (void)signo;
    g_stop = 1;
}

/* -------------------------------------------------------------------------- */
/* Zeitbasis                                                                  */
/* -------------------------------------------------------------------------- */

static uint64_t core0_now_ns_monotonic(void) {
    struct timespec ts;
    if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0) {
        return 0;
    }
    return (uint64_t)ts.tv_sec * CL_NS_PER_S + (uint64_t)ts.tv_nsec;
}

/* -------------------------------------------------------------------------- */
/* SHM Mapping                                                                */
/* -------------------------------------------------------------------------- */

typedef struct core0_map_s {
    int      fd;
    uint8_t *base;
    size_t   size;
} core0_map_t;

/* In deinem Root-Header stehen die Namen:
 *   CL_CORE_SHM_NAME = "/cl_core_root"
 */
#ifndef CL_CORE_SHM_NAME
#define CL_CORE_SHM_NAME "/cl_core_root"
#endif

static int core0_map_open(core0_map_t *m, const char *shm_name, size_t min_size) {
    memset(m, 0, sizeof(*m));
    m->fd = shm_open(shm_name, O_RDWR, 0600);
    if (m->fd < 0) return -1;

    struct stat st;
    if (fstat(m->fd, &st) != 0) {
        close(m->fd);
        m->fd = -1;
        return -1;
    }
    if ((size_t)st.st_size < min_size) {
        close(m->fd);
        m->fd = -1;
        errno = EINVAL;
        return -1;
    }

    m->size = (size_t)st.st_size;
    m->base = (uint8_t *)mmap(NULL, m->size, PROT_READ | PROT_WRITE, MAP_SHARED, m->fd, 0);
    if (m->base == MAP_FAILED) {
        m->base = NULL;
        close(m->fd);
        m->fd = -1;
        return -1;
    }
    return 0;
}

static void core0_map_close(core0_map_t *m) {
    if (m->base) {
        (void)munmap(m->base, m->size);
        m->base = NULL;
    }
    if (m->fd >= 0) {
        (void)close(m->fd);
        m->fd = -1;
    }
    m->size = 0;
}

/* -------------------------------------------------------------------------- */
/* Root / TOC Zugriff (SSOT)                                                  */
/* -------------------------------------------------------------------------- */

static inline cl_root_4096_t *core0_root_ptr(uint8_t *base) {
    return (cl_root_4096_t *)(void *)base;
}

static inline cl_toc_header_t *core0_toc_hdr_ptr(uint8_t *base, const cl_root_4096_t *root) {
    return (cl_toc_header_t *)(void *)(base + (size_t)root->toc_offset);
}

static inline cl_toc_entry_t *core0_toc_entries_ptr(cl_toc_header_t *hdr) {
    /* Header ist 64B, Entries folgen direkt */
    return (cl_toc_entry_t *)(void *)((uint8_t *)(void *)hdr + sizeof(*hdr));
}

static cl_toc_entry_t *core0_toc_find_entry_mut(cl_toc_header_t *hdr, cl_toc_entry_t *ent, uint16_t type) {
    const uint32_t n = hdr->entry_count;
    for (uint32_t i = 0; i < n; i++) {
        if (ent[i].type == type) return &ent[i];
    }
    return NULL;
}

static const cl_toc_entry_t *core0_toc_find_entry(const cl_toc_header_t *hdr, const cl_toc_entry_t *ent, uint16_t type) {
    const uint32_t n = hdr->entry_count;
    for (uint32_t i = 0; i < n; i++) {
        if (ent[i].type == type) return &ent[i];
    }
    return NULL;
}

static void *core0_seg_ptr(uint8_t *base, size_t map_size, const cl_toc_entry_t *e) {
    const uint64_t off   = e->offset_bytes;
    const uint64_t bytes = (uint64_t)e->stride_bytes * (uint64_t)e->count;

    if (off == 0 || bytes == 0) return NULL;
    if (off + bytes > (uint64_t)map_size) return NULL;

    return (void *)(base + (size_t)off);
}

/* -------------------------------------------------------------------------- */
/* Epoch Publish (Cut-Point)                                                  */
/* -------------------------------------------------------------------------- */

static uint64_t core0_next_epoch_u64(uint64_t cur) {
    /* epoch==0 ist UNINITIALIZED. CORE bump’t immer auf >=1. */
    uint64_t n = (cur == 0) ? 1ull : (cur + 1ull);
    if (n == 0) n = 1ull;
    return n;
}

static void core0_publish_epoch(cl_toc_entry_t *e, uint64_t next_epoch) {
    atomic_store_explicit((_Atomic(uint64_t) *)&e->epoch, next_epoch, memory_order_release);
}

/* Reader-Gating: Segment ist nur "brauchbar", wenn epoch>0 und presence PRESENT (und nicht RECLAIMED). */
static bool core0_entry_readable(const cl_root_4096_t *root, const cl_toc_entry_t *e) {
    (void)root;
    const uint64_t ep = atomic_load_explicit((_Atomic(uint64_t) *)&e->epoch, memory_order_acquire);
    if (ep == 0) return false;

    /* presence_flags ist SSOT: RECLAIMED dominiert */
    if ((e->presence_flags & CL_TOC_RECLAIMED) != 0) return false;

    /* Bulk-Segmente sind RECLAIMED, wenn root.bulk_present == 0 und RECLAIMABLE gesetzt ist.
     * (Monitor-Regel; CORE behandelt das gleich konservativ fürs Lesen.)
     */
    if ((e->flags & CL_TOC_FLAG_RECLAIMABLE) != 0) {
        const uint32_t bp = atomic_load_explicit(&root->bulk_present, memory_order_relaxed);
        if (bp == 0) return false;
    }

    /* UNSUPPORTED -> nicht kontrollwirksam */
    if ((e->source_flags & CL_TOC_SOURCE_UNSUPPORTED) != 0) return false;

    return true;
}

/* -------------------------------------------------------------------------- */
/* Reason / Priority (minimal, deterministisch)                               */
/* -------------------------------------------------------------------------- */

/* In den Segmenten existieren reason_code / constraint_flags (u32), aber das konkrete Enum
 * liegt in cl_manifest/cl_enums.h. Wir dürfen hier keine Policy erfinden.
 *
 * Deshalb: CORE arbeitet primär mit GATES (u64) als physikalische Wahrheit.
 * root.reason_code wird als "best-effort Spiegel" gesetzt:
 *   - 0 = none/ok (konservativ)
 *   - sonst bleibt es bei den Input-Reasons, sofern vorhanden.
 *
 * Watchdog hat eigene Reasons (cl_wd_reason_t) – dort ist Latching Pflicht.
 */

static uint32_t core0_u32_min(uint32_t a, uint32_t b) { return (a < b) ? a : b; }
static uint32_t core0_u32_max(uint32_t a, uint32_t b) { return (a > b) ? a : b; }

/* -------------------------------------------------------------------------- */
/* Watchdog Latching (CORE Authority)                                         */
/* -------------------------------------------------------------------------- */

typedef struct core0_wd_eval_s {
    cl_wd_state_t  state;
    cl_wd_reason_t reason;
    cl_wd_module_t module;
    uint64_t       last_progress_ns;
} core0_wd_eval_t;

static core0_wd_eval_t core0_watchdog_eval(const cl_root_4096_t *root,
                                          cl_watchdog_seg_256_t *wd,
                                          const cl_toc_header_t *toc_hdr,
                                          const cl_toc_entry_t *toc_ent,
                                          uint64_t now_ns)
{
    (void)toc_hdr;
    (void)toc_ent;

    core0_wd_eval_t out;
    out.state = CL_WD_OK;
    out.reason = CL_WD_R_NONE;
    out.module = CL_WD_MOD_NONE;

    /* Policy/Thresholds (COLD) – konservativ, aber sichtbar */
    const uint32_t warn_th = wd->cold.warn_ns_threshold ? wd->cold.warn_ns_threshold : 250000000u;   /* 250ms */
    const uint32_t stall_th = wd->cold.stall_ns_threshold ? wd->cold.stall_ns_threshold : 2000000000u;/* 2s */

    /* Liveness: Module ticks */
    const uint64_t hal_tick    = atomic_load_explicit(&wd->hot_a.hal_tick_ns,    memory_order_relaxed);
    const uint64_t core_tick   = atomic_load_explicit(&wd->hot_a.core_tick_ns,   memory_order_relaxed);
    const uint64_t flow_tick   = atomic_load_explicit(&wd->hot_a.flow_tick_ns,   memory_order_relaxed);
    const uint64_t link_tick   = atomic_load_explicit(&wd->hot_a.link_tick_ns,   memory_order_relaxed);
    const uint64_t oracle_tick = atomic_load_explicit(&wd->hot_a.oracle_tick_ns, memory_order_relaxed);

    /* "progress": wenn root.seq_cnt/uptime_ns sich bewegt oder LINK commit epoch steigt.
     * Hier minimal: nutze root.seq_cnt (monotone) als Fortschrittssignal, wenn vorhanden.
     */
    const uint64_t root_seq = atomic_load_explicit(&root->seq_cnt, memory_order_relaxed);

    const uint64_t last_root_seq = atomic_load_explicit(&wd->hot_b.last_root_seq_cnt, memory_order_relaxed);
    uint64_t last_progress = atomic_load_explicit(&wd->hot_b.last_progress_ns, memory_order_relaxed);

    if (root_seq != last_root_seq) {
        last_progress = now_ns;
        /* Update progress marker (relaxed; publish über CORE-epoch an WD-Entry) */
        atomic_store_explicit(&wd->hot_b.last_progress_ns, last_progress, memory_order_relaxed);
        atomic_store_explicit(&wd->hot_b.last_root_seq_cnt, root_seq, memory_order_relaxed);
    }
    out.last_progress_ns = last_progress;

    /* Stall-Check Helper */
    auto uint64_t age(uint64_t t) -> uint64_t { return (t == 0 || now_ns < t) ? UINT64_MAX : (now_ns - t); };

    /* Bestimme schlimmste Liveness-Abweichung (Warn/Stall) */
    struct {
        cl_wd_module_t mod;
        cl_wd_reason_t r_warn;
        cl_wd_reason_t r_stall;
        uint64_t       tick_ns;
    } mods[] = {
        { CL_WD_MOD_HAL,    CL_WD_R_NONE, CL_WD_R_STALL_HAL,    hal_tick    },
        { CL_WD_MOD_CORE,   CL_WD_R_NONE, CL_WD_R_STALL_CORE,   core_tick   },
        { CL_WD_MOD_FLOW,   CL_WD_R_NONE, CL_WD_R_STALL_FLOW,   flow_tick   },
        { CL_WD_MOD_LINK,   CL_WD_R_NONE, CL_WD_R_STALL_LINK,   link_tick   },
        { CL_WD_MOD_ORACLE, CL_WD_R_NONE, CL_WD_R_STALL_ORACLE, oracle_tick }
    };

    cl_wd_state_t worst_state = CL_WD_OK;
    cl_wd_reason_t worst_reason = CL_WD_R_NONE;
    cl_wd_module_t worst_mod = CL_WD_MOD_NONE;

    for (size_t i = 0; i < sizeof(mods)/sizeof(mods[0]); i++) {
        const uint64_t a = age(mods[i].tick_ns);
        if (a == UINT64_MAX) {
            /* Wenn ein Modul noch nie getickt hat, ist das im Endausbau ein Warnsignal,
             * aber nicht sofort Stall, solange progress existiert.
             */
            if (worst_state < CL_WD_WARN) {
                worst_state = CL_WD_WARN;
                worst_reason = mods[i].r_stall; /* reuse: "stall <mod>" als Diagnose */
                worst_mod = mods[i].mod;
            }
            continue;
        }

        if (a >= (uint64_t)stall_th) {
            worst_state = CL_WD_STALL;
            worst_reason = mods[i].r_stall;
            worst_mod = mods[i].mod;
            break; /* Stall dominiert */
        }
        if (a >= (uint64_t)warn_th) {
            if (worst_state < CL_WD_WARN) {
                worst_state = CL_WD_WARN;
                worst_reason = mods[i].r_stall; /* Diagnose */
                worst_mod = mods[i].mod;
            }
        }
    }

    /* Progress-Stall: wenn über stall_th kein Fortschritt, escalate zu STALL/PANIC */
    if (last_progress != 0 && now_ns >= last_progress) {
        const uint64_t prog_age = now_ns - last_progress;
        if (prog_age >= (uint64_t)stall_th) {
            /* Fortschrittsstillstand ist härter als einzelne Tick-Warnungen */
            worst_state = CL_WD_STALL;
            if (worst_reason == CL_WD_R_NONE) worst_reason = CL_WD_R_INVARIANT_BREACH;
            if (worst_mod == CL_WD_MOD_NONE) worst_mod = CL_WD_MOD_CORE;
        }
    }

    /* Latching: schreibe NICHT jedes Tick Reason zurück auf NONE.
     * Regel:
     * - Wenn neuer Zustand schlimmer -> übernehmen.
     * - Wenn neuer Zustand besser -> erst übernehmen, wenn tatsächlich alle Bedingungen ok sind.
     */
    const uint32_t cur_state_u32  = atomic_load_explicit(&wd->hot_b.wd_state, memory_order_relaxed);
    const uint32_t cur_reason_u32 = atomic_load_explicit(&wd->hot_b.wd_reason, memory_order_relaxed);
    const uint32_t cur_mod_u32    = atomic_load_explicit(&wd->hot_b.last_stall_module, memory_order_relaxed);

    const cl_wd_state_t cur_state = (cl_wd_state_t)cur_state_u32;
    const cl_wd_reason_t cur_reason = (cl_wd_reason_t)cur_reason_u32;
    const cl_wd_module_t cur_mod = (cl_wd_module_t)cur_mod_u32;

    out.state  = cur_state;
    out.reason = cur_reason;
    out.module = cur_mod;

    if (worst_state > cur_state) {
        /* Verschlechterung: sofort latched */
        out.state  = worst_state;
        out.reason = worst_reason;
        out.module = worst_mod;
    } else if (worst_state < cur_state) {
        /* Verbesserung: nur wenn wirklich OK und progress ok */
        if (worst_state == CL_WD_OK) {
            out.state  = CL_WD_OK;
            out.reason = CL_WD_R_NONE;
            out.module = CL_WD_MOD_NONE;
        } else {
            /* z.B. STALL -> WARN, latche WARN */
            out.state  = worst_state;
            out.reason = worst_reason;
            out.module = worst_mod;
        }
    } else {
        /* Gleich: wenn cur_reason NONE aber worst_reason != NONE, setze Diagnose */
        if (out.reason == CL_WD_R_NONE && worst_reason != CL_WD_R_NONE) {
            out.reason = worst_reason;
            out.module = worst_mod;
        }
    }

    return out;
}

/* -------------------------------------------------------------------------- */
/* Physik-Auswertung -> Gates (global)                                        */
/* -------------------------------------------------------------------------- */

typedef struct core0_inputs_s {
    bool have_cpu;
    bool have_nic;
    bool have_board;
    bool have_budget;
    bool have_time;
    bool have_link;
    bool have_mesh_peer;
    bool have_watchdog;

    /* Snapshots (best-effort) */
    uint32_t cpu_temp_c_x10;
    uint32_t cpu_throttling;      /* 0/1 */
    uint32_t cpu_load_permille;

    uint32_t nic_thermal_state;   /* enum numeric */
    uint32_t nic_loss_ppm;
    uint32_t nic_jitter_p99_us;
    uint32_t nic_rxq_fill;
    uint32_t nic_txq_fill;

    uint32_t board_therm_state;
    uint32_t board_power_unstable; /* 0/1 */
    uint32_t vrm_temp_c_x10;
    uint32_t vrm_ripple_mv_x10;

    uint32_t budget_interactive_hint; /* 0/1 */
    uint32_t budget_cpu_pressure;
    uint32_t budget_mem_pressure;

    uint32_t link_path_state;
    uint32_t link_backend_active;
    uint32_t link_mode_active;
    uint32_t link_profile_effective;
    uint32_t link_constraint_flags;
    uint32_t link_reason_code;
    uint32_t link_global_health;

    uint16_t trusted_peer_count; /* root quick view */
} core0_inputs_t;

static cl_gate_state_t core0_eval_gates(const core0_inputs_t *in,
                                       const core0_wd_eval_t *wd,
                                       bool trust_active)
{
    cl_gate_state_t gs;
    gs.possible = 0;
    gs.effective = 0;

    /* possible: was physikalisch/logisch möglich ist.
     * In Endausbau: possible ist i.d.R. "alles" minus harte Plattform-Verbote.
     * Da wir hier keine Plattform-Heuristik/CPUID implementieren (HAL macht das),
     * setzen wir possible = 0 und lassen effective als Wahrheit wirken.
     * Monitor sieht: unknown -> conservative.
     */

    /* Watchdog */
    if (wd->state >= CL_WD_STALL) {
        gs.effective |= CL_GATE_WATCHDOG_TRIGGERED;
    }

    /* Interaktivität/Budget: Schutz des OS/Users */
    if (in->have_budget && in->budget_interactive_hint) {
        gs.effective |= CL_GATE_INTERACTIVE_ACTIVE;
    }
    if (in->have_budget) {
        /* Wenn Druck hoch ist: budget exceeded */
        if (in->budget_cpu_pressure >= 900 || in->budget_mem_pressure >= 900) {
            gs.effective |= CL_GATE_BUDGET_EXCEEDED;
        }
    }

    /* Thermik: konservativ – wenn throttling aktiv, mindestens SOFT */
    if (in->have_cpu) {
        if (in->cpu_throttling) {
            gs.effective |= CL_GATE_THERMAL_SOFT;
        }
        /* Optional: Temperatur heuristisch (x10 °C).
         * Ohne spezifizierte Schwellen darf CORE keine policy erfinden.
         * Wir benutzen daher nur eine sehr grobe, deterministische Schwelle,
         * die als "soft indicator" gilt:
         *   >= 900 (90.0°C) -> HARD
         *   >= 800 (80.0°C) -> SOFT
         * Diese Schwelle ist bewusst konservativ.
         */
        if (in->cpu_temp_c_x10 >= 900) gs.effective |= CL_GATE_THERMAL_HARD;
        else if (in->cpu_temp_c_x10 >= 800) gs.effective |= CL_GATE_THERMAL_SOFT;
    }

    /* NIC thermals / DOM: wenn NIC thermal_state nicht ok, setze SOFT */
    if (in->have_nic) {
        /* numeric state: keine Enum hier; wir interpretieren 0 als unknown/ok.
         * Jede non-zero state wird als "soft thermal" betrachtet.
         */
        if (in->nic_thermal_state != 0) {
            gs.effective |= CL_GATE_THERMAL_SOFT;
        }
        /* Queue pressure als Budget/Interactive proxy */
        if (in->nic_rxq_fill >= 950 || in->nic_txq_fill >= 950) {
            gs.effective |= CL_GATE_BUDGET_EXCEEDED;
        }
    }

    /* Board/VRM: Power instabil => HARD/VRM_LIMIT */
    if (in->have_board) {
        if (in->board_power_unstable) {
            gs.effective |= CL_GATE_POWER_HARD;
            gs.effective |= CL_GATE_VRM_LIMIT;
        }
        /* VRM ripple hoch -> soft power */
        if (in->vrm_ripple_mv_x10 >= 200) { /* 20.0mV ripple als konservativer Hinweis */
            gs.effective |= CL_GATE_POWER_SOFT;
        }
        /* VRM temp hoch -> thermal */
        if (in->vrm_temp_c_x10 >= 950) gs.effective |= CL_GATE_THERMAL_HARD;
        else if (in->vrm_temp_c_x10 >= 850) gs.effective |= CL_GATE_THERMAL_SOFT;
    }

    /* Trust gates: Default-deny ist physikalische Wahrheit (Security/Join).
     * - Wenn trust_active -> ACTIVE/ESTABLISHED.
     * - Sonst -> TRUST_NONE.
     */
    if (trust_active) {
        gs.effective |= CL_GATE_TRUST_ESTABLISHED;
        gs.effective |= CL_GATE_TRUST_ACTIVE;
    } else {
        gs.effective |= CL_GATE_TRUST_NONE;
    }

    /* Security Degraded: wenn Watchdog oder Trust fehlt => degraded */
    if (!trust_active || (gs.effective & CL_GATE_WATCHDOG_TRIGGERED)) {
        gs.effective |= CL_GATE_SECURITY_DEGRADED;
    }

    return gs;
}

/* -------------------------------------------------------------------------- */
/* Trust Ableitung (konservativ)                                              */
/* -------------------------------------------------------------------------- */

static bool core0_eval_trust_active(const cl_root_4096_t *root,
                                   const cl_toc_header_t *toc_hdr,
                                   const cl_toc_entry_t *toc_ent,
                                   uint8_t *base, size_t map_size)
{
    /* Quick-View: trusted_peer_count */
    const uint32_t tpc = atomic_load_explicit(&root->trusted_peer_count, memory_order_relaxed);
    if (tpc == 0) return false;

    /* Zusätzlich: Mesh Peer Segmente lesen (falls vorhanden) und prüfen, ob irgendein Peer
     * plausibel "trusted" ist (trust_state != 0).
     * Wir kennen die Enum-Werte nicht, daher minimal:
     *   trust_state != 0 gilt als "irgendein Trust-Level vorhanden".
     */
    const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_MESH_PEER_SEG_256);
    if (!e) return true; /* Quick-View reicht, wenn Segment fehlt */

    if (!core0_entry_readable(root, e)) return false;

    const cl_mesh_peer_seg_256_t *p = (const cl_mesh_peer_seg_256_t *)core0_seg_ptr(base, map_size, e);
    if (!p) return false;

    const uint32_t n = e->count;
    for (uint32_t i = 0; i < n; i++) {
        const uint32_t ts = atomic_load_explicit(&p[i].hot.trust_state, memory_order_relaxed);
        if (ts != 0) return true;
    }
    return false;
}

/* -------------------------------------------------------------------------- */
/* Service Heartbeat (CORE Slot 0)                                            */
/* -------------------------------------------------------------------------- */

static void core0_service_heartbeat(const cl_root_4096_t *root,
                                   const cl_toc_header_t *toc_hdr,
                                   cl_toc_entry_t *toc_ent,
                                   uint8_t *base, size_t map_size,
                                   uint64_t now_ns)
{
    (void)root;

    cl_toc_entry_t *e = core0_toc_find_entry_mut((cl_toc_header_t *)toc_hdr, toc_ent, (uint16_t)CL_SERVICE_SEG_256);
    if (!e) return;

    /* SERVICE ist resident/control, wird vom Supervisor initialisiert.
     * CORE schreibt nur last_heartbeat_ns.
     */
    if (!core0_entry_readable((const cl_root_4096_t *)root, e)) {
        /* Wenn epoch==0, darf CORE trotzdem schreiben? SSOT sagt: clinit setzt epoch=0,
         * CORE ist Publisher: wir publishten dieses Segment über epoch.
         * => Wir erlauben Schreiben, publishen danach.
         */
    }

    cl_service_seg_256_t *svc = (cl_service_seg_256_t *)core0_seg_ptr(base, map_size, e);
    if (!svc) return;

    /* Slot CORE0 = s0 in g1 */
    atomic_store_explicit(&svc->g1.s0.last_heartbeat_ns, now_ns, memory_order_relaxed);
    atomic_store_explicit(&svc->g1.s0.pid, (uint32_t)getpid(), memory_order_relaxed);
    atomic_store_explicit(&svc->g1.s0.running, 1u, memory_order_relaxed);

    const uint64_t cur = atomic_load_explicit((_Atomic(uint64_t) *)&e->epoch, memory_order_acquire);
    core0_publish_epoch(e, core0_next_epoch_u64(cur));
}

/* -------------------------------------------------------------------------- */
/* CORE Hauptauswertung + Publish                                              */
/* -------------------------------------------------------------------------- */

static void core0_tick(core0_map_t *m)
{
    uint8_t *base = m->base;
    const size_t map_size = m->size;

    cl_root_4096_t *root = core0_root_ptr(base);
    cl_toc_header_t *toc_hdr = core0_toc_hdr_ptr(base, root);
    cl_toc_entry_t  *toc_ent = core0_toc_entries_ptr(toc_hdr);

    const uint64_t now_ns = core0_now_ns_monotonic();
    if (now_ns == 0) return;

    /* ---- Inputs einsammeln (nur lesen; strikt epoch-gated) ---- */
    core0_inputs_t in;
    memset(&in, 0, sizeof(in));

    /* CPU */
    {
        const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_CPU_SEG_1024);
        if (e && core0_entry_readable(root, e)) {
            const cl_cpu_seg_1024_t *cpu = (const cl_cpu_seg_1024_t *)core0_seg_ptr(base, map_size, e);
            if (cpu) {
                in.have_cpu = true;
                in.cpu_temp_c_x10 = atomic_load_explicit(&cpu[0].hot_a.temp_c_x10, memory_order_relaxed);
                in.cpu_throttling = atomic_load_explicit(&cpu[0].hot_a.throttling, memory_order_relaxed);
                in.cpu_load_permille = atomic_load_explicit(&cpu[0].hot_a.load_permille, memory_order_relaxed);
            }
        }
    }

    /* NIC */
    {
        const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_NIC_SEG_512);
        if (e && core0_entry_readable(root, e)) {
            const cl_nic_seg_512_t *nic = (const cl_nic_seg_512_t *)core0_seg_ptr(base, map_size, e);
            if (nic) {
                in.have_nic = true;
                in.nic_rxq_fill = atomic_load_explicit(&nic[0].warm_a.rx_queue_fill_permille, memory_order_relaxed);
                in.nic_txq_fill = atomic_load_explicit(&nic[0].warm_a.tx_queue_fill_permille, memory_order_relaxed);
                in.nic_loss_ppm = atomic_load_explicit(&nic[0].warm_b.loss_ppm, memory_order_relaxed);
                in.nic_jitter_p99_us = atomic_load_explicit(&nic[0].warm_b.jitter_p99_us, memory_order_relaxed);
                in.nic_thermal_state = atomic_load_explicit(&nic[0].warm_b.thermal_state, memory_order_relaxed);
            }
        }
    }

    /* BOARD */
    {
        const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_BOARD_SEG_512);
        if (e && core0_entry_readable(root, e)) {
            const cl_board_seg_512_t *b = (const cl_board_seg_512_t *)core0_seg_ptr(base, map_size, e);
            if (b) {
                in.have_board = true;
                in.board_therm_state = atomic_load_explicit(&b[0].hot_a.board_therm_state, memory_order_relaxed);
                in.board_power_unstable = atomic_load_explicit(&b[0].hot_a.power_unstable, memory_order_relaxed);
                in.vrm_temp_c_x10 = atomic_load_explicit(&b[0].hot_a.vrm_temp_c_x10, memory_order_relaxed);
                in.vrm_ripple_mv_x10 = atomic_load_explicit(&b[0].hot_a.vrm_ripple_mv_x10, memory_order_relaxed);
            }
        }
    }

    /* BUDGET */
    {
        const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_BUDGET_SEG_256);
        if (e && core0_entry_readable(root, e)) {
            const cl_budget_seg_256_t *b = (const cl_budget_seg_256_t *)core0_seg_ptr(base, map_size, e);
            if (b) {
                in.have_budget = true;
                in.budget_interactive_hint = atomic_load_explicit(&b[0].hot.interactive_hint, memory_order_relaxed);
                in.budget_cpu_pressure = atomic_load_explicit(&b[0].hot.cpu_pressure_permille, memory_order_relaxed);
                in.budget_mem_pressure = atomic_load_explicit(&b[0].hot.mem_pressure_permille, memory_order_relaxed);
            }
        }
    }

    /* TIMEBASE */
    {
        const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_TIME_SEG_256);
        if (e && core0_entry_readable(root, e)) {
            const cl_time_seg_256_t *t = (const cl_time_seg_256_t *)core0_seg_ptr(base, map_size, e);
            if (t) {
                in.have_time = true;
                /* mono_now_ns steht im Segment; wir nutzen es hier nicht direkt (now_ns ist unsere Zeitbasis). */
            }
        }
    }

    /* LINK summary */
    {
        const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_LINK_SEG_256);
        if (e && core0_entry_readable(root, e)) {
            const cl_link_seg_256_t *l = (const cl_link_seg_256_t *)core0_seg_ptr(base, map_size, e);
            if (l) {
                in.have_link = true;
                in.link_path_state       = atomic_load_explicit(&l[0].hot.path_state, memory_order_relaxed);
                in.link_backend_active   = atomic_load_explicit(&l[0].hot.backend_active, memory_order_relaxed);
                in.link_mode_active      = atomic_load_explicit(&l[0].hot.mode_active, memory_order_relaxed);
                in.link_profile_effective= atomic_load_explicit(&l[0].hot.profile_effective, memory_order_relaxed);
                in.link_constraint_flags = atomic_load_explicit(&l[0].hot.constraint_flags, memory_order_relaxed);
                in.link_reason_code      = atomic_load_explicit(&l[0].hot.reason_code, memory_order_relaxed);
                in.link_global_health    = atomic_load_explicit(&l[0].hot.global_health, memory_order_relaxed);
            }
        }
    }

    /* Trusted peer count (root quick view) */
    in.trusted_peer_count = (uint16_t)atomic_load_explicit(&root->trusted_peer_count, memory_order_relaxed);

    /* WATCHDOG (CORE schreibt, aber liest auch zum Latching) */
    cl_watchdog_seg_256_t *wd = NULL;
    cl_toc_entry_t *wd_e = core0_toc_find_entry_mut(toc_hdr, toc_ent, (uint16_t)CL_WATCHDOG_SEG_256);
    if (wd_e) {
        wd = (cl_watchdog_seg_256_t *)core0_seg_ptr(base, map_size, wd_e);
        if (wd) in.have_watchdog = true;
    }

    /* ---- Trust evaluation ---- */
    const bool trust_active = core0_eval_trust_active(root, toc_hdr, toc_ent, base, map_size);

    /* ---- Watchdog evaluation (latching) ---- */
    core0_wd_eval_t wd_eval;
    memset(&wd_eval, 0, sizeof(wd_eval));
    if (wd) {
        /* CORE markiert eigenes Tick zuerst */
        atomic_store_explicit(&wd->hot_a.core_tick_ns, now_ns, memory_order_relaxed);

        wd_eval = core0_watchdog_eval(root, wd, toc_hdr, toc_ent, now_ns);

        /* schreibe latched state/reason/module */
        atomic_store_explicit(&wd->hot_b.wd_state, (uint32_t)wd_eval.state, memory_order_relaxed);
        atomic_store_explicit(&wd->hot_b.wd_reason, (uint32_t)wd_eval.reason, memory_order_relaxed);
        atomic_store_explicit(&wd->hot_b.last_stall_module, (uint32_t)wd_eval.module, memory_order_relaxed);

        /* restart_count_total / warm last_restart* werden NICHT von CORE inkrementiert hier
         * (das macht Supervisor/Restart-Mechanik). CORE setzt nur Diagnose/State.
         */

        /* Publish WD epoch (Cut-Point) */
        const uint64_t cur = atomic_load_explicit((_Atomic(uint64_t) *)&wd_e->epoch, memory_order_acquire);
        core0_publish_epoch(wd_e, core0_next_epoch_u64(cur));
    }

    /* ---- Gates evaluation ---- */
    const cl_gate_state_t gs = core0_eval_gates(&in, &wd_eval, trust_active);

    /* ---- Dataplane Viability (minimal, aus LINK summary) ----
     * CORE entscheidet NICHT Redirect, aber setzt GATES so, dass LINK safe cutover machen kann.
     * Hier: wenn LINK fehlt/UNINIT => dataplane verboten über TRUST_NONE/SECURITY_DEGRADED ohnehin.
     */
    const bool dataplane_ready = in.have_link && (in.link_global_health != 0);

    /* ---- Root Quick Views spiegeln (SSOT: Root ist Abkürzung, nicht zweite Wahrheit) ---- */
    atomic_store_explicit(&root->uptime_ns, now_ns, memory_order_relaxed);

    if (in.have_link) {
        atomic_store_explicit(&root->path_state,      in.link_path_state,       memory_order_relaxed);
        atomic_store_explicit(&root->backend_active,  in.link_backend_active,   memory_order_relaxed);
        atomic_store_explicit(&root->mode_active,     in.link_mode_active,      memory_order_relaxed);
        atomic_store_explicit(&root->profile_active,  in.link_profile_effective,memory_order_relaxed);

        atomic_store_explicit(&root->constraint_flags,in.link_constraint_flags, memory_order_relaxed);
        atomic_store_explicit(&root->reason_code,     in.link_reason_code,      memory_order_relaxed);
        atomic_store_explicit(&root->global_health,   in.link_global_health,    memory_order_relaxed);
    } else {
        /* Wenn kein Link-Input: lasse Root-Werte unverändert (keine willkürlichen Resets). */
    }

    /* rx_gate/tx_gate sind u32; wir spiegeln die unteren 32 Bits des effective Gate-Maskenworts. */
    atomic_store_explicit(&root->rx_gate, (uint32_t)(gs.effective & 0xFFFFFFFFu), memory_order_relaxed);
    atomic_store_explicit(&root->tx_gate, (uint32_t)(gs.effective & 0xFFFFFFFFu), memory_order_relaxed);

    /* ---- TOC per-entry gates setzen (Authority) ----
     * Policy:
     * - Für alle Entries: gates_effective = global effective
     * - gates_possible bleibt unverändert, außer wenn bisher 0 -> setze auf effective als "mindestens".
     * (possible ist physikalisch; wenn HAL keine possible liefert, bleibt es 0; wir fälschen nicht.)
     */
    for (uint32_t i = 0; i < toc_hdr->entry_count; i++) {
        /* gates_effective: immer spiegeln */
        toc_ent[i].gates_effective = gs.effective;

        /* gates_possible: wenn bereits gesetzt, respektieren; sonst konservativ = 0.
         * Optional: wenn du willst, kannst du hier "possible |= effective" machen.
         * Ich mache das nur, wenn möglich==0 und effective!=0, damit Monitor nicht komplett leer ist,
         * ohne "physik möglich" zu erfinden: effective ist ja bereits eine reale Schranke.
         */
        if (toc_ent[i].gates_possible == 0 && gs.effective != 0) {
            toc_ent[i].gates_possible = gs.effective;
        }
    }

    /* ---- Publish CORE-relevante Entries epoch bump ----
     * Endausbau-Cutpoint: CORE bump’t mindestens WATCHDOG + SERVICE (und optional TOC epoch).
     * Für Root gibt es kein epoch-Feld; Root ist atomisch via einzelne Felder.
     *
     * Zusätzlich: wir bumpen den TOC-Header epoch als "configuration/authority epoch".
     */
    {
        const uint64_t cur = toc_hdr->epoch;
        toc_hdr->epoch = core0_next_epoch_u64(cur);
    }

    /* ---- Service heartbeat publish ---- */
    core0_service_heartbeat(root, toc_hdr, toc_ent, base, map_size, now_ns);

    (void)dataplane_ready;
}

/* -------------------------------------------------------------------------- */
/* CLI / Main                                                                 */
/* -------------------------------------------------------------------------- */

static void core0_usage(FILE *f) {
    fprintf(f,
        "core0 (CommanderLink CORE0)\n"
        "Usage: core0 [--shm <name>] [--tick-ms <n>]\n"
        "Default shm=%s, tick-ms=%u\n",
        CL_CORE_SHM_NAME, (unsigned)CL_CORE_DEFAULT_TICK_MS);
}

int main(int argc, char **argv)
{
    const char *shm_name = CL_CORE_SHM_NAME;
    uint32_t tick_ms = CL_CORE_DEFAULT_TICK_MS;

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--shm") == 0 && i + 1 < argc) {
            shm_name = argv[++i];
        } else if (strcmp(argv[i], "--tick-ms") == 0 && i + 1 < argc) {
            tick_ms = (uint32_t)strtoul(argv[++i], NULL, 10);
            if (tick_ms == 0) tick_ms = CL_CORE_DEFAULT_TICK_MS;
        } else if (strcmp(argv[i], "--help") == 0 || strcmp(argv[i], "-h") == 0) {
            core0_usage(stdout);
            return 0;
        } else {
            core0_usage(stderr);
            return 2;
        }
    }

    (void)signal(SIGINT, core0_on_signal);
    (void)signal(SIGTERM, core0_on_signal);

    core0_map_t m;
    if (core0_map_open(&m, shm_name, (size_t)CL_ROOT_BYTES) != 0) {
        perror("core0: shm_open/map failed");
        return 1;
    }

    /* Minimal sanity: Root-Magic/Endian/Schema prüfen (FAILFAST nur wenn Flag gesetzt) */
    cl_root_4096_t *root = core0_root_ptr(m.base);

    if (root->root_magic != CL_ROOT_MAGIC_U32) {
        fprintf(stderr, "core0: root_magic mismatch (0x%08x)\n", root->root_magic);
        core0_map_close(&m);
        return 1;
    }
    if (root->endian_magic != CL_ENDIAN_MAGIC_U32) {
        fprintf(stderr, "core0: endian_magic mismatch (0x%08x)\n", root->endian_magic);
        core0_map_close(&m);
        return 1;
    }
    if (root->schema_version != CL_SCHEMA_VERSION_U32) {
        fprintf(stderr, "core0: schema_version mismatch (0x%08x)\n", root->schema_version);
        core0_map_close(&m);
        return 1;
    }

    /* FAILFAST_ABI: wenn abi_layout_checksum != expected und ihr expected habt, dann hier prüfen.
     * In deinem Schema steht CL_ABI_CHECKSUM_NONE; daher kein harter Vergleich.
     */
    if ((root->root_flags & CL_ROOT_FLAG_FAILFAST_ABI) != 0) {
        if (root->abi_layout_checksum != CL_ABI_CHECKSUM_NONE) {
            /* Wenn ihr später eine echte Checksum habt, wird hier verglichen. */
        }
    }

    while (!g_stop) {
        core0_tick(&m);

        struct timespec req;
        req.tv_sec  = (time_t)(tick_ms / 1000u);
        req.tv_nsec = (long)((tick_ms % 1000u) * 1000000u);
        (void)nanosleep(&req, NULL);
    }

    core0_map_close(&m);
    return 0;
}


<<< END FILE: ./src/core/core0.c

>>> START FILE: ./src/flow/flow0.c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>

#include "cl_runtime/cl_runtime.h"
#include "cl_runtime/cl_service_seg_256.h"

static uint64_t now_ns(void){ struct timespec ts; clock_gettime(CLOCK_MONOTONIC,&ts); return (uint64_t)ts.tv_sec*1000000000ull+(uint64_t)ts.tv_nsec; }

static int map_core_rw(void **out_base, size_t *out_sz){
    int fd=shm_open(CL_CORE_SHM_NAME,O_RDWR,0); if(fd<0) return -1;
    struct stat st; if(fstat(fd,&st)!=0){close(fd);return -2;} if(st.st_size<=0){close(fd);return -3;}
    void *p=mmap(NULL,(size_t)st.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); close(fd);
    if(p==MAP_FAILED) return -4; *out_base=p; *out_sz=(size_t)st.st_size; return 0;
}

static cl_service_seg_256_t* find_service_seg(void *core_base){
    cl_root_t *r=(cl_root_t*)core_base;
    cl_toc_t *toc=(cl_toc_t*)((uint8_t*)core_base+(size_t)r->toc_offset);
    for(uint32_t i=0;i<toc->header.entry_count && i<CL_TOC_MAX_ENTRIES;i++){
        cl_toc_entry_t *e=&toc->entries[i];
        if((uint16_t)e->type==(uint16_t)CL_SERVICE_SEG_256) return (cl_service_seg_256_t*)((uint8_t*)core_base+(size_t)e->offset_bytes);
    }
    return NULL;
}

static cl_service_slot_32_t* slot_for(cl_service_seg_256_t *svc, cl_service_id_t id){
    switch(id){
        case CL_SVC_CORE0: return &svc->g1.s0;
        case CL_SVC_HAL0: return &svc->g1.s1;
        case CL_SVC_LINK0: return &svc->g2.s2;
        case CL_SVC_FLOW0: return &svc->g2.s3;
        case CL_SVC_ORACLE0: return &svc->g3.s4;
        case CL_SVC_MONITOR: return &svc->g3.s5;
        default: return NULL;
    }
}

int main(void){
    void *core=NULL; size_t core_sz=0;
    int rc=map_core_rw(&core,&core_sz);
    if(rc!=0){ printf("flow0: cannot map core shm: rc=%d errno=%d (%s)\n",rc,errno,strerror(errno)); return 2; }
    cl_service_seg_256_t *svc=find_service_seg(core);
    if(!svc){ printf("flow0: service segment not found\n"); return 3; }
    cl_service_slot_32_t *sl=slot_for(svc,CL_SVC_FLOW0);
    if(!sl) return 4;

    for(;;){
        atomic_store(&sl->last_heartbeat_ns, now_ns());
        struct timespec ts={0}; ts.tv_nsec=250000000L; nanosleep(&ts,NULL);
    }
}


<<< END FILE: ./src/flow/flow0.c

>>> START FILE: ./src/hal/hal0.c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>

#include "cl_runtime/cl_runtime.h"
#include "cl_runtime/cl_service_seg_256.h"

static uint64_t now_ns(void){ struct timespec ts; clock_gettime(CLOCK_MONOTONIC,&ts); return (uint64_t)ts.tv_sec*1000000000ull+(uint64_t)ts.tv_nsec; }

static int map_core_rw(void **out_base, size_t *out_sz){
    int fd=shm_open(CL_CORE_SHM_NAME,O_RDWR,0); if(fd<0) return -1;
    struct stat st; if(fstat(fd,&st)!=0){close(fd);return -2;} if(st.st_size<=0){close(fd);return -3;}
    void *p=mmap(NULL,(size_t)st.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); close(fd);
    if(p==MAP_FAILED) return -4; *out_base=p; *out_sz=(size_t)st.st_size; return 0;
}

static cl_service_seg_256_t* find_service_seg(void *core_base){
    cl_root_t *r=(cl_root_t*)core_base;
    cl_toc_t *toc=(cl_toc_t*)((uint8_t*)core_base+(size_t)r->toc_offset);
    for(uint32_t i=0;i<toc->header.entry_count && i<CL_TOC_MAX_ENTRIES;i++){
        cl_toc_entry_t *e=&toc->entries[i];
        if((uint16_t)e->type==(uint16_t)CL_SERVICE_SEG_256) return (cl_service_seg_256_t*)((uint8_t*)core_base+(size_t)e->offset_bytes);
    }
    return NULL;
}

static cl_service_slot_32_t* slot_for(cl_service_seg_256_t *svc, cl_service_id_t id){
    switch(id){
        case CL_SVC_CORE0: return &svc->g1.s0;
        case CL_SVC_HAL0: return &svc->g1.s1;
        case CL_SVC_LINK0: return &svc->g2.s2;
        case CL_SVC_FLOW0: return &svc->g2.s3;
        case CL_SVC_ORACLE0: return &svc->g3.s4;
        case CL_SVC_MONITOR: return &svc->g3.s5;
        default: return NULL;
    }
}

int main(void){
    void *core=NULL; size_t core_sz=0;
    int rc=map_core_rw(&core,&core_sz);
    if(rc!=0){ printf("hal0: cannot map core shm: rc=%d errno=%d (%s)\n",rc,errno,strerror(errno)); return 2; }
    cl_service_seg_256_t *svc=find_service_seg(core);
    if(!svc){ printf("hal0: service segment not found\n"); return 3; }
    cl_service_slot_32_t *sl=slot_for(svc,CL_SVC_HAL0);
    if(!sl) return 4;

    for(;;){
        atomic_store(&sl->last_heartbeat_ns, now_ns());
        struct timespec ts={0}; ts.tv_nsec=250000000L; nanosleep(&ts,NULL);
    }
}


<<< END FILE: ./src/hal/hal0.c

>>> START FILE: ./src/link/link0.c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>

#include "cl_runtime/cl_runtime.h"
#include "cl_runtime/cl_service_seg_256.h"

static uint64_t now_ns(void){ struct timespec ts; clock_gettime(CLOCK_MONOTONIC,&ts); return (uint64_t)ts.tv_sec*1000000000ull+(uint64_t)ts.tv_nsec; }

static int map_core_rw(void **out_base, size_t *out_sz){
    int fd=shm_open(CL_CORE_SHM_NAME,O_RDWR,0); if(fd<0) return -1;
    struct stat st; if(fstat(fd,&st)!=0){close(fd);return -2;} if(st.st_size<=0){close(fd);return -3;}
    void *p=mmap(NULL,(size_t)st.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); close(fd);
    if(p==MAP_FAILED) return -4; *out_base=p; *out_sz=(size_t)st.st_size; return 0;
}

static cl_service_seg_256_t* find_service_seg(void *core_base){
    cl_root_t *r=(cl_root_t*)core_base;
    cl_toc_t *toc=(cl_toc_t*)((uint8_t*)core_base+(size_t)r->toc_offset);
    for(uint32_t i=0;i<toc->header.entry_count && i<CL_TOC_MAX_ENTRIES;i++){
        cl_toc_entry_t *e=&toc->entries[i];
        if((uint16_t)e->type==(uint16_t)CL_SERVICE_SEG_256) return (cl_service_seg_256_t*)((uint8_t*)core_base+(size_t)e->offset_bytes);
    }
    return NULL;
}

static cl_service_slot_32_t* slot_for(cl_service_seg_256_t *svc, cl_service_id_t id){
    switch(id){
        case CL_SVC_CORE0: return &svc->g1.s0;
        case CL_SVC_HAL0: return &svc->g1.s1;
        case CL_SVC_LINK0: return &svc->g2.s2;
        case CL_SVC_FLOW0: return &svc->g2.s3;
        case CL_SVC_ORACLE0: return &svc->g3.s4;
        case CL_SVC_MONITOR: return &svc->g3.s5;
        default: return NULL;
    }
}

int main(void){
    void *core=NULL; size_t core_sz=0;
    int rc=map_core_rw(&core,&core_sz);
    if(rc!=0){ printf("link0: cannot map core shm: rc=%d errno=%d (%s)\n",rc,errno,strerror(errno)); return 2; }
    cl_service_seg_256_t *svc=find_service_seg(core);
    if(!svc){ printf("link0: service segment not found\n"); return 3; }
    cl_service_slot_32_t *sl=slot_for(svc,CL_SVC_LINK0);
    if(!sl) return 4;

    for(;;){
        atomic_store(&sl->last_heartbeat_ns, now_ns());
        struct timespec ts={0}; ts.tv_nsec=250000000L; nanosleep(&ts,NULL);
    }
}


<<< END FILE: ./src/link/link0.c

>>> START FILE: ./src/monitor/.nfs.8180f1a2.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.8180f1a2.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.818142e8.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.818142e8.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8182daea.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.8182daea.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.81870104.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_YELLOW, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.81870104.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.81876a53.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLUE, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_YELLOW, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.81876a53.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8187d662.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_YELLOW, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.8187d662.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8187fa1d.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_YELLOW, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.8187fa1d.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8188f583.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.8188f583.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.81895f53.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.81895f53.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8189ddaa.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.8189ddaa.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.818cfa69.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.818cfa69.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.818d2fcc.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.818d2fcc.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.818d72b1.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.818d72b1.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.818dc014.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.818dc014.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.818e1f1d.5aaa4.4
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>

#include "monitor_curses.h"
#include "monitor_ui.h"
#include "tabs.h"

/* State Definitions */
typedef enum {
    TAB_DASHBOARD = 0,
    TAB_CPU,
    TAB_MEM,
    /* ... weitere ... */
    TAB_COUNT
} AppTab;

int main(void) {
    ui_init();

    int running = 1;
    AppTab current_tab = TAB_DASHBOARD;
    int ch;

    while (running) {
        /* 1. Global UI zeichnen */
        ui_draw_screen_bg();
        ui_draw_header("CommanderLink - Monitor v0.1", 
                       "F1:Dash  F2:CPU  F3:Mem  F10:Quit");
        
        /* 2. Aktiven Tab zeichnen */
        int h = getmaxy(stdscr);
        int w = getmaxx(stdscr);
        
        switch (current_tab) {
            case TAB_DASHBOARD:
                tab_dashboard_draw(h, w);
                break;
            default:
                mvprintw(h/2, w/2 - 10, "Tab not implemented yet.");
                break;
        }

        /* 3. Statusbar update */
        ui_draw_statusbar("Status: CONNECTED", "Mode: VIEW");

        refresh();

        /* 4. Input Loop */
        ch = getch();
        switch (ch) {
            case KEY_F(1): current_tab = TAB_DASHBOARD; break;
            case KEY_F(2): current_tab = TAB_CPU; break;
            case KEY_F(3): current_tab = TAB_MEM; break;
            case KEY_F(10): running = 0; break;
            case 27: /* ESC */ running = 0; break;
            
            default:
                /* Input an den Tab weiterleiten */
                if (current_tab == TAB_DASHBOARD) {
                    tab_dashboard_input(ch);
                }
                break;
        }
        
        /* Kurzes Sleep um CPU zu sparen (Monitor ist passiv) */
        /* usleep(10000); -> ncurses getch() blockt eh standardmäßig oder hat timeout */
    }

    ui_shutdown();
    printf("[Monitor] Terminated gracefully.\n");
    return 0;
}

<<< END FILE: ./src/monitor/.nfs.818e1f1d.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8190a368.5aaa4.4
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "monitor_curses.h"
#include "monitor_ui.h"
#include "monitor_state.h" // NEU
#include "monitor_input.h" // NEU
#include "tabs.h"

int main(void) {
    ui_init();
    
    /* State holen */
    cl_monitor_state_t *st = monitor_state();

    while (st->running) {
        /* 1. Global UI & Header */
        ui_draw_screen_bg();
        
        /* Dynamischer Header je nach Tab */
        const char *title = "CommanderLink Monitor";
        if (st->active_tab == TAB_DASHBOARD) title = "CL - Dashboard";
        if (st->active_tab == TAB_CPU)       title = "CL - CPU Core Physics";
        if (st->active_tab == TAB_MEM)       title = "CL - Memory Matrix";

        ui_draw_header(title, "TAB/Arrows: Switch   F1:Dash F2:CPU F3:Mem   F10:Quit");
        
        /* 2. Aktiven Tab zeichnen */
        int h = getmaxy(stdscr);
        int w = getmaxx(stdscr);
        
        switch (st->active_tab) {
            case TAB_DASHBOARD:
                tab_dashboard_draw(h, w);
                break;
            case TAB_CPU:
                mvprintw(h/2, w/2 - 10, "[ CPU TAB PLACEHOLDER ]");
                break;
            case TAB_MEM:
                mvprintw(h/2, w/2 - 10, "[ MEM TAB PLACEHOLDER ]");
                break;
            default:
                break;
        }

        /* 3. Statusbar */
        ui_draw_statusbar("Status: CONNECTED", "Mode: VIEW");

        refresh();

        /* 4. Input an Handler delegieren */
        int ch = getch();
        monitor_handle_input(ch);
    }

    ui_shutdown();
    return 0;
}

<<< END FILE: ./src/monitor/.nfs.8190a368.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8197ae7d.5aaa4.4
#ifndef CL_MONITOR_UI_H
#define CL_MONITOR_UI_H

#include "monitor_curses.h"

/* Farben (TVision Style) */
#define CL_COLOR_BG       1  /* Blau / Weiß */
#define CL_COLOR_TITLE    2  /* Schwarz / Cyan */
#define CL_COLOR_STATUS   3  /* Schwarz / Grau */
#define CL_COLOR_TEXT     4  /* Weiß / Blau */
#define CL_COLOR_ALERT    5  /* Weiß / Rot */

void ui_init(void);
void ui_shutdown(void);

/* Zeichen-Primitive */
void ui_draw_screen_bg(void);
void ui_draw_header(const char *title, const char *subtitle);
void ui_draw_statusbar(const char *status_left, const char *status_right);
void ui_draw_box(int y, int x, int h, int w, const char *title);
void ui_draw_label_value(int y, int x, const char *label, const char *value);

#endif

<<< END FILE: ./src/monitor/.nfs.8197ae7d.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8197e4da.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_BLACK, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.8197e4da.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.819d3e2f.5aaa4.4
#ifndef CL_MONITOR_STATE_H
#define CL_MONITOR_STATE_H

typedef enum {
    TAB_DASHBOARD = 0,
    TAB_CPU,
    TAB_MEM,
    /* Hier kommen später TAB_NIC, TAB_ZFS etc. dazu */
    TAB_COUNT
} cl_mon_tab_t;

/* Singleton State Accessor */
typedef struct {
    cl_mon_tab_t active_tab;
    int running;
} cl_monitor_state_t;

cl_monitor_state_t* monitor_state(void);

#endif

<<< END FILE: ./src/monitor/.nfs.819d3e2f.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.819db378.5aaa4.4
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h> /* Für snprintf */

#include "monitor_curses.h"
#include "monitor_ui.h"
#include "monitor_state.h"
#include "monitor_input.h"
#include "tabs.h"

int main(void) {
    ui_init();
    
    /* State holen */
    cl_monitor_state_t *st = monitor_state();

    while (st->running) {
        /* 1. Global UI & Header */
        ui_draw_screen_bg();
        
        /* A. Titel-Logik: "CommanderLink Monitor - [TABNAME]" */
        char title_buf[128];
        const char *tab_name = "Unknown";
        
        switch (st->active_tab) {
            case TAB_DASHBOARD: tab_name = "Dashboard"; break;
            case TAB_CPU:       tab_name = "CPU Core Physics"; break;
            case TAB_MEM:       tab_name = "Memory Matrix"; break;
            default:            tab_name = "Section"; break;
        }
        
        snprintf(title_buf, sizeof(title_buf), "CommanderLink Monitor - %s", tab_name);

        /* B. Header zeichnen: Titel + F-Tasten direkt darunter */
        ui_draw_header(title_buf, " F1:Dash  F2:CPU  F3:Mem  F10:Quit");
        
        /* 2. Aktiven Tab zeichnen */
        int h = getmaxy(stdscr);
        int w = getmaxx(stdscr);
        
        /* Content-Bereich etwas kleiner machen, da Header 2 Zeilen nutzt */
        /* Die ui_draw_header nimmt Zeile 0 und 1. Content startet ab Zeile 2 */
        
        switch (st->active_tab) {
            case TAB_DASHBOARD:
                tab_dashboard_draw(h, w);
                break;
            case TAB_CPU:
                /* Platzhalter bis Tab implementiert ist */
                ui_draw_box(h/2 - 2, w/2 - 20, 5, 40, "Info");
                mvprintw(h/2, w/2 - 18, "CPU Tab implementing...");
                break;
            case TAB_MEM:
                ui_draw_box(h/2 - 2, w/2 - 20, 5, 40, "Info");
                mvprintw(h/2, w/2 - 18, "Memory Tab implementing...");
                break;
            default:
                break;
        }

        /* 3. Statusbar unten: Navigation links, Status rechts */
        /* Hier kommt deine gewünschte Änderung rein */
        ui_draw_statusbar(" TAB/Arrows: Switch Tab | ENTER: Select", "Status: CONNECTED");

        refresh();

        /* 4. Input an Handler delegieren */
        int ch = getch();
        monitor_handle_input(ch);
    }

    ui_shutdown();
    return 0;
}

<<< END FILE: ./src/monitor/.nfs.819db378.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.81d5f1a7.69804.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_BLACK, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

void ui_draw_progressbar(int y, int x, int width, int permille, int color_pair) {
    if (width < 3) return;
    
    int fill_w = (width * permille) / 1000;
    if (fill_w > width) fill_w = width;
    
    attron(COLOR_PAIR(color_pair));
    
    /* Rahmen optional oder direkt Balken */
    mvprintw(y, x, "[");
    for (int i = 0; i < width - 2; i++) {
        if (i < fill_w) addch('|'); // Oder ACS_BLOCK für vollen Block
        else addch('.');
    }
    mvprintw(y, x + width - 1, "]");
    
    /* Prozentzahl in die Mitte (optional) */
    char buf[16];
    snprintf(buf, sizeof(buf), " %3d%% ", permille / 10);
    if ((int)strlen(buf) < width - 4) {
        mvprintw(y, x + (width/2) - (strlen(buf)/2), "%s", buf);
    }
    
    attroff(COLOR_PAIR(color_pair));
}

<<< END FILE: ./src/monitor/.nfs.81d5f1a7.69804.4

>>> START FILE: ./src/monitor/.nfs.81d702e1.69804.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLACK);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_BLACK, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

void ui_draw_progressbar(int y, int x, int width, int permille, int color_pair) {
    if (width < 3) return;
    
    int fill_w = (width * permille) / 1000;
    if (fill_w > width) fill_w = width;
    
    attron(COLOR_PAIR(color_pair));
    
    /* Rahmen optional oder direkt Balken */
    mvprintw(y, x, "[");
    for (int i = 0; i < width - 2; i++) {
        if (i < fill_w) addch('|'); // Oder ACS_BLOCK für vollen Block
        else addch('.');
    }
    mvprintw(y, x + width - 1, "]");
    
    /* Prozentzahl in die Mitte (optional) */
    char buf[16];
    snprintf(buf, sizeof(buf), " %3d%% ", permille / 10);
    if ((int)strlen(buf) < width - 4) {
        mvprintw(y, x + (width/2) - (strlen(buf)/2), "%s", buf);
    }
    
    attroff(COLOR_PAIR(color_pair));
}

<<< END FILE: ./src/monitor/.nfs.81d702e1.69804.4

>>> START FILE: ./src/monitor/.nfs.81f6b82b.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.81f6b82b.75fb4.4

>>> START FILE: ./src/monitor/.nfs.81f7161b.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.81f7161b.75fb4.4

>>> START FILE: ./src/monitor/.nfs.81f7495c.75fb4.4
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>      /* shm_open */
#include <sys/mman.h>   /* mmap */
#include <sys/stat.h>
#include <errno.h>

#include "monitor_curses.h"
#include "monitor_ui.h"
#include "monitor_state.h"
#include "monitor_input.h"
#include "tabs.h"

/* HIER ist der Name definiert: */
#include "../../include/cl_runtime/cl_shm_layout.h"

/* Helper: SHM verbinden */
static void attach_shm(cl_monitor_state_t *st) {
    /* Benutzt "/cl_core_root" aus dem Header */
    int fd = shm_open(CL_CORE_SHM_NAME, O_RDONLY, 0);
    if (fd == -1) {
        st->core_base = NULL;
        st->core_size = 0;
        return;
    }

    struct stat sb;
    if (fstat(fd, &sb) == -1) {
        close(fd);
        return;
    }

    st->core_size = (size_t)sb.st_size;
    st->core_base = mmap(NULL, st->core_size, PROT_READ, MAP_SHARED, fd, 0);
    close(fd);

    if (st->core_base == MAP_FAILED) {
        st->core_base = NULL;
        st->core_size = 0;
    }
}

static void detach_shm(cl_monitor_state_t *st) {
    if (st->core_base && st->core_base != MAP_FAILED) {
        munmap(st->core_base, st->core_size);
    }
}

int main(void) {
    cl_monitor_state_t *st = monitor_state();
    
    attach_shm(st); /* Versucht Verbindung */

    ui_init();

    while (st->running) {
        ui_draw_screen_bg();
        
        char title_buf[128];
        const char *tab_name = "Unknown";
        
        switch (st->active_tab) {
            case TAB_DASHBOARD: tab_name = "Dashboard"; break;
            case TAB_CPU:       tab_name = "CPU Core Physics"; break;
            case TAB_MEM:       tab_name = "Memory Matrix"; break;
            default:            tab_name = "Section"; break;
        }
        
        snprintf(title_buf, sizeof(title_buf), "CommanderLink Monitor - %s", tab_name);
        ui_draw_header(title_buf, " F1:Dash  F2:CPU  F3:Mem  F10:Quit");
        
        int h = getmaxy(stdscr);
        int w = getmaxx(stdscr);
        
        switch (st->active_tab) {
            case TAB_DASHBOARD:
                tab_dashboard_draw(h, w);
                break;
            case TAB_CPU:
                ui_draw_box(h/2 - 2, w/2 - 20, 5, 40, "Info");
                mvprintw(h/2, w/2 - 18, "CPU Tab implementing...");
                break;
            case TAB_MEM:
                ui_draw_box(h/2 - 2, w/2 - 20, 5, 40, "Info");
                mvprintw(h/2, w/2 - 18, "Memory Tab implementing...");
                break;
            default: break;
        }

        /* Statusbar mit SHM Info */
        char status_right[64];
        if (st->core_base) {
            snprintf(status_right, sizeof(status_right), "SHM: ONLINE (%zu B)", st->core_size);
        } else {
            snprintf(status_right, sizeof(status_right), "SHM: WAIT (%s)", CL_CORE_SHM_NAME);
        }
        
        ui_draw_statusbar(" TAB/Arrows: Switch Tab | ENTER: Select", status_right);

        refresh();

        int ch = getch();
        monitor_handle_input(ch);
    }

    ui_shutdown();
    detach_shm(st);
    
    return 0;
}

<<< END FILE: ./src/monitor/.nfs.81f7495c.75fb4.4

>>> START FILE: ./src/monitor/monitor_curses.h
#ifndef CL_MONITOR_CURSES_H
#define CL_MONITOR_CURSES_H

#if defined(__sun)
/* OmniOS/illumos: ncurses header is available as ncurses/ncurses.h -> curses.h */
  #include <ncurses/ncurses.h>
#else
  /* Linux + BSD */
  #include <ncurses.h>
#endif

#endif


<<< END FILE: ./src/monitor/monitor_curses.h

>>> START FILE: ./src/monitor/monitor_input.c
#include "monitor_curses.h" // Für Key-Definitionen
#include "monitor_state.h"
#include "tabs.h"

void monitor_handle_input(int key) {
    cl_monitor_state_t *st = monitor_state();

    switch (key) {
        /* --- GLOBAL NAVIGATION --- */
        
        /* TAB oder RECHTS -> Nächster Tab */
        case '\t': 
        case KEY_RIGHT:
            st->active_tab = (st->active_tab + 1) % TAB_COUNT;
            break;

        /* SHIFT+TAB (Backtab) oder LINKS -> Vorheriger Tab */
        case KEY_BTAB: // Shift-Tab (wird von vielen Terminals unterstützt)
        case KEY_LEFT:
            /* Trick für Modulo mit negativen Zahlen in C: + COUNT addieren */
            st->active_tab = (st->active_tab - 1 + TAB_COUNT) % TAB_COUNT;
            break;

        /* F-Keys direkt */
        case KEY_F(1): st->active_tab = TAB_DASHBOARD; break;
        case KEY_F(2): st->active_tab = TAB_CPU; break;
        case KEY_F(3): st->active_tab = TAB_MEM; break;
        
        case KEY_F(10): 
        case 27: /* ESC */
            st->running = 0; 
            break;

        /* --- CONTENT PASS-THROUGH --- */
        default:
            /* Input an den aktiven Tab weiterreichen (z.B. für Scrollen in Listen) */
            if (st->active_tab == TAB_DASHBOARD) {
                tab_dashboard_input(key);
            }
            break;
    }
}

<<< END FILE: ./src/monitor/monitor_input.c

>>> START FILE: ./src/monitor/monitor_input.h
#ifndef CL_MONITOR_INPUT_H
#define CL_MONITOR_INPUT_H

void monitor_handle_input(int key);

#endif

<<< END FILE: ./src/monitor/monitor_input.h

>>> START FILE: ./src/monitor/monitor_shm.c
#define _POSIX_C_SOURCE 200809L
#include "monitor_shm.h"
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

void mon_shm_connect(cl_monitor_state_t *st) {
    /* Reset */
    st->core_base = NULL;
    st->core_size = 0;

    int fd = shm_open(CL_CORE_SHM_NAME, O_RDONLY, 0);
    if (fd == -1) return; 

    struct stat sb;
    if (fstat(fd, &sb) == -1) { close(fd); return; }

    void *map = mmap(NULL, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
    close(fd);

    if (map == MAP_FAILED) return;

    if (sb.st_size < sizeof(cl_root_4096_t)) {
        munmap(map, sb.st_size);
        return;
    }

    st->core_base = map;
    st->core_size = (size_t)sb.st_size;
}

void mon_shm_disconnect(cl_monitor_state_t *st) {
    if (st->core_base && st->core_base != MAP_FAILED) {
        munmap(st->core_base, st->core_size);
    }
    st->core_base = NULL;
    st->core_size = 0;
}

const cl_root_4096_t* mon_get_root(cl_monitor_state_t *st) {
    if (!st->core_base) return NULL;
    const cl_root_4096_t *r = (const cl_root_4096_t*)st->core_base;
    if (r->root_magic != CL_ROOT_MAGIC_U32) return NULL;
    return r;
}

const cl_toc_t* mon_get_toc(cl_monitor_state_t *st, const cl_root_4096_t *root) {
    if (!root) return NULL;
    if (root->toc_offset >= st->core_size) return NULL;
    if (root->toc_offset + sizeof(cl_toc_header_t) > st->core_size) return NULL;

    const cl_toc_t *toc = (const cl_toc_t*)((const uint8_t*)st->core_base + root->toc_offset);
    
    /* Grober Bounds Check für den ganzen TOC */
    size_t toc_min_size = sizeof(cl_toc_header_t) + (toc->header.entry_count * sizeof(cl_toc_entry_t));
    if (root->toc_offset + toc_min_size > st->core_size) return NULL;

    return toc;
}

const cl_toc_entry_t* mon_find_entry(cl_monitor_state_t *st, const cl_toc_t *toc, uint16_t seg_type) {
    (void)st;
    if (!toc) return NULL;
    for (uint32_t i = 0; i < toc->header.entry_count; i++) {
        if (toc->entries[i].type == seg_type) return &toc->entries[i];
    }
    return NULL;
}

const void* mon_map_segment(cl_monitor_state_t *st, const cl_toc_entry_t *e, uint32_t idx) {
    if (!st->core_base || !e) return NULL;
    if (idx >= e->count) return NULL;

    uint64_t start = e->offset_bytes + (idx * (uint64_t)e->stride_bytes);
    if (start + e->stride_bytes > st->core_size) return NULL;

    return (const void*)((const uint8_t*)st->core_base + start);
}

<<< END FILE: ./src/monitor/monitor_shm.c

>>> START FILE: ./src/monitor/monitor_shm.h
#ifndef CL_MONITOR_SHM_H
#define CL_MONITOR_SHM_H

#include <stdint.h>
#include "monitor_state.h"

/* Runtime Headers */
#include "../../include/cl_runtime/cl_shm_layout.h"
#include "../../include/cl_runtime/cl_toc.h"

void mon_shm_connect(cl_monitor_state_t *st);
void mon_shm_disconnect(cl_monitor_state_t *st);

const cl_root_4096_t* mon_get_root(cl_monitor_state_t *st);
const cl_toc_t* mon_get_toc(cl_monitor_state_t *st, const cl_root_4096_t *root);
const cl_toc_entry_t* mon_find_entry(cl_monitor_state_t *st, const cl_toc_t *toc, uint16_t seg_type);
const void* mon_map_segment(cl_monitor_state_t *st, const cl_toc_entry_t *e, uint32_t idx);

#endif

<<< END FILE: ./src/monitor/monitor_shm.h

>>> START FILE: ./src/monitor/monitor_state.c
#include "monitor_state.h"

static cl_monitor_state_t g_state = {
    .active_tab = TAB_DASHBOARD,
    .running = 1
};

cl_monitor_state_t* monitor_state(void) {
    return &g_state;
}

<<< END FILE: ./src/monitor/monitor_state.c

>>> START FILE: ./src/monitor/monitor_state.h
#ifndef CL_MONITOR_STATE_H
#define CL_MONITOR_STATE_H

#include <stddef.h> /* size_t */

typedef enum {
    TAB_DASHBOARD = 0,
    TAB_CPU,
    TAB_MEM,
    TAB_COUNT
} cl_mon_tab_t;

typedef struct {
    cl_mon_tab_t active_tab;
    int running;
    
    /* Der Live-Pointer ins SHM */
    void *core_base;    
    size_t core_size;

} cl_monitor_state_t;

cl_monitor_state_t* monitor_state(void);

#endif

<<< END FILE: ./src/monitor/monitor_state.h

>>> START FILE: ./src/monitor/monitor_ui.c
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_BLACK, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

void ui_draw_progressbar(int y, int x, int width, int permille, int color_pair) {
    if (width < 3) return;
    
    int fill_w = (width * permille) / 1000;
    if (fill_w > width) fill_w = width;
    
    attron(COLOR_PAIR(color_pair));
    
    /* Rahmen optional oder direkt Balken */
    mvprintw(y, x, "[");
    for (int i = 0; i < width - 2; i++) {
        if (i < fill_w) addch('|'); // Oder ACS_BLOCK für vollen Block
        else addch('.');
    }
    mvprintw(y, x + width - 1, "]");
    
    /* Prozentzahl in die Mitte (optional) */
    char buf[16];
    snprintf(buf, sizeof(buf), " %3d%% ", permille / 10);
    if ((int)strlen(buf) < width - 4) {
        mvprintw(y, x + (width/2) - (strlen(buf)/2), "%s", buf);
    }
    
    attroff(COLOR_PAIR(color_pair));
}

<<< END FILE: ./src/monitor/monitor_ui.c

>>> START FILE: ./src/monitor/monitor_ui.h
#ifndef CL_MONITOR_UI_H
#define CL_MONITOR_UI_H

#include "monitor_curses.h"

/* Farben (TVision Style) */
#define CL_COLOR_BG       1  /* Blau / Weiß */
#define CL_COLOR_TITLE    2  /* Schwarz / Cyan */
#define CL_COLOR_STATUS   3  /* Schwarz / Grau */
#define CL_COLOR_TEXT     4  /* Weiß / Blau */
#define CL_COLOR_ALERT    5  /* Weiß / Rot */

void ui_init(void);
void ui_shutdown(void);

/* Zeichen-Primitive */
void ui_draw_screen_bg(void);
void ui_draw_header(const char *title, const char *subtitle);
void ui_draw_statusbar(const char *status_left, const char *status_right);
void ui_draw_box(int y, int x, int h, int w, const char *title);
void ui_draw_label_value(int y, int x, const char *label, const char *value);
void ui_draw_progressbar(int y, int x, int width, int permille, int color_pair);

#endif

<<< END FILE: ./src/monitor/monitor_ui.h

>>> START FILE: ./src/monitor/monitor.c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include "monitor_curses.h"
#include "monitor_ui.h"
#include "monitor_state.h"
#include "monitor_input.h"
#include "monitor_shm.h" /* WICHTIG: Neue API */
#include "tabs.h"

int main(void) {
    cl_monitor_state_t *st = monitor_state();
    
    /* Neue API Verbindung */
    mon_shm_connect(st);

    ui_init();

    while (st->running) {
        ui_draw_screen_bg();
        
        char title_buf[128];
        const char *tab_name = "Unknown";
        switch (st->active_tab) {
            case TAB_DASHBOARD: tab_name = "Dashboard"; break;
            case TAB_CPU:       tab_name = "CPU Core Physics"; break;
            case TAB_MEM:       tab_name = "Memory Matrix"; break;
            default:            tab_name = "Section"; break;
        }
        snprintf(title_buf, sizeof(title_buf), "CommanderLink Monitor - %s", tab_name);
        ui_draw_header(title_buf, " F1:Dash  F2:CPU  F3:Mem  F10:Quit");
        
        int h = getmaxy(stdscr);
        int w = getmaxx(stdscr);
        
        /* Zeichnen */
        switch (st->active_tab) {
            case TAB_DASHBOARD: tab_dashboard_draw(h, w); break;
            case TAB_CPU:       /* Placeholder oder Implementierung */ break;
            case TAB_MEM:       /* Placeholder */ break;
            default: break;
        }

        /* Statusbar & Reconnect Logic */
        char status_right[64];
        if (st->core_base) {
            snprintf(status_right, sizeof(status_right), "SHM: ONLINE (%zu B)", st->core_size);
        } else {
            snprintf(status_right, sizeof(status_right), "SHM: SEARCHING...");
            mon_shm_connect(st); /* Auto-Reconnect Versuch jeden Frame */
        }
        
        ui_draw_statusbar(" TAB/Arrows: Switch Tab | ENTER: Select", status_right);

        refresh();
        monitor_handle_input(getch());
    }

    ui_shutdown();
    mon_shm_disconnect(st);
    
    return 0;
}

<<< END FILE: ./src/monitor/monitor.c

>>> START FILE: ./src/monitor/tabs.h
#ifndef CL_TABS_H
#define CL_TABS_H

#include "monitor_curses.h"

/* Jeder Tab muss diese Signatur haben */
typedef void (*tab_draw_fn)(int h, int w);
typedef void (*tab_input_fn)(int key);

/* Dashboard Tab (Demo) */
void tab_dashboard_draw(int h, int w);
void tab_dashboard_input(int key);

#endif

<<< END FILE: ./src/monitor/tabs.h

>>> START FILE: ./src/monitor/tabs/tab_dashboard.c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <math.h>

#include "../monitor_ui.h"
#include "../monitor_curses.h"
#include "../tabs.h"
#include "../monitor_state.h"
#include "../monitor_shm.h" // Unsere neue SSOT API

/* Runtime Headers für die Struct-Casts */
#include "../../../include/cl_runtime/cl_seg_cpu_1024.h"
#include "../../../include/cl_runtime/cl_seg_mem_256.h"
#include "../../../include/cl_runtime/cl_seg_dma_4096.h"
#include "../../../include/cl_runtime/cl_seg_zfs_4096.h"

/* --- Helpers --- */

static void fmt_size(char *buf, size_t sz, uint64_t bytes) {
    const double GiB = 1024.0 * 1024.0 * 1024.0;
    const double MiB = 1024.0 * 1024.0;
    
    if (bytes >= GiB) snprintf(buf, sz, "%.2f GiB", (double)bytes / GiB);
    else if (bytes >= MiB) snprintf(buf, sz, "%.2f MiB", (double)bytes / MiB);
    else snprintf(buf, sz, "%" PRIu64 " B", bytes);
}

static void fmt_time(char *buf, size_t sz, uint64_t ns) {
    uint64_t s = ns / 1000000000ULL;
    uint32_t h = s / 3600;
    uint32_t m = (s % 3600) / 60;
    uint32_t sec = s % 60;
    snprintf(buf, sz, "%02u:%02u:%02u", h, m, sec);
}

/* --- Drawing --- */

void tab_dashboard_draw(int h, int w) {
    cl_monitor_state_t *st = monitor_state();

    /* 1. SSOT: Root holen */
    const cl_root_4096_t *root = mon_get_root(st);
    if (!root) {
        ui_draw_box(h/2-2, w/2-20, 5, 40, "OFFLINE");
        mvprintw(h/2, w/2-15, "Waiting for Shared Memory...");
        return;
    }

    /* 2. SSOT: TOC holen */
    const cl_toc_t *toc = mon_get_toc(st, root);
    if (!toc) {
        ui_draw_box(h/2-2, w/2-20, 5, 40, "ERROR");
        mvprintw(h/2, w/2-15, "TOC Integrity Check Failed");
        return;
    }

    /* 3. Layout Grid berechnen */
    int col_width = (w / 2) - 2;
    int col2_x = col_width + 4;
    
    /* --- SECTION: GLOBAL HEALTH (Oben) --- */
    ui_draw_box(2, 2, 5, w-4, "System Health");
    
    char tbuf[64];
    fmt_time(tbuf, sizeof(tbuf), atomic_load(&root->uptime_ns));
    ui_draw_label_value(4, 4, "Uptime", tbuf);

    uint64_t seq = atomic_load(&root->seq_cnt);
    snprintf(tbuf, sizeof(tbuf), "%" PRIu64, seq);
    ui_draw_label_value(4, 30, "Heartbeat", tbuf);

    uint32_t rx = atomic_load(&root->rx_gate);
    uint32_t tx = atomic_load(&root->tx_gate);
    
    attron(COLOR_PAIR(CL_COLOR_TEXT));
    mvprintw(4, 55, "GATES: RX[%c] TX[%c]", 
             rx ? 'X' : 'O', 
             tx ? 'X' : 'O');
    attroff(COLOR_PAIR(CL_COLOR_TEXT));


    /* --- SECTION: COMPUTE UNIT (Links) --- */
    ui_draw_box(7, 2, 14, col_width, "Compute Unit (CPU)");
    
    const cl_toc_entry_t *e_cpu = mon_find_entry(st, toc, CL_CPU_SEG_1024);
    if (e_cpu) {
        uint32_t count = e_cpu->count;
        uint64_t load_sum = 0;
        uint64_t temp_sum = 0;
        char model[64] = "Unknown";

        /* Aggregate Stats */
        for (uint32_t i=0; i<count; i++) {
            const cl_cpu_seg_1024_t *cpu = (const cl_cpu_seg_1024_t*)mon_map_segment(st, e_cpu, i);
            if (cpu) {
                load_sum += atomic_load(&cpu->hot_a.load_permille);
                temp_sum += atomic_load(&cpu->hot_a.temp_c_x10);
                if (i==0) {
                     snprintf(model, sizeof(model), "%s %s", 
                        cpu->cold_b.vendor_str, cpu->cold_b.model_str_a);
                }
            }
        }
        
        uint32_t avg_load = (count > 0) ? (load_sum / count) : 0;
        uint32_t avg_temp = (count > 0) ? (temp_sum / count) : 0; // x10

        ui_draw_label_value(9, 4, "Model", model);
        snprintf(tbuf, sizeof(tbuf), "%u Physical Cores", count);
        ui_draw_label_value(10, 4, "Topology", tbuf);

        /* Load Bar */
        mvprintw(12, 4, "Avg Load:");
        /* Load is permille (0-1000). Green < 50%, Yellow < 80%, Red > 80% */
        int color = CL_COLOR_TEXT; // Standard Blau/Gelb
        if (avg_load > 800) color = CL_COLOR_ALERT;
        ui_draw_progressbar(13, 4, col_width-6, avg_load, color);

        /* Temp Bar */
        double temp_c = (double)avg_temp / 10.0;
        snprintf(tbuf, sizeof(tbuf), "Thermals (%.1f %cC)", temp_c, ACS_DEGREE);
        mvprintw(15, 4, "%s", tbuf);
        
        /* Temp Scaling: 0°C - 100°C maps to 0-1000 permille for bar */
        int temp_permille = avg_temp; // da avg_temp schon x10 ist (450 = 45.0 = 45%)
        if (temp_permille > 1000) temp_permille = 1000;
        
        int t_color = CL_COLOR_TEXT;
        if (temp_c > 75.0) t_color = CL_COLOR_ALERT;
        ui_draw_progressbar(16, 4, col_width-6, temp_permille, t_color);

    } else {
        mvprintw(10, 4, "No CPU Segment found.");
    }


    /* --- SECTION: MEMORY MATRIX (Rechts) --- */
    ui_draw_box(7, col2_x, 14, col_width, "Memory Matrix");
    
    const cl_toc_entry_t *e_mem = mon_find_entry(st, toc, CL_MEM_SEG_256);
    if (e_mem) {
        const cl_mem_seg_256_t *mem = (const cl_mem_seg_256_t*)mon_map_segment(st, e_mem, 0);
        if (mem) {
            uint64_t total = atomic_load(&mem->hot.total_bytes);
            uint64_t free  = atomic_load(&mem->hot.free_bytes);
            uint64_t used  = total - free;
            uint32_t press = atomic_load(&mem->hot.pressure_permille);

            char s_tot[32], s_free[32], s_used[32];
            fmt_size(s_tot, sizeof(s_tot), total);
            fmt_size(s_free, sizeof(s_free), free);
            fmt_size(s_used, sizeof(s_used), used);

            ui_draw_label_value(9, col2_x+2,  "Total", s_tot);
            ui_draw_label_value(10, col2_x+2, "Used ", s_used);
            ui_draw_label_value(11, col2_x+2, "Free ", s_free);

            /* Usage Bar */
            int usage_permille = 0;
            if (total > 0) usage_permille = (used * 1000) / total;
            
            mvprintw(13, col2_x+2, "RAM Usage:");
            ui_draw_progressbar(14, col2_x+2, col_width-6, usage_permille, CL_COLOR_TEXT);

            /* Pressure Bar (Memory Pressure Stall Information simulator) */
            mvprintw(16, col2_x+2, "Pressure Index:");
            int p_color = (press > 300) ? CL_COLOR_ALERT : CL_COLOR_TEXT;
            ui_draw_progressbar(17, col2_x+2, col_width-6, press, p_color);
        }
    } else {
        mvprintw(10, col2_x+2, "No MEM Segment found.");
    }


    /* --- SECTION: DATA PLANE / INFRA (Unten) --- */
    /* Check for DMA or ZFS segments */
    const cl_toc_entry_t *e_dma = mon_find_entry(st, toc, CL_DMA_SEG_4096);
    const cl_toc_entry_t *e_zfs = mon_find_entry(st, toc, CL_ZFS_SEG_4096);

    ui_draw_box(21, 2, 6, w-4, "Data Plane & Storage");

    if (e_dma) {
        /* DMA meist Ringbuffer */
        ui_draw_label_value(23, 4, "DMA Engine", "ONLINE");
        mvprintw(23, 30, "[Active Ring Handling]");
    } else {
        ui_draw_label_value(23, 4, "DMA Engine", "N/A");
    }

    if (e_zfs) {
        const cl_zfs_seg_4096_t *zfs = (const cl_zfs_seg_4096_t*)mon_map_segment(st, e_zfs, 0);
        if (zfs) {
             /* HIER WAR DER FEHLER: Zugriff über .arc Unterstruktur */
             uint64_t hits = atomic_load(&zfs->arc.arc_hits);
             uint64_t miss = atomic_load(&zfs->arc.arc_misses);
             uint64_t total_arc = hits + miss;
             int ratio = 0;
             if (total_arc > 0) ratio = (hits * 100) / total_arc;
             
             snprintf(tbuf, sizeof(tbuf), "ARC Hitrate: %d%%", ratio);
             ui_draw_label_value(24, 4, "ZFS Cache", tbuf);
        }
    } else {
        ui_draw_label_value(24, 4, "ZFS Cache", "No Segment");
    }

}

void tab_dashboard_input(int key) {
    (void)key;
}

<<< END FILE: ./src/monitor/tabs/tab_dashboard.c

>>> START FILE: ./src/oracle/oracle0.c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>

#include "cl_runtime/cl_runtime.h"
#include "cl_runtime/cl_service_seg_256.h"

static uint64_t now_ns(void){ struct timespec ts; clock_gettime(CLOCK_MONOTONIC,&ts); return (uint64_t)ts.tv_sec*1000000000ull+(uint64_t)ts.tv_nsec; }

static int map_core_rw(void **out_base, size_t *out_sz){
    int fd=shm_open(CL_CORE_SHM_NAME,O_RDWR,0); if(fd<0) return -1;
    struct stat st; if(fstat(fd,&st)!=0){close(fd);return -2;} if(st.st_size<=0){close(fd);return -3;}
    void *p=mmap(NULL,(size_t)st.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); close(fd);
    if(p==MAP_FAILED) return -4; *out_base=p; *out_sz=(size_t)st.st_size; return 0;
}

static cl_service_seg_256_t* find_service_seg(void *core_base){
    cl_root_t *r=(cl_root_t*)core_base;
    cl_toc_t *toc=(cl_toc_t*)((uint8_t*)core_base+(size_t)r->toc_offset);
    for(uint32_t i=0;i<toc->header.entry_count && i<CL_TOC_MAX_ENTRIES;i++){
        cl_toc_entry_t *e=&toc->entries[i];
        if((uint16_t)e->type==(uint16_t)CL_SERVICE_SEG_256) return (cl_service_seg_256_t*)((uint8_t*)core_base+(size_t)e->offset_bytes);
    }
    return NULL;
}

static cl_service_slot_32_t* slot_for(cl_service_seg_256_t *svc, cl_service_id_t id){
    switch(id){
        case CL_SVC_CORE0: return &svc->g1.s0;
        case CL_SVC_HAL0: return &svc->g1.s1;
        case CL_SVC_LINK0: return &svc->g2.s2;
        case CL_SVC_FLOW0: return &svc->g2.s3;
        case CL_SVC_ORACLE0: return &svc->g3.s4;
        case CL_SVC_MONITOR: return &svc->g3.s5;
        default: return NULL;
    }
}

int main(void){
    void *core=NULL; size_t core_sz=0;
    int rc=map_core_rw(&core,&core_sz);
    if(rc!=0){ printf("oracle0: cannot map core shm: rc=%d errno=%d (%s)\n",rc,errno,strerror(errno)); return 2; }
    cl_service_seg_256_t *svc=find_service_seg(core);
    if(!svc){ printf("oracle0: service segment not found\n"); return 3; }
    cl_service_slot_32_t *sl=slot_for(svc,CL_SVC_ORACLE0);
    if(!sl) return 4;

    for(;;){
        atomic_store(&sl->last_heartbeat_ns, now_ns());
        struct timespec ts={0}; ts.tv_nsec=250000000L; nanosleep(&ts,NULL);
    }
}


<<< END FILE: ./src/oracle/oracle0.c

>>> START FILE: ./tools/cl_abi_report/cl_abi_report.c
/*
 * ============================================================================
 * CommanderLink – ABI / Layout Report Tool (Truth Meter) – FINAL Endausbau
 * Datei: tools/cl_abi_report/cl_abi_report.c
 * ============================================================================
 *
 * Zweck:
 *   - Compile-time ABI: Größen/Alignments/Offsets prüfen (muss immer grün)
 *   - Runtime ABI (optional): Root + TOC + Segment-Geometrie gegen SHM prüfen
 *
 * Maschinenregeln:
 *   - Keine Heuristik. Keine Policy. Nur Verifikation.
 *   - Wenn Root FAILFAST setzt, ist ABI-Mismatch hartes Fail.
 *
 * Plattform:
 *   - Linux / BSD / OmniOS (POSIX shm_open + mmap)
 * ============================================================================
 */

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <stddef.h>
#include <stdalign.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include "../../include/cl_runtime/cl_runtime.h"

/* --------------------------- Hash (FNV-1a 64) ---------------------------- */

static uint64_t fnv1a64_init(void) { return 1469598103934665603ull; }
static uint64_t fnv1a64_u64(uint64_t h, uint64_t v) {
    for (int i = 0; i < 8; i++) {
        uint8_t b = (uint8_t)((v >> (i * 8)) & 0xffu);
        h ^= (uint64_t)b;
        h *= 1099511628211ull;
    }
    return h;
}
static uint64_t fnv1a64_u32(uint64_t h, uint32_t v) { return fnv1a64_u64(h, (uint64_t)v); }
static uint64_t fnv1a64_sz(uint64_t h, size_t v) { return fnv1a64_u64(h, (uint64_t)v); }

/* ABI-Fingerprint: compile-time Wahrheiten */
static uint64_t cl_compute_abi_fingerprint(void) {
    uint64_t h = fnv1a64_init();

    /* Schema */
    h = fnv1a64_u32(h, (uint32_t)CL_SCHEMA_VERSION_U32);
    h = fnv1a64_u32(h, (uint32_t)CL_ENDIAN_MAGIC_U32);
    h = fnv1a64_u32(h, (uint32_t)CL_SHM_PAGE_BYTES);

    /* Root/TOC sizes */
    h = fnv1a64_sz(h, sizeof(cl_root_t));
    h = fnv1a64_sz(h, sizeof(cl_toc_header_t));
    h = fnv1a64_sz(h, sizeof(cl_toc_entry_t));
    h = fnv1a64_u32(h, (uint32_t)CL_TOC_MAX_ENTRIES);
    h = fnv1a64_u32(h, (uint32_t)CL_TOC_VERSION);

    /* Segment sizes (SSOT = struct sizes) */
    h = fnv1a64_sz(h, sizeof(cl_cpu_seg_1024_t));
    h = fnv1a64_sz(h, sizeof(cl_budget_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_mem_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_link_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_overlay_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_watchdog_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_pcie_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_time_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_mesh_neighbor_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_mesh_peer_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_oracle_seg_256_t));

    h = fnv1a64_sz(h, sizeof(cl_nic_seg_512_t));
    h = fnv1a64_sz(h, sizeof(cl_board_seg_512_t));

    h = fnv1a64_sz(h, sizeof(cl_dma_seg_4096_t));
    h = fnv1a64_sz(h, sizeof(cl_history_seg_4096_t));
    h = fnv1a64_sz(h, sizeof(cl_forensics_seg_4096_t));
    h = fnv1a64_sz(h, sizeof(cl_zfs_seg_4096_t));

    /* Alignments */
    h = fnv1a64_sz(h, (size_t)alignof(cl_root_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_cpu_seg_1024_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_dma_seg_4096_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_zfs_seg_4096_t));

    /* Critical offsets: Root */
    h = fnv1a64_sz(h, offsetof(cl_root_t, abi_layout_checksum));
    h = fnv1a64_sz(h, offsetof(cl_root_t, toc_offset));
    h = fnv1a64_sz(h, offsetof(cl_root_t, toc_size));
    h = fnv1a64_sz(h, offsetof(cl_root_t, schema_version));
    h = fnv1a64_sz(h, offsetof(cl_root_t, endian_magic));
    h = fnv1a64_sz(h, offsetof(cl_root_t, root_magic));
    h = fnv1a64_sz(h, offsetof(cl_root_t, root_flags));
    h = fnv1a64_sz(h, offsetof(cl_root_t, bulk_present));
    h = fnv1a64_sz(h, offsetof(cl_root_t, bulk_epoch));

    /* Critical offsets: TOC entry */
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, type));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, stride_bytes));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, count));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, offset_bytes));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, source_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, access_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, presence_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, layout_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, gates_possible));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, gates_effective));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, epoch));

    return h;
}

/* ---------------------------- Helpers ----------------------------------- */

static int is_allowed_stride(uint32_t s) {
    return (s == 256u) || (s == 512u) || (s == 1024u) || (s == 4096u);
}

static int check_bounds_u64(uint64_t off, uint64_t len, uint64_t total) {
    if (off > total) return 0;
    if (len > total) return 0;
    if (off + len > total) return 0;
    return 1;
}

static int map_shm_ro(const char *name, void **out_base, size_t *out_sz) {
    int fd = shm_open(name, O_RDONLY, 0);
    if (fd < 0) return -1;

    struct stat st;
    if (fstat(fd, &st) != 0) {
        close(fd);
        return -2;
    }
    if (st.st_size <= 0) {
        close(fd);
        return -3;
    }

    void *p = mmap(NULL, (size_t)st.st_size, PROT_READ, MAP_SHARED, fd, 0);
    close(fd);
    if (p == MAP_FAILED) return -4;

    *out_base = p;
    *out_sz = (size_t)st.st_size;
    return 0;
}

static void unmap_shm(void *base, size_t sz) {
    if (base && sz) (void)munmap(base, sz);
}

/* ---------------------------- Reports ----------------------------------- */

static int report_compile_time_sizes(void) {
    int ok = 1;

    if (sizeof(cl_root_t) != 4096u) ok = 0;
    if (sizeof(cl_toc_header_t) != 64u) ok = 0;
    if (sizeof(cl_toc_entry_t) != 64u) ok = 0;

    if (sizeof(cl_budget_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_mem_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_link_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_time_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_overlay_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_watchdog_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_pcie_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_mesh_neighbor_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_mesh_peer_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_oracle_seg_256_t) != 256u) ok = 0;

    if (sizeof(cl_nic_seg_512_t) != 512u) ok = 0;
    if (sizeof(cl_board_seg_512_t) != 512u) ok = 0;

    if (sizeof(cl_cpu_seg_1024_t) != 1024u) ok = 0;

    if (sizeof(cl_dma_seg_4096_t) != 4096u) ok = 0;
    if (sizeof(cl_history_seg_4096_t) != 4096u) ok = 0;
    if (sizeof(cl_forensics_seg_4096_t) != 4096u) ok = 0;
    if (sizeof(cl_zfs_seg_4096_t) != 4096u) ok = 0;

    if (!ok) {
        printf("CT FAIL: size drift detected.\n");
        return 1;
    }

    printf("CT OK: sizes stable.\n");
    printf("ABI fingerprint (CT): 0x%016" PRIx64 "\n", cl_compute_abi_fingerprint());
    return 0;
}

static int report_runtime_shm(void *core_base, size_t core_sz,
                              void *bulk_base, size_t bulk_sz, int bulk_mapped) {
    (void)bulk_base; /* optional */
    (void)bulk_sz;

    const cl_root_t *r = (const cl_root_t*)core_base;

    if (r->root_magic != CL_ROOT_MAGIC_U32) return 10;
    if (r->endian_magic != CL_ENDIAN_MAGIC_U32) return 11;
    if (r->schema_version != CL_SCHEMA_VERSION_U32) return 12;

    uint64_t want = cl_compute_abi_fingerprint();
    if (r->abi_layout_checksum != want) {
        if ((r->root_flags & CL_ROOT_FLAG_FAILFAST_ABI) != 0u) return 13;
    }

    if (!check_bounds_u64(r->toc_offset, r->toc_size, (uint64_t)core_sz)) return 14;
    if (r->toc_size < sizeof(cl_toc_header_t)) return 15;

    const cl_toc_t *toc = (const cl_toc_t*)((const uint8_t*)core_base + (size_t)r->toc_offset);
    if (toc->header.entry_count > CL_TOC_MAX_ENTRIES) return 16;

    uint64_t need = (uint64_t)sizeof(cl_toc_header_t) +
                    (uint64_t)toc->header.entry_count * (uint64_t)sizeof(cl_toc_entry_t);
    if (need > r->toc_size) return 17;

    for (uint32_t i = 0; i < toc->header.entry_count; i++) {
        const cl_toc_entry_t *e = &toc->entries[i];
        uint32_t stride = (uint32_t)e->stride_bytes;
        uint32_t count  = (uint32_t)e->count;
        uint64_t off    = (uint64_t)e->offset_bytes;

        if (!is_allowed_stride(stride)) return 18;

        uint64_t seg_bytes = (uint64_t)stride * (uint64_t)count;
        if ((off % (uint64_t)stride) != 0u) return 19;

        const int in_bulk = ((e->flags & CL_TOC_FLAG_RECLAIMABLE) != 0u);
        if (!in_bulk) {
            if (!check_bounds_u64(off, seg_bytes, (uint64_t)core_sz)) return 20;
        } else {
            if (bulk_mapped) {
                if (!check_bounds_u64(off, seg_bytes, (uint64_t)bulk_sz)) return 21;
            }
        }
    }

    return 0;
}

int main(void) {
    /* compile-time ABI must be green */
    int ct = report_compile_time_sizes();
    if (ct != 0) return ct;

    /* runtime check is optional; if no SHM exists, exit clean */
    void *core_base = NULL;
    size_t core_sz = 0;
    int rc = map_shm_ro(CL_CORE_SHM_NAME, &core_base, &core_sz);
    if (rc != 0) {
           printf("RT INFO: core shm not mapped (%s): rc=%d errno=%d (%s); compile-time ABI is green.\n",
           CL_CORE_SHM_NAME, rc, errno, strerror(errno));
    return 0;
    }

    void *bulk_base = NULL;
    size_t bulk_sz = 0;
    int bulk_mapped = (map_shm_ro(CL_BULK_SHM_NAME, &bulk_base, &bulk_sz) == 0);

    int rt = report_runtime_shm(core_base, core_sz, bulk_base, bulk_sz, bulk_mapped);

    unmap_shm(core_base, core_sz);
    if (bulk_mapped) unmap_shm(bulk_base, bulk_sz);

    if (rt == 0) {
        printf("RT OK: root/toc/segments geometry validated.\n");
        return 0;
    }
    printf("RT FAIL: code=%d\n", rt);
    return rt;
}


<<< END FILE: ./tools/cl_abi_report/cl_abi_report.c

>>> START FILE: ./tools/cl_abi_report/README.md
# cl_abi_report

ABI-/Layout-Prüfgerät für CommanderLink.

## Zweck
- Prüft Root/TOC/Segment-Geometrie gegen reale SHM-Mappings.
- Meldet ABI-Drift deterministisch.

## Ablauf
1) `cl_dummy_shm` starten (erzeugt /cl_core_root)
2) `cl_abi_report` starten (liest /cl_core_root, prüft TOC/Segmente)

## Ausgabe
- `ABI_STABLE` oder `ABI_UNSTABLE`


<<< END FILE: ./tools/cl_abi_report/README.md

>>> START FILE: ./tools/cl_dummy_shm/cl_dummy_shm.c
/*
 * ============================================================================
 * CommanderLink – Dummy SHM Generator (Core-SHM) – FINAL Endausbau
 * Datei: tools/cl_dummy_shm/cl_dummy_shm.c
 * ============================================================================
 *
 * Zweck:
 *   - Erzeugt /cl_core_root (Core-SHM) mit Root + TOC + Segment-Records
 *   - Initialisiert einen minimalen, konsistenten Runtime-Snapshot
 *   - Dient NUR für Tests/Bringup (Monitor/ABI-Report/shm_dump), nicht produktiv
 *
 * Maschinenregel:
 *   - Host-Order im SHM
 *   - Keine packed Layouts
 *   - Stride/Offsets exakt wie in den Headern
 *   - TOC ist Header+Entries (keine Legacy-Felder)
 *
 * Hinweis:
 *   - Bulk-SHM wird hier NICHT erzeugt. bulk_present = 0.
 * ============================================================================
 */

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdatomic.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>

#include "../../include/cl_runtime/cl_runtime.h"

/* --------------------------------------------------------------------------
 * Zeit
 * -------------------------------------------------------------------------- */
static uint64_t now_ns(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)ts.tv_sec * 1000000000ull + (uint64_t)ts.tv_nsec;
}

/* --------------------------------------------------------------------------
 * Hash (FNV-1a 64) – identisch zum ABI-Report
 * -------------------------------------------------------------------------- */
static uint64_t fnv1a64_init(void) { return 1469598103934665603ull; }

static uint64_t fnv1a64_u64(uint64_t h, uint64_t v) {
    for (int i = 0; i < 8; i++) {
        uint8_t b = (uint8_t)((v >> (i * 8)) & 0xffu);
        h ^= (uint64_t)b;
        h *= 1099511628211ull;
    }
    return h;
}
static uint64_t fnv1a64_u32(uint64_t h, uint32_t v) { return fnv1a64_u64(h, (uint64_t)v); }
static uint64_t fnv1a64_sz(uint64_t h, size_t v) { return fnv1a64_u64(h, (uint64_t)v); }

static uint64_t cl_compute_abi_fingerprint(void) {
    uint64_t h = fnv1a64_init();

    /* Schema */
    h = fnv1a64_u32(h, (uint32_t)CL_SCHEMA_VERSION_U32);
    h = fnv1a64_u32(h, (uint32_t)CL_ENDIAN_MAGIC_U32);
    h = fnv1a64_u32(h, (uint32_t)CL_SHM_PAGE_BYTES);

    /* Root / TOC */
    h = fnv1a64_sz(h, sizeof(cl_root_t));
    h = fnv1a64_sz(h, sizeof(cl_toc_header_t));
    h = fnv1a64_sz(h, sizeof(cl_toc_entry_t));
    h = fnv1a64_u32(h, (uint32_t)CL_TOC_MAX_ENTRIES);
    h = fnv1a64_u32(h, (uint32_t)CL_TOC_VERSION);

    /* Segmentgrößen (Strides) */
    h = fnv1a64_sz(h, sizeof(cl_seg_cpu_1024_t));
    h = fnv1a64_sz(h, sizeof(cl_budget_seg_256_t));     /* Budget */
    h = fnv1a64_sz(h, sizeof(cl_seg_mem_256_t));        /* Memory */
    h = fnv1a64_sz(h, sizeof(cl_seg_nic_512_t));        /* NIC */
    h = fnv1a64_sz(h, sizeof(cl_seg_link_256_t));       /* Link Summary */
    h = fnv1a64_sz(h, sizeof(cl_overlay_seg_256_t));    /* Overlay */
    h = fnv1a64_sz(h, sizeof(cl_watchdog_seg_256_t));   /* Watchdog */
    h = fnv1a64_sz(h, sizeof(cl_seg_pcie_256_t));       /* PCIe */
    h = fnv1a64_sz(h, sizeof(cl_seg_board_512_t));      /* Board */
    h = fnv1a64_sz(h, sizeof(cl_seg_time_256_t));       /* Timebase */
    h = fnv1a64_sz(h, sizeof(cl_seg_mesh_neighbor_256_t)); /* Hot Neighbor */
    h = fnv1a64_sz(h, sizeof(cl_seg_zfs_4096_t));       /* ZFS Summary */

    /* Alignments */
    h = fnv1a64_sz(h, (size_t)alignof(cl_root_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_seg_cpu_1024_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_seg_zfs_4096_t));

    /* Root Offsets (kritisch) */
    h = fnv1a64_sz(h, offsetof(cl_root_t, abi_layout_checksum));
    h = fnv1a64_sz(h, offsetof(cl_root_t, toc_offset));
    h = fnv1a64_sz(h, offsetof(cl_root_t, toc_size));
    h = fnv1a64_sz(h, offsetof(cl_root_t, schema_version));
    h = fnv1a64_sz(h, offsetof(cl_root_t, endian_magic));
    h = fnv1a64_sz(h, offsetof(cl_root_t, root_magic));
    h = fnv1a64_sz(h, offsetof(cl_root_t, root_flags));
    h = fnv1a64_sz(h, offsetof(cl_root_t, bulk_present));
    h = fnv1a64_sz(h, offsetof(cl_root_t, bulk_epoch));

    /* TOC Entry Offsets */
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, type));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, stride_bytes));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, count));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, offset_bytes));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, source_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, access_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, presence_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, layout_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, gates_possible));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, gates_effective));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, epoch));

    return h;
}

/* --------------------------------------------------------------------------
 * Alignment Helper
 * -------------------------------------------------------------------------- */
static size_t align_up(size_t v, size_t a) {
    if (a == 0) return v;
    size_t r = v % a;
    return r ? (v + (a - r)) : v;
}

/* --------------------------------------------------------------------------
 * TOC Helper (neues Layout)
 * -------------------------------------------------------------------------- */
static void toc_init(cl_toc_t *toc, uint64_t total_bytes, uint64_t build_id) {
    memset(toc, 0, sizeof(*toc));
    toc->header.version = CL_TOC_VERSION;
    toc->header.entry_count = 0;
    toc->header.total_bytes = total_bytes;
    toc->header.build_id = build_id;
    toc->header.epoch = 1;
}

static cl_toc_entry_t* toc_add(cl_toc_t *toc,
                               cl_segment_type_t type,
                               uint16_t seg_version,
                               cl_toc_flags_t flags,
                               uint32_t stride_bytes,
                               uint32_t count,
                               uint64_t offset_bytes,
                               uint16_t source_flags,
                               uint16_t access_flags,
                               uint16_t presence_flags,
                               uint16_t layout_flags,
                               uint64_t gates_possible,
                               uint64_t gates_effective,
                               uint64_t epoch)
{
    if (toc->header.entry_count >= CL_TOC_MAX_ENTRIES) return NULL;

    cl_toc_entry_t *e = &toc->entries[toc->header.entry_count++];
    memset(e, 0, sizeof(*e));

    e->type = (uint16_t)type;
    e->version = seg_version;
    e->flags = (uint32_t)flags;

    e->stride_bytes = stride_bytes;
    e->count = count;
    e->offset_bytes = offset_bytes;

    e->source_flags = source_flags;
    e->access_flags = access_flags;
    e->presence_flags = presence_flags;
    e->layout_flags = layout_flags;

    e->gates_possible = (cl_gate_mask_t)gates_possible;
    e->gates_effective = (cl_gate_mask_t)gates_effective;

    e->epoch = epoch;
    e->reserved0 = 0;

    return e;
}

/* --------------------------------------------------------------------------
 * Minimal Fill Helpers (keine Heuristik)
 * -------------------------------------------------------------------------- */
static void fill_budget(cl_budget_seg_256_t *b) {
    /* Alle Felder deterministisch: nur ein Snapshot */
    b->cl0_ident.v.epoch = 1;
    b->cl0_ident.v.tsc_last_update = 0;
    b->cl0_ident.v.window_ns = 250000000ull; /* 250ms window als Beispiel */
    b->cl0_ident.v.window_start_tsc = 0;

    b->cl1_capacity.v.cpu_possible_ns = 250000000ull;
    b->cl1_capacity.v.cpu_effective_ns = 250000000ull;
    b->cl1_capacity.v.net_possible_ns = 250000000ull;
    b->cl1_capacity.v.net_effective_ns = 250000000ull;

    b->cl2_usage.v.cpu_used_ns = 0;
    b->cl2_usage.v.net_used_ns = 0;
    b->cl2_usage.v.stall_events = 0;
    b->cl2_usage.v.interactive_events = 0;

    b->cl3_state.v.gates.possible = 0;
    b->cl3_state.v.gates.effective = 0;
    b->cl3_state.v.gates_seen = 0;
    b->cl3_state.v.reclaim_events = 0;
}

static void fill_mem(cl_seg_mem_256_t *m) {
    atomic_store(&m->hot.total_bytes, 32ull * 1024ull * 1024ull * 1024ull);
    atomic_store(&m->hot.used_bytes,  8ull * 1024ull * 1024ull * 1024ull);
    atomic_store(&m->hot.free_bytes, 24ull * 1024ull * 1024ull * 1024ull);
    atomic_store(&m->hot.ecc_err_cnt, 0u);

    atomic_store(&m->hot.pressure_permille, 50u);
    atomic_store(&m->hot.reason_code, 0u);

    m->hot.src = 0;
    m->hot.qual = 0;

    atomic_store(&m->warm.bw_read_bps, 0u);
    atomic_store(&m->warm.bw_write_bps, 0u);
    atomic_store(&m->warm.timing_tcl, 0u);
    atomic_store(&m->warm.timing_trcd, 0u);
    atomic_store(&m->warm.timing_trp, 0u);
    atomic_store(&m->warm.timing_tras, 0u);
    atomic_store(&m->warm.channel_state, 0u);
    atomic_store(&m->warm.reclaim_events, 0u);
    atomic_store(&m->warm.last_update_ns, now_ns());

    memset(m->cold.dimm_mode, 0, sizeof(m->cold.dimm_mode));
    memset(m->cold.channel_mode, 0, sizeof(m->cold.channel_mode));
    strncpy(m->cold.dimm_mode, "DDR", sizeof(m->cold.dimm_mode)-1);
    strncpy(m->cold.channel_mode, "DUAL", sizeof(m->cold.channel_mode)-1);
    m->cold.src = 0;
    m->cold.qual = 0;

    atomic_store(&m->rsv.gates_possible, 0u);
    atomic_store(&m->rsv.gates_effective, 0u);
    atomic_store(&m->rsv.gates_seen, 0u);
    atomic_store(&m->rsv.oom_events, 0u);
    atomic_store(&m->rsv.reclaim_failures, 0u);
    atomic_store(&m->rsv.epoch, 1u);
    atomic_store(&m->rsv.last_gate_change_ns, now_ns());
}

static void fill_overlay(cl_overlay_seg_256_t *o) {
    o->cl0_ident.v.mesh_id = 0;
    o->cl0_ident.v.node_id = 0;
    o->cl0_ident.v.overlay_ipv4 = 0;
    o->cl0_ident.v.overlay_prefix = 32;
    o->cl0_ident.v.collision_offset = 0;
    o->cl0_ident.v.active = 0;

    o->cl1_trust.v.trust_state = 0;
    o->cl1_trust.v.join_epoch = 0;
    o->cl1_trust.v.grants_active = 0;
    o->cl1_trust.v.grants_revoked = 0;

    o->cl2_routing.v.routes_installed = 0;
    o->cl2_routing.v.routes_failed = 0;
    o->cl2_routing.v.fail_open = 0;
    o->cl2_routing.v.unreachable_peers = 0;

    o->cl3_state.v.gates.possible = 0;
    o->cl3_state.v.gates.effective = 0;
    o->cl3_state.v.gates_seen = 0;
    o->cl3_state.v.security_events = 0;
}

static void fill_watchdog(cl_watchdog_seg_256_t *w) {
    atomic_store(&w->cl0_liveness.v.heartbeat_seq, 1u);
    atomic_store(&w->cl0_liveness.v.last_heartbeat_tsc, 0u);
    atomic_store(&w->cl0_liveness.v.timeout_ns, 1000000000ull);
    atomic_store(&w->cl0_liveness.v.epoch, 1u);

    atomic_store(&w->cl1_faults.v.fault_flags, 0u);
    atomic_store(&w->cl1_faults.v.fault_epoch, 0u);
    atomic_store(&w->cl1_faults.v.escalation_level, 0u);
    atomic_store(&w->cl1_faults.v.escalation_count, 0u);

    atomic_store(&w->cl2_recovery.v.soft_restarts, 0u);
    atomic_store(&w->cl2_recovery.v.hard_restarts, 0u);
    atomic_store(&w->cl2_recovery.v.last_restart_tsc, 0u);
    atomic_store(&w->cl2_recovery.v.recovery_failures, 0u);

    w->cl3_state.v.gates.possible = 0;
    w->cl3_state.v.gates.effective = 0;
    w->cl3_state.v.gates_seen = 0;
    w->cl3_state.v.fatal_events = 0;
}

/* --------------------------------------------------------------------------
 * Main
 * -------------------------------------------------------------------------- */
int main(void) {
    const uint64_t boot_ns = now_ns();
    const uint64_t abi_fp = cl_compute_abi_fingerprint();

    /* Root(4096) + TOC(4096) + Segmente … */
    size_t toc_offset = CL_SHM_PAGE_BYTES;
    size_t toc_size   = CL_SHM_PAGE_BYTES;

    /* Start of segments after TOC page */
    size_t off = toc_offset + toc_size;
    off = align_up(off, 256);

    /* Segment Layout (Core-only in Dummy) */
    const uint32_t cpu_count = 1;
    const uint32_t nic_count = 1;
    const uint32_t neighbor_count = 32; /* Hot neighbors Ziel */

    /* Offsets: align to stride */
    size_t off_link      = align_up(off, 256);  off = off_link + sizeof(cl_seg_link_256_t);
    size_t off_budget    = align_up(off, 256);  off = off_budget + sizeof(cl_budget_seg_256_t);
    size_t off_mem       = align_up(off, 256);  off = off_mem + sizeof(cl_seg_mem_256_t);
    size_t off_overlay   = align_up(off, 256);  off = off_overlay + sizeof(cl_overlay_seg_256_t);
    size_t off_watchdog  = align_up(off, 256);  off = off_watchdog + sizeof(cl_watchdog_seg_256_t);

    size_t off_cpu       = align_up(off, 1024); off = off_cpu + cpu_count * sizeof(cl_seg_cpu_1024_t);
    size_t off_nic       = align_up(off, 512);  off = off_nic + nic_count * sizeof(cl_seg_nic_512_t);

    size_t off_pcie      = align_up(off, 256);  off = off_pcie + sizeof(cl_seg_pcie_256_t);
    size_t off_board     = align_up(off, 512);  off = off_board + sizeof(cl_seg_board_512_t);
    size_t off_time      = align_up(off, 256);  off = off_time + sizeof(cl_seg_time_256_t);

    size_t off_neighbor  = align_up(off, 256);  off = off_neighbor + neighbor_count * sizeof(cl_seg_mesh_neighbor_256_t);

    size_t off_zfs       = align_up(off, 4096); off = off_zfs + sizeof(cl_seg_zfs_4096_t);

    size_t core_total = align_up(off, 4096);

    /* Create SHM */
    shm_unlink(CL_CORE_SHM_NAME);
    int fd = shm_open(CL_CORE_SHM_NAME, O_CREAT | O_RDWR, 0600);
    if (fd < 0) {
        printf("FAIL: shm_open(%s): errno=%d (%s)\n", CL_CORE_SHM_NAME, errno, strerror(errno));
        return 2;
    }
    if (ftruncate(fd, (off_t)core_total) != 0) {
        printf("FAIL: ftruncate core_total=%zu: errno=%d (%s)\n", core_total, errno, strerror(errno));
        close(fd);
        return 3;
    }
    void *base = mmap(NULL, core_total, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    close(fd);
    if (base == MAP_FAILED) {
        printf("FAIL: mmap core: errno=%d (%s)\n", errno, strerror(errno));
        return 4;
    }

    memset(base, 0, core_total);

    /* Root */
    cl_root_t *root = (cl_root_t*)base;
    root->abi_layout_checksum = abi_fp;

    atomic_store(&root->seq_cnt, 1u);
    atomic_store(&root->uptime_ns, 0u);

    atomic_store(&root->bulk_epoch, 0u);
    root->boot_id_ns = boot_ns;

    root->mesh_tag64 = 0;
    root->node_tag64 = 0;

    root->core_total_bytes = (uint64_t)core_total;
    root->bulk_total_bytes = 0;

    root->toc_offset = (uint64_t)toc_offset;
    root->toc_size   = (uint64_t)toc_size;

    atomic_store(&root->gates_possible, 0u);
    atomic_store(&root->gates_effective, 0u);

    root->root_magic = CL_ROOT_MAGIC_U32;
    root->schema_version = CL_SCHEMA_VERSION_U32;
    root->endian_magic = CL_ENDIAN_MAGIC_U32;

    root->root_flags = CL_ROOT_FLAG_FAILFAST_ABI | CL_ROOT_FLAG_BULK_OPTIONAL;

    atomic_store(&root->bulk_present, 0u);

    /* TOC */
    cl_toc_t *toc = (cl_toc_t*)((uint8_t*)base + toc_offset);
    toc_init(toc, (uint64_t)core_total, abi_fp);

    /* Add segments (Core) */
    (void)toc_add(toc, CL_SEG_LINK_SUMMARY, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL,
                  256, 1, (uint64_t)off_link,
                  CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_BUDGET, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL,
                  256, 1, (uint64_t)off_budget,
                  CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_MEMORY, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_DATA,
                  256, 1, (uint64_t)off_mem,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_OVERLAY, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_CONTROL,
                  256, 1, (uint64_t)off_overlay,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_WATCHDOG, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL | CL_TOC_FLAG_FORENSICS,
                  256, 1, (uint64_t)off_watchdog,
                  CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_CPU, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA | CL_TOC_FLAG_FIXED_COUNT,
                  1024, cpu_count, (uint64_t)off_cpu,
                  CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_NIC, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA | CL_TOC_FLAG_FIXED_COUNT,
                  512, nic_count, (uint64_t)off_nic,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_PCIe, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_DATA,
                  256, 1, (uint64_t)off_pcie,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_BOARD, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_DATA,
                  512, 1, (uint64_t)off_board,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_TIMEBASE, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_CONTROL,
                  256, 1, (uint64_t)off_time,
                  CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_MESH_NEIGHBOR, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA | CL_TOC_FLAG_FIXED_COUNT,
                  256, neighbor_count, (uint64_t)off_neighbor,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE | CL_TOC_LAYOUT_ARRAY, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_ZFS_SUMMARY, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_COLD | CL_TOC_FLAG_DATA,
                  4096, 1, (uint64_t)off_zfs,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    /* Fill segments minimal */
    cl_seg_link_256_t *link = (cl_seg_link_256_t*)((uint8_t*)base + off_link);
    memset(link, 0, sizeof(*link)); /* Link wird in Monitor ohnehin gelesen */
    /* Optional: könnte man deterministisch setzen, aber nicht nötig fürs ABI */

    cl_budget_seg_256_t *budget = (cl_budget_seg_256_t*)((uint8_t*)base + off_budget);
    memset(budget, 0, sizeof(*budget));
    fill_budget(budget);

    cl_seg_mem_256_t *mem = (cl_seg_mem_256_t*)((uint8_t*)base + off_mem);
    memset(mem, 0, sizeof(*mem));
    fill_mem(mem);

    cl_overlay_seg_256_t *ovl = (cl_overlay_seg_256_t*)((uint8_t*)base + off_overlay);
    memset(ovl, 0, sizeof(*ovl));
    fill_overlay(ovl);

    cl_watchdog_seg_256_t *wd = (cl_watchdog_seg_256_t*)((uint8_t*)base + off_watchdog);
    memset(wd, 0, sizeof(*wd));
    fill_watchdog(wd);

    /* CPU/NIC/PCIE/BOARD/TIME/MESH/ZFS werden hier bewusst nur genullt:
     * Dummy ist Testharness; der Aufbau zählt, nicht „Simulation“. */
    memset((uint8_t*)base + off_cpu, 0, cpu_count * sizeof(cl_seg_cpu_1024_t));
    memset((uint8_t*)base + off_nic, 0, nic_count * sizeof(cl_seg_nic_512_t));
    memset((uint8_t*)base + off_pcie, 0, sizeof(cl_seg_pcie_256_t));
    memset((uint8_t*)base + off_board, 0, sizeof(cl_seg_board_512_t));
    memset((uint8_t*)base + off_time, 0, sizeof(cl_seg_time_256_t));
    memset((uint8_t*)base + off_neighbor, 0, neighbor_count * sizeof(cl_seg_mesh_neighbor_256_t));
    memset((uint8_t*)base + off_zfs, 0, sizeof(cl_seg_zfs_4096_t));

    /* Fertig */
    msync(base, core_total, MS_SYNC);
    munmap(base, core_total);

    printf("OK: created CORE SHM %s size=%zu\n", CL_CORE_SHM_NAME, core_total);
    printf("    toc_offset=%zu toc_size=%zu entries=%u\n",
           toc_offset, toc_size, (unsigned)toc->header.entry_count);
    printf("    abi_fingerprint=0x%016" PRIx64 "\n", abi_fp);

    return 0;
}


<<< END FILE: ./tools/cl_dummy_shm/cl_dummy_shm.c

>>> START FILE: ./tools/cl_shm_dump/cl_shm_dump.c
/*
 * ============================================================================
 * CommanderLink – SHM Dump Tool (read-only) – FINAL Endausbau
 * Datei: tools/cl_shm_dump/cl_shm_dump.c
 * ============================================================================
 *
 * Zweck:
 *   - Read-only Dump von Core-SHM Root + TOC + Segment-Geometrie.
 *   - Keine Policy, keine Interpretation, keine Heuristik.
 *   - Zeigt die physikalische Wahrheit: Offsets/Strides/Counts/Flags/Gates.
 *
 * Plattform:
 *   - Linux / BSD / OmniOS (POSIX shm_open + mmap)
 * ============================================================================
 */

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include "../../include/cl_runtime/cl_runtime.h"

/* --------------------------------------------------------------------------
 * Helpers: POSIX SHM Mapping
 * -------------------------------------------------------------------------- */

static int map_shm_ro(const char *name, void **out_base, size_t *out_sz) {
    int fd = shm_open(name, O_RDONLY, 0);
    if (fd < 0) return -1;

    struct stat st;
    if (fstat(fd, &st) != 0) {
        close(fd);
        return -2;
    }
    if (st.st_size <= 0) {
        close(fd);
        return -3;
    }

    void *p = mmap(NULL, (size_t)st.st_size, PROT_READ, MAP_SHARED, fd, 0);
    close(fd);
    if (p == MAP_FAILED) return -4;

    *out_base = p;
    *out_sz = (size_t)st.st_size;
    return 0;
}

static void unmap_shm(void *base, size_t sz) {
    if (base && sz) (void)munmap(base, sz);
}

/* --------------------------------------------------------------------------
 * Helpers: Segment-Type Name
 *
 * Hinweis:
 *   Die Typ-IDs sind manifest-nahe. Die Größe (Stride) steht im TOC.
 * -------------------------------------------------------------------------- */
static const char* seg_type_name(uint32_t t) {
    switch ((cl_seg_type_t)t) {
        case CL_SEG_CPU:           return "CPU";
        case CL_SEG_MEMORY:        return "MEMORY";
        case CL_SEG_PCIe:          return "PCIe";
        case CL_SEG_BOARD:         return "BOARD";
        case CL_SEG_TIMEBASE:      return "TIMEBASE";
        case CL_SEG_BUDGET:        return "BUDGET";
        case CL_SEG_WATCHDOG:      return "WATCHDOG";
        case CL_SEG_NIC:           return "NIC";
        case CL_SEG_LINK_SUMMARY:  return "LINK_SUMMARY";
        case CL_SEG_DMA:           return "DMA";
        case CL_SEG_OVERLAY:       return "OVERLAY";
        case CL_SEG_MESH_NEIGHBOR: return "MESH_NEIGHBOR";
        case CL_SEG_MESH_PEER:     return "MESH_PEER";
        case CL_SEG_ZFS_SUMMARY:   return "ZFS_SUMMARY";
        case CL_SEG_ZFS_POOL:      return "ZFS_POOL";
        case CL_SEG_ZFS_VDEV:      return "ZFS_VDEV";
        case CL_SEG_ZFS_DATASET:   return "ZFS_DATASET";
        case CL_SEG_ZFS_ZVOL:      return "ZFS_ZVOL";
        case CL_SEG_HISTORY:       return "HISTORY";
        case CL_SEG_FORENSICS:     return "FORENSICS";
        default:                   return "UNKNOWN";
    }
}

/* --------------------------------------------------------------------------
 * Helpers: Flags pretty-print (keine Interpretation, nur Anzeige)
 * -------------------------------------------------------------------------- */
static void print_flags_u32(const char *label, uint32_t v) {
    printf("    %-14s 0x%08x\n", label, v);
}

static void print_u16_flags(const char *label, uint16_t v) {
    printf("    %-14s 0x%04x\n", label, (unsigned)v);
}

/* --------------------------------------------------------------------------
 * Dump Root
 * -------------------------------------------------------------------------- */
static int dump_root(const cl_root_t *r, size_t core_sz) {
    printf("ROOT (Core-SHM):\n");
    printf("  root_magic:      0x%08x\n", r->root_magic);
    printf("  schema_version:  0x%08x\n", r->schema_version);
    printf("  endian_magic:    0x%08x\n", r->endian_magic);
    printf("  root_flags:      0x%08x\n", r->root_flags);
    printf("  abi_checksum:    0x%016" PRIx64 "\n", (uint64_t)r->abi_layout_checksum);

    printf("  seq_cnt:         %" PRIu64 "\n", (uint64_t)atomic_load(&r->seq_cnt));
    printf("  uptime_ns:       %" PRIu64 "\n", (uint64_t)atomic_load(&r->uptime_ns));
    printf("  bulk_epoch:      %" PRIu64 "\n", (uint64_t)atomic_load(&r->bulk_epoch));
    printf("  bulk_present:    %u\n", (unsigned)atomic_load(&r->bulk_present));

    printf("  core_total:      %" PRIu64 "\n", (uint64_t)r->core_total_bytes);
    printf("  bulk_total:      %" PRIu64 "\n", (uint64_t)r->bulk_total_bytes);

    printf("  toc_offset:      %" PRIu64 "\n", (uint64_t)r->toc_offset);
    printf("  toc_size:        %" PRIu64 "\n", (uint64_t)r->toc_size);

    printf("  gates_possible:  0x%016" PRIx64 "\n", (uint64_t)atomic_load(&r->gates_possible));
    printf("  gates_effective: 0x%016" PRIx64 "\n", (uint64_t)atomic_load(&r->gates_effective));

    if (r->root_magic != CL_ROOT_MAGIC_U32) {
        printf("  FAIL: root_magic mismatch (expected 0x%08x)\n", (unsigned)CL_ROOT_MAGIC_U32);
        return 1;
    }
    if (r->endian_magic != CL_ENDIAN_MAGIC_U32) {
        printf("  FAIL: endian_magic mismatch (expected 0x%08x)\n", (unsigned)CL_ENDIAN_MAGIC_U32);
        return 2;
    }
    if (r->schema_version != CL_SCHEMA_VERSION_U32) {
        printf("  FAIL: schema_version mismatch (expected 0x%08x)\n", (unsigned)CL_SCHEMA_VERSION_U32);
        return 3;
    }
    if (r->toc_offset + r->toc_size > (uint64_t)core_sz) {
        printf("  FAIL: toc_offset/toc_size out of core mapping\n");
        return 4;
    }
    if (r->toc_size < sizeof(cl_toc_header_t)) {
        printf("  FAIL: toc_size too small\n");
        return 5;
    }
    return 0;
}

/* --------------------------------------------------------------------------
 * Dump TOC
 * -------------------------------------------------------------------------- */
static void dump_toc(const cl_toc_t *toc, uint64_t toc_size_bytes) {
    printf("\nTOC:\n");
    printf("  version:      %u\n", (unsigned)toc->header.version);
    printf("  entry_count:  %u\n", (unsigned)toc->header.entry_count);
    printf("  total_bytes:  %" PRIu64 "\n", (uint64_t)toc->header.total_bytes);
    printf("  build_id:     0x%016" PRIx64 "\n", (uint64_t)toc->header.build_id);
    printf("  epoch:        %" PRIu64 "\n", (uint64_t)toc->header.epoch);

    uint64_t need = (uint64_t)sizeof(cl_toc_header_t) +
                    (uint64_t)toc->header.entry_count * (uint64_t)sizeof(cl_toc_entry_t);

    printf("  toc_size:     %" PRIu64 "\n", toc_size_bytes);
    printf("  need_bytes:   %" PRIu64 "\n", need);

    if (toc->header.entry_count > CL_TOC_MAX_ENTRIES) {
        printf("  WARN: entry_count > CL_TOC_MAX_ENTRIES (%u)\n", (unsigned)CL_TOC_MAX_ENTRIES);
    }
    if (need > toc_size_bytes) {
        printf("  FAIL: TOC size too small for header+entries\n");
        return;
    }

    for (uint32_t i = 0; i < toc->header.entry_count && i < CL_TOC_MAX_ENTRIES; i++) {
        const cl_toc_entry_t *e = &toc->entries[i];

        const uint32_t type   = (uint32_t)e->type;
        const uint32_t flags  = (uint32_t)e->flags;
        const uint32_t stride = (uint32_t)e->stride_bytes;
        const uint32_t count  = (uint32_t)e->count;
        const uint64_t off    = (uint64_t)e->offset_bytes;

        printf("\n  SEG[%u]: %s (type=0x%04x)\n", i, seg_type_name(type), type);
        printf("    offset_bytes   %" PRIu64 "\n", off);
        printf("    stride_bytes   %u\n", stride);
        printf("    count          %u\n", count);

        print_flags_u32("flags", flags);
        print_u16_flags("source",  (uint16_t)e->source_flags);
        print_u16_flags("access",  (uint16_t)e->access_flags);
        print_u16_flags("presence",(uint16_t)e->presence_flags);
        print_u16_flags("layout",  (uint16_t)e->layout_flags);

        printf("    gates_possible 0x%016" PRIx64 "\n", (uint64_t)e->gates_possible);
        printf("    gates_effective 0x%016" PRIx64 "\n", (uint64_t)e->gates_effective);
        printf("    epoch          %" PRIu64 "\n", (uint64_t)e->epoch);
    }
}

int main(void) {
    void *core_base = NULL;
    size_t core_sz = 0;

    int rc = map_shm_ro(CL_CORE_SHM_NAME, &core_base, &core_sz);
    if (rc != 0) {
        printf("FAIL: cannot map CORE SHM (%s): rc=%d errno=%d (%s)\n",
               CL_CORE_SHM_NAME, rc, errno, strerror(errno));
        return 2;
    }

    const cl_root_t *root = (const cl_root_t*)core_base;
    int root_rc = dump_root(root, core_sz);
    if (root_rc != 0) {
        unmap_shm(core_base, core_sz);
        return 3;
    }

    const cl_toc_t *toc = (const cl_toc_t*)((const uint8_t*)core_base + (size_t)root->toc_offset);
    dump_toc(toc, (uint64_t)root->toc_size);

    unmap_shm(core_base, core_sz);
    return 0;
}


<<< END FILE: ./tools/cl_shm_dump/cl_shm_dump.c

>>> START FILE: ./tools/cl_shm_dump/README.md
# cl_shm_dump

CLI-Tool zur Prüfung des CommanderLink Core-SHM.

## Zweck
- Root lesen (Host-Order)
- TOC iterieren
- Segmentübersicht ausgeben

## Build
Wird später per Makefile-Target eingebunden.

## Lauf
- benötigt laufenden Core/Dummy-SHM, der `/cl_core_root` erstellt.


<<< END FILE: ./tools/cl_shm_dump/README.md

========================================
 PROJECT STRUCTURE TREE
========================================
.
├── .nfs.7ffe91f3.09684.4
├── .nfs.800e85df.0c9b4.4
├── .nfs.800eb7f6.0c9b4.4
├── .nfs.80574f08.1d974.4
├── .nfs.807390a5.23d94.4
├── .nfs.807dad42.25eb4.4
├── .nfs.81313032.25eb4.4
├── .nfs.81626978.533d4.4
├── .nfs.81626f5f.533d4.4
├── .nfs.817dcc22.081d4.4
├── .nfs.817ddd81.081d4.4
├── .nfs.818494ad.5aaa4.4
├── .nfs.818e88d5.5aaa4.4
├── .nfs.818ea65e.5aaa4.4
├── .nfs.819ee2b4.5aaa4.4
├── .nfs.819ef8e4.5aaa4.4
├── .nfs.819f1274.5aaa4.4
├── .nfs.81a0a8d7.61884.4
├── .nfs.81a0eb27.61884.4
├── .nfs.81a49dab.61884.4
├── .nfs.81b2cd1c.66e54.4
├── .nfs.81daded4.6f534.4
├── .nfs.81dbb6a4.6f534.4
├── .nfs.81dbfbec.6f534.4
├── .nfs.81de4be0.6f534.4
├── .nfs.81e67082.6f534.4
├── .nfs.81eb6f66.6f534.4
├── .nfs.81f60fa2.081d4.4
├── .nfs.81f62280.081d4.4
├── .nfs.81f79b50.75fb4.4
├── .nfs.81faa63c.75fb4.4
├── .nfs.81fb0cd4.75fb4.4
├── .nfs.81fdbb28.75fb4.4
├── .nfs.81fe21c7.75fb4.4
├── .nfs.823f1438.75fb4.4
├── .nfs.823f6169.75fb4.4
├── .nfs.823f9c3c.75fb4.4
├── .nfs.8241688c.75fb4.4
├── .nfs.8241a1fc.75fb4.4
├── .nfs.8241bfa8.75fb4.4
├── .nfs.8242c97a.75fb4.4
├── .nfs.8243fc24.75fb4.4
├── .nfs.824400c7.75fb4.4
├── .nfs.8255d539.75fb4.4
├── .nfs.82560a18.75fb4.4
├── .nfs.82562c91.75fb4.4
├── .nfs.82563421.75fb4.4
├── .nfs.8256f306.75fb4.4
├── .nfs.82582300.75fb4.4
├── .nfs.825830ec.75fb4.4
├── .nfs.82bd2602.081d4.4
├── bin
│   └── bsd
│       ├── cl_abi_report
│       ├── clboot
│       ├── cld
│       └── clinit
├── build
│   └── bsd
│       ├── src
│       │   ├── clboot
│       │   │   └── clboot.o
│       │   ├── cld
│       │   │   └── cld.o
│       │   ├── clinit
│       │   │   └── clinit.o
│       │   ├── core
│       │   ├── flow
│       │   ├── hal
│       │   ├── link
│       │   ├── monitor
│       │   │   └── tabs
│       │   └── oracle
│       └── tools
│           └── cl_abi_report
│               └── cl_abi_report.o
├── BUILD REQUIREMENTS.md
├── docs
│   ├── .nfs.81897eb6.63604.4
│   ├── .nfs.818a45af.63604.4
│   ├── ABI_LAYOUT.md
│   ├── ENGINEERING_RULES.md
│   ├── laws
│   │   ├── 00_PHYSICS.md
│   │   ├── ANNEX_36_SHM_ENFORCEMENT.md
│   │   ├── LAW_00_PHYSICS.md
│   │   ├── LAW_01_CPU.md
│   │   ├── LAW_02_MEMORY.md
│   │   ├── LAW_03_NETWORK.md
│   │   ├── LAW_04_TIME.md
│   │   ├── LAW_05_POWER.md
│   │   ├── LAW_06_SCHEDULING.md
│   │   ├── LAW_07_IO.md
│   │   ├── LAW_08_SECURITY.md
│   │   ├── LAW_09_MEASUREMENT.md
│   │   ├── LAW_10_FAILURE.md
│   │   ├── LAW_11_CONTROL.md
│   │   ├── LAW_12_IDENTITY.md
│   │   ├── LAW_13_STATE.md
│   │   ├── LAW_14_INTERFACE.md
│   │   ├── LAW_15_CONFIGURATION.md
│   │   ├── LAW_16_DEPLOYMENT.md
│   │   ├── LAW_17_GOVERNANCE.md
│   │   ├── LAW_18_DOCUMENTATION.md
│   │   ├── LAW_19_IMPLEMENTATION.md
│   │   ├── LAW_20_VERIFICATION.md
│   │   ├── LAW_21_SCOPE.md
│   │   ├── LAW_22_STATUS.md
│   │   ├── LAW_23_SYMBIONT.md
│   │   ├── LAW_24_READINESS.md
│   │   ├── LAW_25_CONFORMANCE.md
│   │   ├── LAW_26_LAYOUT.md
│   │   ├── LAW_27_COVERAGE.md
│   │   ├── LAW_28_STRUCTURE.md
│   │   ├── LAW_29_NAMING.md
│   │   ├── LAW_30_MANIFEST_START.md
│   │   ├── LAW_31_TERMS.md
│   │   ├── LAW_32_BASE.md
│   │   ├── LAW_33_POLICY.md
│   │   ├── LAW_34_RUNTIME_START.md
│   │   ├── LAW_35_ABI.md
│   │   ├── LAW_36_SHM.md
│   │   ├── LAW_37_RUNTIME_STATE.md
│   │   ├── LAW_38_BUDGET.md
│   │   ├── LAW_39_WIRE.md
│   │   ├── LAW_40_MONITOR.md
│   │   ├── LAW_41_TOOLING.md
│   │   └── LAW_42_FINAL.md
│   ├── MEMORY_MODEL.md
│   ├── PROJECT_GUARDRAILS.md
│   ├── SECURITY_AND_JOIN_POLICY.md
│   ├── SPEC_EXEC_CTX_64.md
│   ├── TYPES_AND_ABI.md
│   ├── WATCHDOG_AND_FORENSICS.md
│   ├── WATCHDOG.md
│   ├── ZERO_LAWS_2.md
│   └── ZERO_LAWS.md
├── include
│   ├── cl_common
│   │   ├── cl_align.h
│   │   └── cl_endian.h
│   ├── cl_core
│   ├── cl_flow
│   ├── cl_hal
│   ├── cl_link
│   ├── cl_manifest
│   │   ├── cl_enums.h
│   │   ├── cl_features.h
│   │   ├── cl_ids.h
│   │   ├── cl_join_policy.h
│   │   ├── cl_limits.h
│   │   ├── cl_link_modes.h
│   │   ├── cl_manifest.h
│   │   ├── cl_modeling_rule.h
│   │   ├── cl_oob_wire.h
│   │   ├── cl_oob.h
│   │   ├── cl_overlay.h
│   │   ├── cl_simd_policy.h
│   │   ├── cl_trust.h
│   │   ├── cl_wire_crc.h
│   │   ├── cl_wire.h
│   │   └── cl_zero_transform.h
│   ├── cl_monitor
│   │   └── cl_monitor.h
│   ├── cl_oracle
│   └── cl_runtime
│       ├── cl_gates.h
│       ├── cl_quality.h
│       ├── cl_runtime.h
│       ├── cl_schema.h
│       ├── cl_seg_board_512.h
│       ├── cl_seg_budget_256.h
│       ├── cl_seg_cpu_1024.h
│       ├── cl_seg_dma_4096.h
│       ├── cl_seg_forensics_4096.h
│       ├── cl_seg_history_4096.h
│       ├── cl_seg_link_256.h
│       ├── cl_seg_mem_256.h
│       ├── cl_seg_mesh_neighbor_256.h
│       ├── cl_seg_mesh_peer_256.h
│       ├── cl_seg_nic_512.h
│       ├── cl_seg_oracle_256.h
│       ├── cl_seg_overlay_256.h
│       ├── cl_seg_pcie_256.h
│       ├── cl_seg_time_256.h
│       ├── cl_seg_watchdog_256.h
│       ├── cl_seg_zfs_4096.h
│       ├── cl_service_seg_256.h
│       ├── cl_shm_layout.h
│       └── cl_toc.h
├── Makefile
├── README.md
├── single_dump.sh
├── src
│   ├── clboot
│   │   └── clboot.c
│   ├── cld
│   │   └── cld.c
│   ├── clinit
│   │   └── clinit.c
│   ├── core
│   │   └── core0.c
│   ├── flow
│   │   └── flow0.c
│   ├── hal
│   │   └── hal0.c
│   ├── link
│   │   └── link0.c
│   ├── monitor
│   │   ├── .nfs.8180f1a2.5aaa4.4
│   │   ├── .nfs.818142e8.5aaa4.4
│   │   ├── .nfs.8182daea.5aaa4.4
│   │   ├── .nfs.81870104.5aaa4.4
│   │   ├── .nfs.81876a53.5aaa4.4
│   │   ├── .nfs.8187d662.5aaa4.4
│   │   ├── .nfs.8187fa1d.5aaa4.4
│   │   ├── .nfs.8188f583.5aaa4.4
│   │   ├── .nfs.81895f53.5aaa4.4
│   │   ├── .nfs.8189ddaa.5aaa4.4
│   │   ├── .nfs.818cfa69.5aaa4.4
│   │   ├── .nfs.818d2fcc.5aaa4.4
│   │   ├── .nfs.818d72b1.5aaa4.4
│   │   ├── .nfs.818dc014.5aaa4.4
│   │   ├── .nfs.818e1f1d.5aaa4.4
│   │   ├── .nfs.8190a368.5aaa4.4
│   │   ├── .nfs.8197ae7d.5aaa4.4
│   │   ├── .nfs.8197e4da.5aaa4.4
│   │   ├── .nfs.819d3e2f.5aaa4.4
│   │   ├── .nfs.819db378.5aaa4.4
│   │   ├── .nfs.81d5f1a7.69804.4
│   │   ├── .nfs.81d702e1.69804.4
│   │   ├── .nfs.81f6b82b.75fb4.4
│   │   ├── .nfs.81f7161b.75fb4.4
│   │   ├── .nfs.81f7495c.75fb4.4
│   │   ├── monitor_curses.h
│   │   ├── monitor_input.c
│   │   ├── monitor_input.h
│   │   ├── monitor_shm.c
│   │   ├── monitor_shm.h
│   │   ├── monitor_state.c
│   │   ├── monitor_state.h
│   │   ├── monitor_ui.c
│   │   ├── monitor_ui.h
│   │   ├── monitor.c
│   │   ├── tabs
│   │   │   └── tab_dashboard.c
│   │   └── tabs.h
│   ├── oracle
│   │   └── oracle0.c
│   └── wire
└── tools
    ├── cl_abi_report
    │   ├── cl_abi_report.c
    │   └── README.md
    ├── cl_dummy_shm
    │   └── cl_dummy_shm.c
    └── cl_shm_dump
        ├── cl_shm_dump.c
        └── README.md

46 directories, 214 files

<<< END FILE: ./.nfs.82bdb153.081d4.4

>>> START FILE: ./BUILD REQUIREMENTS.md
BUILD_REQUIREMENTS.md
Zweck

Diese Datei definiert die Build- und Laufzeit-Voraussetzungen für CommanderLink (CL) auf den Zielplattformen:

Linux (openSUSE Tumbleweed / Arch)

GhostBSD (FreeBSD-Basis)

OmniOS (illumos)

Grundsatz:
CL wird als Binary ausgeliefert. Externe Libraries werden nur verlangt, wenn sie Host-Requirement sind (z. B. OpenSSL). Kompressionsbibliotheken wie LZ4 werden mitgeliefert/vendored, sofern wir sie verwenden.

1) Gemeinsame Anforderungen (alle Plattformen)
1.1 Toolchain

C-Compiler: GCC oder Clang (C11)

Make: GNU make empfohlen (auf illumos zwingend als gmake)

Standard-Header und libc

1.2 Curses UI (Monitor)

ncurses/curses Development Header + Library

Wegen OS-Unterschieden (Headerpfad / Libraryname) wird ein Wrapper genutzt (z. B. monitor_curses.h), der auf die richtige Include-Variante mappt. ncurses/curses Header-Varianten sind historisch unterschiedlich. 
FreeBSD Handbuchseiten
+1

1.3 Security (Join/Trust paranoid)

OpenSSL ist Host-Requirement für OOB-Auth/Join/Trust.

CL verweigert Join (Default-deny), wenn OpenSSL fehlt oder zu alt ist.

OpenSSL wird nicht vendored (Security-Patch-Pflege bleibt Host-Aufgabe).

2) Linux (openSUSE Tumbleweed / Arch)
2.1 Pflicht (Build)

gcc oder clang

make

pkg-config (optional, aber praktisch)

ncurses dev headers + lib (für Monitor)

libpthread/librt sind Teil der glibc Umgebung (typisch)

Beispiel: openSUSE Tumbleweed
sudo zypper install -t pattern devel_basis
sudo zypper install ncurses-devel

Beispiel: Arch
sudo pacman -S --needed base-devel ncurses

2.2 Optional (Performance Backends)
AF_XDP (BYPASS)

Kernel muss AF_XDP unterstützen; CL nutzt den Kernel-Mechanismus UMEM + XSK rings (SPSC rings) wie in Kernel-Doku beschrieben. 
Kernel-Dokumentation
+2
kernel.org
+2

Optional: libbpf/bpftool nur, wenn ihr XDP-Programme laden wollt (v0.1 kann BYPASS capability-gated sein).

Wichtig: UMEM „chunk size“ beeinflusst Kapazität/Max-Packet-Size; Kernel-Doku beschreibt Chunk-Beziehung. 
Kernel-Dokumentation
+2
kernel.org
+2

3) GhostBSD / FreeBSD

GhostBSD ist FreeBSD-basiert, daher gelten FreeBSD-Manpages und Base-System-Konventionen.

3.1 Pflicht (Build)

Compiler: cc (Clang in Base) oder GCC

make / gmake (je nach Ports)

ncurses/curses: FreeBSD bringt ncursesw in der Base; Header liegt typischerweise unter /usr/include/ncurses.h. 
The FreeBSD Forums
+1

Optionaler Build-Komfort
pkg install gmake

3.2 Optional (Performance Backends)
netmap (BYPASS)

netmap ist ein Framework für sehr schnelles Packet I/O; FreeBSD manpage ist Primärreferenz. 
FreeBSD Handbuchseiten
+1

Wenn netmap genutzt wird, müssen Kernel/Driver dies unterstützen (capability-gated).

4) OmniOS / illumos
4.1 Pflicht (Build)

GCC (OmniOS liefert verschiedene GCC-Packages; Beispiel: gcc14)

GNU make: Paketname ist developer/build/gnu-make (liefert gmake). 
OmniOS
+2
GitHub
+2

System-Header: system/header (für Build-Header; OmniOS nutzt pkg)

Beispiel (OmniOS)
pfexec pkg refresh
pfexec pkg install developer/build/gnu-make
pfexec pkg install library/ncurses
pfexec pkg install system/header


Hinweis: OmniOS Katalog führt developer/build/gnu-make explizit. 
OmniOS
+2
GitHub
+2

4.2 curses/ncurses Besonderheiten

OmniOS kann curses.h statt ncurses.h bereitstellen bzw. symlink-Strukturen nutzen. Deshalb wird weiterhin ein Wrapper-Header verwendet, der die richtige Include-Variante wählt und die korrekte Library (-lcurses oder -lncurses) linkt. 
FreeBSD Handbuchseiten
+1

4.3 Optional (Performance Backends)

OmniOS ist bei BYPASS-Mechanismen konservativer. Für v0.1 ist die Baseline:

UDP (Tier-0)

TCP fallback

netmap ist primär BSD-Ökosystem; OmniOS benötigt eigene Treiberpfade → wird capability-gated und später konkretisiert, wenn Treiber/Kernel-Support belegt ist.

5) Laufzeit-Anforderungen (alle Plattformen)
5.1 Privilegien

CL Daemon läuft als Systemdienst, i. d. R. mit Root/CAP-Äquivalent, weil:

Overlay-Interface (tun) anlegen

Routes setzen (/32 host routes)

ggf. Bypass-Queues initialisieren (capability-gated)

5.2 Ports / Firewall

OOB: UDP/4343

Baseline Data Plane: UDP (intern) + optional TCP fallback

In paranoid join: ohne gültige Auth-OOB wird kein Datenpfad aktiviert.

5.3 Optional: ZFS Visibility

Auf OmniOS und ggf. FreeBSD (OpenZFS) werden ZFS-Daten über OS-Interfaces/Tools gesammelt (z. B. arcstat/zpool). CL benötigt keine Kernel-Hacks; es zeigt den Zustand an.

6) CI / Verifikation (Empfehlung)

Linux + FreeBSD + OmniOS Builds als Pflichtmatrix (Monitor + Dummy-SHM).

ABI-Assertions müssen in jedem Build grün sein (sizeof/offset).

Sobald stabil: -Werror für Monitor-Build aktivieren (Phase-Gate).

<<< END FILE: ./BUILD REQUIREMENTS.md

>>> START FILE: ./docs/.nfs.81897eb6.63604.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./docs/.nfs.81897eb6.63604.4

>>> START FILE: ./docs/.nfs.818a45af.63604.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./docs/.nfs.818a45af.63604.4

>>> START FILE: ./docs/ABI_LAYOUT.md
# CommanderLink ABI/Layout-Vertrag (FINAL)

Dieses Dokument ist die **normative ABI-Verfassung** für CommanderLink.  
Es definiert das Speicherlayout, die Größen, die Feldordnung und die Regeln, nach denen Änderungen zulässig sind.

CommanderLink ist **physikgetrieben**: Cacheline-Geometrie, Register-Breiten, deterministische Speicherbewegung.  
Portabilität ist Mittel zum Zweck, nicht Ziel. **Stabilität + Determinismus** sind Ziel.

---

## 1. Grundgesetze

### 1.1 Maximalmodell-Prinzip
- **Das Maximum ist das Minimum.**
- Abwesenheit ist **ein Zustand**, keine Lücke.
- Jedes Feature ist modelliert als:
  - `possible` (kann Hardware/OS prinzipiell?)
  - `effective` (wird aktuell genutzt?)
  - `state` (UNSUPPORTED/DISABLED/IDLE/ACTIVE/UNKNOWN/FAULT)
  - `reason` + `constraint_flags`
  - `source` + `quality`

### 1.2 Zero-Transformation (Standard)
- Im Hot-Path sind **Transformationen verboten**:
  - kein Shift/Rotate/Pack/Shuffle/Repack
  - kein hot memcpy
  - keine Endian-Konvertierung im Hot-Path
- Erlaubt ist nur:
  - `load → compare → store`
- Geometrie (Headroom/Alignment) wird **einmalig im Setup** festgelegt.

### 1.3 Endianness
- SHM ist **Host-Order** (keine ntohl/htonl-Kaskaden).
- Wire/OOB ist **explizit little-endian** (`*_le`) und wird an der Wire-Grenze konvertiert.
- Root enthält `endian_magic` zur Laufzeitprüfung.

### 1.4 Keine `packed`-Layouts im SHM
- `packed` ist in SHM-Segmenten verboten.
- SHM nutzt Cacheline-Unions (`raw[64]`) bzw. Page-Unions (`raw[4096]`).
- Jede Größe wird über `_Static_assert` hart abgesichert.

### 1.5 Atomics
- Atomics sind Sichtbarkeit, nicht Zähler-Müll:
  - **keine Atomics in inneren Paket-Loops**
  - Commit/Updates **pro Batch** (lokal aggregieren, dann 1 atomic add/store)
- Bei `_Atomic`-Felder ist Memory-Order im Code dokumentiert:
  - Hot: i.d.R. relaxed + Release beim Publish, Acquire beim Read
  - Monitor: Acquire

### 1.6 Alignment-Rounding (wichtiger Compiler-Fakt)
- **Wenn ein struct mit großem Alignment (z. B. 1024/4096) versehen wird, kann der Compiler die Gesamtgröße auf ein Vielfaches runden.**
- Darum: Records müssen exakt die Zielgröße treffen, sonst driftet das Layout (z. B. 1024→2048).
- Jede Zielgröße wird mit `_Static_assert(sizeof(...) == N)` erzwungen.

---

## 2. Runtime Kern: Root & TOC

### 2.1 Root (Core-SHM)
- Typ: `cl_root_4096_t` (alias `cl_root_t`)
- Größe: **4096 Bytes**
- Normfläche: `raw[4096]`
- Enthält:
  - Schema-/Endianness-Check (`schema_version`, `endian_magic`)
  - Identitäten (`mesh_tag64`, `node_tag64`)
  - Truth-States (`path_state`, `backend_active`, `mode_active`, `profile_active`)
  - Gates (`rx_gate`, `tx_gate`)
  - Constraints (`constraint_flags`, `reason_code`)
  - TOC pointer (`toc_offset`, `toc_size`)
  - Bulk presence (`bulk_present`, `bulk_epoch`)
- ABI: append-only innerhalb `raw[4096]`

**Runtime-Invariant:**
- Root ist die „Notfall-Wahrheit“. Kein Modul darf Root „interpretieren“, nur lesen/schreiben gemäß Owner-Regeln.

### 2.2 TOC (Table of Contents)
- Typ: `cl_toc_t`
- `cl_toc_entry_t` Größe: **64 Bytes** (Cacheline)
- `CL_TOC_MAX_SEGMENTS = 128`
- `sizeof(cl_toc_t) = 24 + 128*64 = 8216`

**TOC Entry Felder (host-order):**
- `type`, `flags`
- `offset_bytes`, `stride_bytes`, `count`
- `hot_off/hot_len`, `warm_off/warm_len`, `cold_off/cold_len`
- `upd_class`
- `src_tag`, `qual_tag`

**Invariants:**
- Entry ist exakt 64B.
- `offset_bytes` ist aligned zu `stride_bytes` (mindestens).
- Segmente werden niemals „implizit“ gefunden. TOC ist die Wahrheit.

---

## 3. Segment-Geometrie (Strides)

### 3.1 Fixe Strides (Gesetz)
- 256B, 512B, 1024B, 4096B
- jedes Segmentrecord ist Vielfaches von 64B Cachelines
- `raw[64]` Unions als Normfläche pro Line
- `raw[4096]` als Normfläche pro Page-Segment (Bulk)

### 3.2 Segmentliste (aktueller Stand)
Control/Policy:
- `cl_seg_link_256_t`
- `cl_seg_budget_256_t`
- `cl_seg_time_256_t`
- `cl_seg_overlay_256_t`
- `cl_seg_board_512_t`

Inventory:
- `cl_seg_cpu_1024_t`
- `cl_seg_nic_512_t`
- `cl_seg_mem_256_t`
- `cl_seg_pcie_256_t`

Mesh:
- `cl_seg_mesh_neighbor_256_t`
- `cl_seg_mesh_peer_256_t`

Bulk/Meta:
- `cl_seg_dma_4096_t`
- `cl_seg_history_4096_t`
- `cl_seg_forensics_4096_t`
- `cl_seg_zfs_4096_t`

---

## 4. Source/Quality Pflicht

Jeder Segment-Record enthält (mindestens einmal):
- `src` (cl_source_t) und `qual` (cl_quality_t)

**Regel:**
- Fehlende Daten werden nicht „0“ – sondern:
  - Feature state = UNSUPPORTED/UNKNOWN/DISABLED
  - `src/qual` entsprechend setzen
  - `reason_code/constraint_flags` erklären, warum

---

## 5. String- und Herstellerdaten

### 5.1 Grundsatz
- Hersteller/Name/Serial sind Pflicht zur Transparenz (Monitor-Anforderung).
- Strings gehören in COLD (statisch), niemals in HOT.

### 5.2 64B-Line Disziplin
- Keine 64B Cold-Line darf durch Strings >64B gesprengt werden.
- Längere Labels werden über mehrere Cold-Lines verteilt (z. B. CPU cold_b/cold_c).
- Das ist kein Workaround, sondern Normflächenprinzip.

---

## 6. Build-/ABI-Checks (Pflicht)

### 6.1 Compile-Time
- Jeder Segmenttyp hat `_Static_assert(sizeof(...) == STRIDE)`
- `cl_root_4096_t` hat `_Static_assert(sizeof(...) == 4096)`
- `cl_toc_entry_t` hat `_Static_assert(sizeof(...) == 64)`
- Bei großen Alignments (1024/4096) ist size-assert zwingend.

### 6.2 Laufzeit
- `cl_shm_dump` muss Root + TOC lesen können, ohne UB
- Root `endian_magic` muss passen
- `toc_offset + sizeof(cl_toc_t)` muss im Mapping liegen

---

## 7. Änderungsregeln (Append-only)

### 7.1 Was ist erlaubt
- Neue Felder werden **nur in reservierte Bereiche** gesetzt oder in neue Lines/COLD-Erweiterungen verschoben.
- Segment-Strides bleiben gleich.
- TOC kann neue Segmente hinzufügen (bis 128).
- Schema-Version wird erhöht, wenn Semantik/Interpretation sich ändern.

### 7.2 Was ist verboten
- Reordering von bestehenden Feldern in einer Line
- Entfernen/Umbenennen von Feldern ohne Kompatibilitätsbrücke
- `packed` in SHM
- implizite Padding-Annahmen
- „nur für einen Compiler“ Anpassungen

---

## 8. Performance- und Energie-Regel (aggressiv, aber gated)

- CommanderLink darf **aggressiv** Ressourcen nutzen (CPU bis 100%, SIMD bis Maximum), wenn:
  - Budget nicht SHADOW/RECLAIM
  - Thermal/VRM/Power Gates offen
  - Security/Join Trust ok
- Drosselung ist **sofort** und **lokal** (nur betroffene Ressource/Link).

---

## 9. Tooling

- `cl_dummy_shm` erzeugt Core-SHM + TOC + Segment-Records deterministisch.
- `cl_shm_dump` ist Truth-Viewer zur ABI-Prüfung.
- Monitor2 wird ausschließlich aus TOC/Segmente lesen, nicht aus Legacy-Strukturen.

---

## 10. Checkliste für Review

Vor jeder Layout-Änderung:
1) Betrifft es SHM? → `packed` verboten
2) Bleibt jede Line 64B? → `_Static_assert`
3) Bleibt Segmentstride gleich? → `_Static_assert`
4) Bleibt Root 4096? → `_Static_assert`
5) Wird Source/Quality/State/Reason abgebildet? → Pflicht
6) Ist es append-only? → Pflicht
7) Laufen Dummy + Dump auf Linux/BSD/OmniOS? → Pflicht

---


<<< END FILE: ./docs/ABI_LAYOUT.md

>>> START FILE: ./docs/ENGINEERING_RULES.md
# CommanderLink – ENGINEERING RULES

## Zweck
Dieses Dokument definiert die unverrückbaren technischen Grundregeln
für CommanderLink (CL).

CommanderLink ist kein „Framework“, kein „Netzwerktool“ und kein
Standard-Stack.  
CommanderLink ist eine **physiknahe Datenmaschine**.

Diese Regeln gelten **immer** – unabhängig von Plattform, Version oder
Implementierungsdetails.

---

## 1. Primat der Physik

- Hardware ist kein Abstraktionsdetail.
- Cachelines, Register, Busbreiten und Speicherhierarchien sind reale
  physikalische Objekte.
- Software muss sich **der Hardware anpassen**, nicht umgekehrt.

**Konsequenz:**  
„Best Practice“, wenn sie der Physik widerspricht, wird ignoriert.

---

## 2. Zieldefinition

CommanderLink maximiert **gleichzeitig**:

1. Durchsatz
2. Energieeffizienz pro Bit
3. Determinismus
4. Stabilität
5. Hardware-Schutz

Keiner dieser Punkte darf isoliert optimiert werden.

---

## 3. Stabilität vor Geschwindigkeit

- Ein System, das abstürzt, ist wertlos.
- Jeder aggressive Pfad benötigt:
  - Validity Gates
  - Hysterese
  - Sofortige Fallbacks

**Fail-Open Regel:**  
Wenn CL stirbt, bleibt das Betriebssystem funktionsfähig.

---

## 4. Keine impliziten Annahmen

- Keine impliziten Padding-Regeln
- Keine impliziten Alignments
- Keine impliziten Typgrößen
- Keine impliziten Endianness-Annahmen

Alles ist explizit oder verboten.

---

## 5. Messbarkeit

Jede Entscheidung in CL muss messbar sein:
- im Shared Memory
- im Monitor
- in Forensik-Logs

Was nicht sichtbar ist, existiert nicht.

---

## 6. Menschenlesbarkeit

- Code ist auf Deutsch kommentiert.
- Jede Struktur erklärt **warum**, nicht nur **was**.
- Kommentare sind Teil des Vertrags.

---

## 7. Erweiterbarkeit ohne ABI-Bruch

- Strukturen wachsen nur über reservierte Felder.
- Alte Monitore dürfen neue Felder ignorieren können.
- Schema-Versionierung ist Pflicht.

---

## 8. Energie ist erlaubt

- 100 % CPU-Last ist erlaubt.
- AVX-512 Volllast ist erlaubt.
- Hoher Stromverbrauch ist erlaubt.

**Solange:**
- Thermik-Gates offen sind
- VRM-Safety nicht verletzt wird
- OS-Interaktivität nicht leidet

---

## 9. Schlussformel

CommanderLink ist kein Kompromiss.

CommanderLink ist:
> **Investment Protection durch Maximierung**


<<< END FILE: ./docs/ENGINEERING_RULES.md

>>> START FILE: ./docs/laws/00_PHYSICS.md
# LAW_00_PHYSICS.md
## CommanderLink – Gesetz der Physik (Grundgesetz)

**Status:** ENTWURF (normativ nach Freigabe)  
**Geltungsbereich:** Gesamtsystem (Design, Header, Runtime, Tools, Monitor)  
**Priorität:** Höchste – steht über allen weiteren LAWs

---

## 0. Zweck
Dieses Gesetz definiert die **oberste Wahrheit** für CommanderLink.  
Alle Entscheidungen sind **physikalisch deterministisch** zu treffen.  
Software dient der **Ausnutzung der Hardware**, nicht umgekehrt.

---

## 1. Rangordnung der Wahrheit
Bei Konflikten gilt strikt folgende Priorität (absteigend):

1. **Physikalische Realität**
   - Elektrische, thermische, zeitliche Grenzen
   - Cache-/TLB-/NUMA-Effekte, DMA-Geometrie
2. **Mikroarchitektur**
   - Pipeline, SIMD-Breite, Register, Prefetch, Power-States
3. **ABI-Stabilität**
   - Layout, Alignment, Größenverträge, Offsets
4. **Betriebssystem-Koexistenz**
   - Scheduling, Routing, I/O-Pfade
5. **Externe Standards**
   - POSIX, RFCs, Ethernet, TCP/UDP, API-Konventionen

**Ein Standard darf niemals die Physik überstimmen.**

---

## 2. Plattform-Fixierung
- Zielarchitektur: **x86_64**, little-endian
- Hersteller: **Intel & AMD**
- Annahmen:
  - Cacheline = **64 Byte**
  - Registerbreite ≥ **64 Bit**
- Andere Architekturen sind **nicht normativ**, nur optional adaptierbar.

---

## 3. Zero-Transformation-Prinzip
- Keine impliziten Umrechnungen, kein „Parsing-Overhead“.
- Datengeometrie ist **explizit**:
  - Wire → Execution Context → Register ist definiert.
- Transformation ist **verboten**, außer:
  - explizit genehmigt
  - physikalisch notwendig
  - im LAW referenziert

---

## 4. Cacheline-Souveränität
- **64-Byte-Normfläche** ist das atomare Bauelement.
- Alle ABI-relevanten Strukturen:
  - sind Vielfache von 64 Byte
  - enthalten explizites Padding
  - besitzen `raw[64]`-Union oder äquivalente Normfläche
- **False Sharing ist ein Fehler**, kein Optimierungsfall.

---

## 5. Maximierungsprinzip
- **Maximum ist das Minimum.**
- CL nutzt **immer** die maximal physikalisch mögliche Leistung,
  **sofern** alle GATES offen sind.
- Drosselung erfolgt **nur** bei:
  - Thermal / VRM / Power-Gates
  - Interaktivitäts-Gates
  - Sicherheits-/Trust-Gates

---

## 6. Energie & Thermik
- Energieverbrauch ist **kein Makel**, sondern Messgröße.
- Schutzmechanismen:
  - Hardware-gesteuert (Throttling)
  - softwareseitig sichtbar (Gates)
- Software darf **nicht** künstlich bremsen,
  sondern **reaktiv** auf physikalische Grenzen reagieren.

---

## 7. SIMD-Grundsatz
- SIMD ist **Baseline**, kein Sonderfall.
- Leiter:
  - SSE4 → AVX2 → AVX-512
- Nutzung nur, wenn:
  - Effizienzgewinn real
  - Isolation möglich
  - GATES offen
- Sporadischer SIMD-Einsatz in Latenzpfaden ist **verboten**.

---

## 8. Koexistenz statt Dominanz
- CL ist **Symbiont**, kein Eroberer.
- OS bleibt souverän.
- CL darf:
  - Kerne pinnen
  - Ressourcen reservieren
- CL darf **nicht**:
  - Kernel ersetzen
  - Default-Routen kapern
  - OS destabilisieren

---

## 9. Auditierbarkeit
- Jeder physikalische Zustand ist:
  - sichtbar
  - messbar
  - reproduzierbar
- „Best effort“ ist **markierter Ausnahmezustand**, nie Default.

---

## 10. Ableitungsregel
Jedes weitere LAW muss:
- dieses Gesetz **explizit referenzieren**
- keine Regel einführen, die ihm widerspricht
- physikalisch begründet sein

---

## 11. Schlussformel
CommanderLink folgt **keinen Moden**.  
CommanderLink folgt **keinen Dogmen**.  
CommanderLink folgt **der Physik**.

**PHYSICS FIRST. x86_64 FIRST.**


<<< END FILE: ./docs/laws/00_PHYSICS.md

>>> START FILE: ./docs/laws/ANNEX_36_SHM_ENFORCEMENT.md
# ANNEX_36_SHM_ENFORCEMENT.md
## CommanderLink – SHM‑Erzwingungs‑ & Präzisions‑Annex
### Ergänzung zu LAW_35_ABI, LAW_36_SHM, MEMORY_MODEL

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieser Annex schärft die bestehenden SHM‑ und ABI‑Gesetze
auf **mechanisch erzwingbare Präzision** nach.

Er basiert auf dem aktuellen CommanderLink‑Projektstand
(ABI‑Report, Runtime‑Header, Segmentdefinitionen, Monitor).

Ziel ist:
- Eliminierung impliziter Annahmen
- Erzwingung physikalischer Invarianten
- Eindeutige Maschinenverträge für zukünftige KIs

---

## 1. Cacheline‑Konstante ist ABI‑Teil

### 1.1 Normative Konstante

Für CommanderLink gilt:

CL_CACHELINE_BYTES = 64

Diese Konstante ist:
- ABI‑relevant
- SHM‑relevant
- Tool‑relevant

---

### 1.2 Verifikation

Der ABI‑Report MUSS ausgeben:

- cacheline_bytes
- alignment_basis

Abweichung von 64 Byte führt zu:

RESULT: ABI_INVALID

---

## 2. Segment‑Header müssen Konsistenz explizit machen

### 2.1 Pflichtfelder pro Segment

Jeder SHM‑Segment‑Header MUSS enthalten:

- `schema_version`
- `segment_epoch`
- `segment_state`
- `owner_domain`

Diese Felder sind:
- Hot oder Warm klassifiziert
- ABI‑belegt
- maschinenlesbar

---

### 2.2 Segment‑Epoch

`segment_epoch` ist:

- monoton steigend (`u64`)
- Publish‑Token für das gesamte Segment
- einzig zulässiger Sichtbarkeitsanker

---

## 3. Publish / Consume ist verpflichtend pro Segment

### 3.1 Writer‑Pflicht

Ein Writer MUSS:

1. Segmentdaten schreiben
2. `segment_epoch` mit `store_release` erhöhen

Andere Reihenfolgen sind verboten.

---

### 3.2 Reader‑Pflicht

Ein Reader MUSS:

1. `segment_epoch` mit `load_acquire` lesen
2. Segmentdaten lesen
3. optional erneut `segment_epoch` prüfen

Mismatch → Retry oder Abbruch

---

## 4. Non‑Atomic Felder: explizite Zulässigkeit

### 4.1 Verbot

Non‑atomic Felder ohne zugeordnetes Token
sind **Undefined Behavior**.

---

### 4.2 Erlaubnis

Non‑atomic Felder sind nur erlaubt, wenn:

- sie einer Konsistenzgruppe zugeordnet sind
- diese Gruppe ein Token besitzt
- Zugriff ausschließlich nach Acquire erfolgt

---

## 5. Interference‑Klassen sind ABI‑Eigenschaft

### 5.1 Klassen

CommanderLink kennt exakt zwei Klassen:

| Klasse | Fenster |
|------|--------|
| CACHELINE | 64 Byte |
| DESTRUCTIVE | 128 Byte |

---

### 5.2 DESTRUCTIVE‑Klasse (Pflicht)

Die DESTRUCTIVE‑Klasse ist verpflichtend für:

- Cursor (head/tail)
- Epoch‑Zähler
- Heartbeats
- Rate‑Limiter
- globale Gates

Diese Felder dürfen:
- keine schreibenden Nachbarn
  innerhalb ±64 Byte haben

---

### 5.3 ABI‑Bindung

Die Interference‑Klasse eines Feldes:

- ist Teil des ABI
- darf nicht geändert werden
- ist im ABI‑Report auszuweisen

---

## 6. AVX‑512 ist ein globaler Systemzustand

### 6.1 AVX‑Fenster

AVX‑512‑Ausführung erzeugt den Zustand:

AVX_HEAVY_WINDOW

Dieser Zustand:

- ist nicht thread‑lokal
- beeinflusst Frequenz und Latenz
- besitzt eine Nachlaufzeit

---

### 6.2 Normative Regeln

- AVX‑512 ist nur erlaubt in:
  - dedizierten Worker‑Threads
  - explizit gepinnten Cores
- Control‑Plane, Watchdog, Gates:
  - AVX‑frei
- AVX‑Fenster ist Gate‑relevant

---

## 7. Non‑Temporal Stores

### 7.1 Klassifikation

Non‑Temporal Stores sind:

- kein Default
- kein Ersatz für normale Stores
- ein Spezialpfad

---

### 7.2 Regeln

- Nur in Cold/Bulk‑Segmenten erlaubt
- Nie für:
  - Tokens
  - Epochs
  - Statusfelder
- Sichtbarkeit MUSS explizit hergestellt werden

---

## 8. ABI‑Pflichtangaben pro Feld

Für jedes SHM‑Feld MUSS dokumentiert sein:

- Owner‑Domain
- Konsistenzgruppe
- Token‑Zugehörigkeit
- Memory‑Order
- Interference‑Klasse

Fehlende Angaben machen das Feld ungültig.

---

## 9. Tooling‑Pflicht

### 9.1 ABI‑Report

Der ABI‑Report MUSS enthalten:

- Feldgröße
- Alignment
- Offset
- Interference‑Klasse
- Token‑Referenz

---

### 9.2 Monitor

Der Monitor MUSS:

- Segment‑Epochs anzeigen
- AVX‑Zustand sichtbar machen
- Reclaim‑Zustände anzeigen

---

## 10. Schlussformel

Shared Memory ist kein Datenmodell.

Es ist ein **physikalischer Vertrag**
zwischen CPU, Cache und Beobachter.

Wer diese Regeln verletzt,
verlässt Determinismus.

Mit diesem Annex ist
CommanderLink‑SHM **erzwingbar präzise**.

Perfekt.  
Hier ist **alles als ein einziges, zusammenhängendes Markdown‑Dokument**, **ohne Unterbrechung**, **ohne Kommentare**, **ohne Meta**, **direkt copy‑&‑paste‑fähig**.


# ANNEX_36_SHM_COMPLETE.md
## CommanderLink – SHM‑Erzwingungs‑, Memory‑Order‑ & Segment‑Wahrheits‑Annex
### Ergänzung zu LAW_35_ABI, LAW_36_SHM, MEMORY_MODEL

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieser Annex schärft die bestehenden SHM‑ und ABI‑Gesetze
auf **mechanisch erzwingbare Präzision** nach.

Er basiert auf dem aktuellen CommanderLink‑Projektstand
(ABI‑Report, Runtime‑Header, Segmentdefinitionen, Monitor).

Ziel ist:
- Eliminierung impliziter Annahmen
- Erzwingung physikalischer Invarianten
- Eindeutige Maschinenverträge für zukünftige KIs

---

## 1. Architekturannahmen (bindend)

Dieser Annex gilt ausschließlich für:

- x86_64
- Little‑Endian
- Write‑Back (WB) Cacheable Memory
- Cacheline‑Größe: **64 Byte**

Andere Memory‑Typen (UC, WC, MMIO) sind **nicht** Teil dieses Modells.

---

## 2. Cacheline‑Konstante ist ABI‑Teil

### 2.1 Normative Konstante

CL_CACHELINE_BYTES = 64


Diese Konstante ist:
- ABI‑relevant
- SHM‑relevant
- Tool‑relevant

### 2.2 Verifikation

Der ABI‑Report MUSS ausgeben:

- cacheline_bytes
- alignment_basis

Abweichung von 64 Byte führt zu:


RESULT: ABI_INVALID

---

## 3. Publish / Consume ist das einzige Synchronisationsmodell

### 3.1 Grundsatz

Shared‑Memory‑Konsistenz entsteht **ausschließlich**
durch explizite **Publish / Consume‑Token**.

Implizite Ordnung ist unzulässig.

---

### 3.2 Konsistenzgruppe

Eine Konsistenzgruppe besteht aus:

- beliebigen Datenfeldern (non‑atomic erlaubt)
- **genau einem** Sichtbarkeits‑Token

Das Token ist das **einzige** synchronisierende Element.

---

### 3.3 Publish‑Regel (Writer)

Ein Writer MUSS:

1. alle Datenfelder schreiben  
2. anschließend das Token schreiben mit  
   `store_release`

Andere Reihenfolgen sind verboten.

---

### 3.4 Consume‑Regel (Reader)

Ein Reader MUSS:

1. das Token lesen mit  
   `load_acquire`
2. anschließend die Datenfelder lesen

Lesen vor dem Token ist verboten.

---

### 3.5 Token‑Typen

Zulässige Token:

- `segment_epoch`
- `seq_cnt`
- `state`
- explizit benannte Visibility‑Flags

Token sind:
- immer atomic
- monoton oder zustandskodierend
- niemals Teil von Datenfeldern

---

## 4. Non‑Atomic Reads

### 4.1 Verbot

Non‑atomic Reads ohne Token‑Schutz
sind **Undefined Behavior** und verboten.

---

### 4.2 Erlaubnis

Non‑atomic Reads sind nur erlaubt, wenn:

- sie **nach** einem `load_acquire` erfolgen
- sie zur selben Konsistenzgruppe gehören
- es genau einen Writer gibt

---

## 5. Cacheline‑ und Interference‑Klassen

### 5.1 Klassen

| Klasse | Fenster |
|------|--------|
| CACHELINE | 64 Byte |
| DESTRUCTIVE | 128 Byte |

---

### 5.2 DESTRUCTIVE‑Klasse (Pflicht)

Die DESTRUCTIVE‑Klasse ist verpflichtend für:

- Cursor (head/tail)
- Epoch‑Zähler
- Heartbeats
- Rate‑Limiter
- globale Gates

Diese Felder dürfen keine schreibenden Nachbarn
innerhalb ±64 Byte haben.

---

### 5.3 ABI‑Bindung

Die Interference‑Klasse eines Feldes
ist Teil des ABI und unveränderlich.

---

## 6. AVX‑512 ist ein globaler Systemzustand

### 6.1 AVX‑Fenster

AVX‑512‑Ausführung erzeugt den Zustand:

AVX_HEAVY_WINDOW

Dieser Zustand:
- ist nicht thread‑lokal
- beeinflusst Frequenz und Latenz
- besitzt eine Nachlaufzeit

---

### 6.2 Normative Regeln

- AVX‑512 ist nur erlaubt in:
  - dedizierten Worker‑Threads
  - explizit gepinnten Cores
- Control‑Plane, Watchdog, Gates:
  - AVX‑frei
- AVX‑Fenster ist Gate‑relevant

---

## 7. Non‑Temporal Stores

### 7.1 Klassifikation

Non‑Temporal Stores sind Spezialpfade.

### 7.2 Regeln

- Nur in Cold/Bulk‑Segmenten erlaubt
- Nie für Tokens, Epochs oder Statusfelder
- Sichtbarkeit MUSS explizit hergestellt werden

---

## 8. ABI‑Pflichtangaben pro Feld

Für jedes SHM‑Feld MUSS dokumentiert sein:

- Owner‑Domain
- Konsistenzgruppe
- Token‑Zugehörigkeit
- Memory‑Order
- Interference‑Klasse

Fehlende Angaben machen das Feld ungültig.

---

## 9. Segment‑Wahrheitstabellen

---

### 9.1 Segment: LINK_256

**Writer:** LINK‑Thread  
**Reader:** Monitor, NIC, Watchdog  
**Token:** segment_epoch

| Feld | Größe | Klasse | Order | Interference |
|----|----|----|----|----|
| segment_epoch | u64 | Hot | release/acquire | DESTRUCTIVE |
| link_state | u32 | Hot | non‑atomic | CACHELINE |
| link_flags | u32 | Hot | non‑atomic | CACHELINE |
| tx_gate | u32 | Hot | non‑atomic | DESTRUCTIVE |
| rx_gate | u32 | Hot | non‑atomic | DESTRUCTIVE |
| error_flags | u64 | Warm | non‑atomic | CACHELINE |

---

### 9.2 Segment: CPU_1024

**Writer:** CPU‑Sampler  
**Reader:** Monitor, Oracle  
**Token:** segment_epoch

| Feld | Größe | Klasse | Order | Interference |
|----|----|----|----|----|
| segment_epoch | u64 | Hot | release/acquire | DESTRUCTIVE |
| cpu_freq_khz | u64 | Hot | non‑atomic | CACHELINE |
| cpu_temp_mc | u64 | Warm | non‑atomic | CACHELINE |
| avx_state | u32 | Hot | non‑atomic | DESTRUCTIVE |
| avx_window_epoch | u64 | Hot | non‑atomic | DESTRUCTIVE |

---

### 9.3 Segment: NIC_512

**Writer:** NIC‑Backend  
**Reader:** LINK, Monitor  
**Token:** segment_epoch

| Feld | Größe | Klasse | Order | Interference |
|----|----|----|----|----|
| segment_epoch | u64 | Hot | release/acquire | DESTRUCTIVE |
| tx_credits_bytes | u64 | Hot | non‑atomic | DESTRUCTIVE |
| tx_credits_pkts | u32 | Hot | non‑atomic | DESTRUCTIVE |
| rx_backpressure | u32 | Hot | non‑atomic | DESTRUCTIVE |

---

### 9.4 Segment: WATCHDOG_256

**Writer:** Watchdog  
**Reader:** Monitor  
**Token:** segment_epoch

| Feld | Größe | Klasse | Order | Interference |
|----|----|----|----|----|
| segment_epoch | u64 | Hot | release/acquire | DESTRUCTIVE |
| heartbeat_cnt | u64 | Hot | non‑atomic | DESTRUCTIVE |
| restart_count | u32 | Warm | non‑atomic | CACHELINE |

---

## 10. Globale Invarianten

- Jedes Segment besitzt genau ein Token
- Kein Feld ohne Token‑Zuordnung
- Kein DESTRUCTIVE‑Feld ohne 128B‑Isolation
- Kein AVX‑Code außerhalb Worker‑Domänen
- Monitor ist strikt read‑only

---

## 11. Schlussformel

Shared Memory ist kein Datenmodell.

Es ist ein **physikalischer Vertrag**
zwischen CPU, Cache und Beobachter.

Mit diesem Annex ist CommanderLink
**erzwingbar deterministisch**.



<<< END FILE: ./docs/laws/ANNEX_36_SHM_ENFORCEMENT.md

>>> START FILE: ./docs/laws/LAW_00_PHYSICS.md
# LAW_00_PHYSICS.md
## CommanderLink – Physikalisches Grundgesetz

### Status
VERBINDLICH · NORMATIV · NICHT DISKUTABEL

---

## 0. Präambel

CommanderLink ist ein physikalisches System.  
Alle weiteren Gesetze, Verträge, Header und Implementierungen sind diesem Gesetz untergeordnet.

Physik ist die oberste Autorität.  
Spezifikationen, Konventionen, Standards und „Best Practices“ haben keinerlei Vorrang.

---

## 1. Rangordnung der Wahrheit

Die Gültigkeit von Aussagen, Entscheidungen und Messungen folgt strikt dieser Ordnung:

1. Physikalische Realität (Zeit, Energie, Temperatur, elektrische Grenzen)
2. Mikroarchitektur (Caches, Pipelines, TLBs, SIMD, NUMA)
3. Konkrete Hardware-Implementierung (x86_64, reale CPUs, reale NICs)
4. ABI-Verträge (Binärlayout, Alignment, Atomics)
5. Betriebssystem-Verträge
6. Protokolle und formale Spezifikationen

Bei Konflikt gilt immer die höhere Ebene.  
Ein Verstoß gegen diese Ordnung ist ein Designfehler.

---

## 2. Zeit ist endlich

Zeit ist eine physikalische Ressource.

* Jede Operation verbraucht Zeit.
* Zeit kann nicht parallelisiert werden.
* Zeit kann nicht abstrahiert werden.

Folgerungen:
- Worst-Case-Zeit ist maßgeblich, nicht Durchschnittswerte.
- Jitter ist ein Fehler, kein Statistikproblem.
- Ungebundene Wartezeiten sind verboten.

---

## 3. Energie ist endlich

Energie ist begrenzt und messbar.

* CPU-Zyklen sind Energieverbrauch.
* Speicherzugriffe sind Energieverbrauch.
* Netzwerktransfers sind Energieverbrauch.

Folgerungen:
- Jede Berechnung muss eine energetische Rechtfertigung haben.
- Aggressive Nutzung ist erlaubt, ineffiziente Nutzung nicht.
- Thermische Grenzen sind harte Grenzen, keine Hinweise.

---

## 4. Temperatur ist ein Zwang

Temperatur ist ein nicht verhandelbarer Zustand.

* Drosselung ist physikalisch, nicht logisch.
* Thermische Effekte treten verzögert auf.
* Überschreitung führt zu nichtlinearem Verhalten.

Folgerungen:
- Thermische Gates sind sofort wirksam.
- Kein Mechanismus darf Temperatur ignorieren.
- Performance ohne thermische Stabilität ist ungültig.

---

## 5. Speicher ist physikalisch

Speicher ist kein abstrakter Raum.

* Cache-Lines haben feste Größe.
* Alignment ist real.
* Falsches Layout erzeugt reale Kosten.

Folgerungen:
- Implizites Padding ist verboten.
- Layouts müssen cacheline-exakt sein.
- Speicherzugriffe werden nach physikalischer Nähe bewertet.

---

## 6. Parallelität ist begrenzt

Parallelität existiert nur dort, wo Hardware sie zulässt.

* Kerne sind endlich.
* Ausführungseinheiten sind endlich.
* Bandbreite ist endlich.

Folgerungen:
- Oversubscription ist ein Fehler.
- Software darf keine fiktive Parallelität annehmen.
- Scheduling darf keine physikalischen Konflikte erzeugen.

---

## 7. Latenz ist eine Eigenschaft, kein Parameter

Latenz entsteht aus Physik.

* Entfernung
* Zwischenspeicher
* Synchronisation

Folgerungen:
- Latenz kann gemessen, nicht „konfiguriert“ werden.
- Latenzreduktion hat Vorrang vor Durchsatzsteigerung, sofern stabil.
- Ungebundene Latenzpfade sind verboten.

---

## 8. Bandbreite ist ein Fluss

Bandbreite ist kontinuierlich, nicht paketweise.

* Burst-Verhalten erzeugt Störungen.
* Gleichmäßigkeit ist stabiler als Spitzen.

Folgerungen:
- Pacing ist Pflicht.
- Backpressure ist Pflicht.
- Drops sind ein physikalisches Versagen.

---

## 9. Messung ist Teil des Systems

Ein System ohne Messung ist blind.

* Messung darf das System nicht destabilisieren.
* Messung muss zeitlich korrekt sein.
* Messung ist Wahrheit, nicht Interpretation.

Folgerungen:
- Messpfade sind physikalisch zu budgetieren.
- Heuristiken ersetzen keine Messung.
- Logs sind sekundär gegenüber direkter Telemetrie.

---

## 10. Determinismus ist ein physikalisches Ziel

Determinismus bedeutet:
Gleiche Bedingungen → gleiches Verhalten.

Folgerungen:
- Zufälligkeit ist verboten.
- „Best Effort“ ist verboten.
- Nichtdeterministische APIs sind zu kapseln oder auszuschließen.

---

## 11. Fehler sind Zustände, keine Ausnahmen

Fehler entstehen aus Physik.

* Überlast
* Hitze
* Zeitüberschreitung
* Ressourcenmangel

Folgerungen:
- Fehlerpfade sind gleichwertige Pfade.
- Recovery ist Teil des Normalbetriebs.
- Undefined Behavior ist verboten.

---

## 12. Architekturbindung

CommanderLink ist primär x86_64-gebunden.

* Little-Endian ist gegeben.
* Cache-Line-Größe ist bekannt.
* SIMD-Eigenschaften sind explizit.

Portabilität ist nachrangig gegenüber physikalischer Korrektheit.

---

## 13. Schlussformel

Wenn eine Entscheidung physikalisch falsch ist,
ist sie falsch – unabhängig von Eleganz, Konformität oder Konvention.

Dieses Gesetz ist unveränderlich.  
Alle weiteren Gesetze müssen ihm widerspruchsfrei folgen.


<<< END FILE: ./docs/laws/LAW_00_PHYSICS.md

>>> START FILE: ./docs/laws/LAW_01_CPU.md
# LAW_01_CPU.md
## CommanderLink – CPU-Gesetz (x86_64)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt die Nutzung, Wahrnehmung und Belastung der CPU
für CommanderLink auf **x86_64**-Systemen.

Es beschreibt keine Implementierungen.
Es definiert verbindliche physikalische und architektonische Regeln.

---

## 1. Die CPU ist eine physikalische Maschine

Die CPU ist kein abstrakter Rechenkern.

* Kerne sind physisch.
* Ausführungseinheiten sind endlich.
* Frontend, Backend und Speicherpfade sind getrennt.

Jede Annahme einer „idealen CPU“ ist verboten.

---

## 2. Kerne sind exklusive Ressourcen

Ein CPU-Kern kann nur einen physikalischen Ausführungskontext
ohne Interferenz garantieren.

Folgerungen:
- Exklusive Nutzung ist der Referenzzustand.
- Geteilte Nutzung ist ein degradierter Zustand.
- Überschneidung erzeugt nichtlineare Effekte.

---

## 3. SMT ist kein zusätzlicher Kern

SMT/Hyper-Threading erzeugt keine neuen Ausführungseinheiten.

Folgerungen:
- SMT-Threads konkurrieren um dieselbe Physik.
- SMT darf niemals als Kapazitätserweiterung gerechnet werden.
- SMT ist optional und jederzeit entziehbar.

---

## 4. Pipelines sind endlich und zustandsbehaftet

Instruktionspipelines haben Tiefe, Latenz und Abhängigkeiten.

Folgerungen:
- Pipeline-Flushes sind reale Kosten.
- Fehlvorhersagen sind physikalische Verluste.
- Kontrollfluss ist teurer als Datenfluss.

---

## 5. SIMD ist ein physikalischer Verstärker

SIMD nutzt vorhandene Breite der Recheneinheiten.

Folgerungen:
- SIMD ist der Normalfall, nicht die Optimierung.
- Skalierung erfolgt über Vektorisierung, nicht über Threads.
- Nicht-vektorisierte Pfade gelten als degradiert.

---

## 6. Frequenz ist variabel und instabil

CPU-Frequenz ist kein konstanter Wert.

* Turbo ist opportunistisch.
* Drosselung ist zwingend.
* Übergänge sind nicht linear.

Folgerungen:
- Zeitabschätzungen dürfen keine fixe Frequenz annehmen.
- Thermal- und Power-Limits haben Vorrang.
- Performance ohne Frequenzkontrolle ist ungültig.

---

## 7. Zeitbasis ist lokal

Zeit entsteht auf der CPU.

Folgerungen:
- Lokale Zeitquellen haben Vorrang vor externen.
- Zeitstempel sind kernabhängig.
- Synchronisation kostet Zeit.

---

## 8. Preemption ist ein physikalischer Eingriff

Unterbrechungen reißen Ausführungskontexte auf.

Folgerungen:
- Preemption ist ein Störereignis.
- Latenzpfade müssen preemption-resistent sein.
- Kritische Pfade sind gegen Verdrängung zu schützen.

---

## 9. Pinning ist ein Vertrag mit der Physik

CPU-Pinning ist keine Optimierung, sondern eine Festlegung.

Folgerungen:
- Gepinnte Ausführung übernimmt Verantwortung für den Kern.
- Pinning entzieht dem System Ressourcen.
- Falsches Pinning ist ein Systemfehler.

---

## 10. Kontextwechsel sind Verluste

Jeder Kontextwechsel verursacht:

* Cache-Verlust
* Pipeline-Verlust
* Zeitverlust

Folgerungen:
- Kontextwechsel sind zu minimieren.
- Hohe Wechselraten sind ein Designfehler.
- „Leichtgewichtige“ Threads existieren physikalisch nicht.

---

## 11. Überbuchung ist verboten

Mehr Arbeit als physikalisch ausführbar zu planen ist unzulässig.

Folgerungen:
- Warteschlangen müssen begrenzt sein.
- Rückstau ist vorzuziehen gegenüber Überlast.
- Dropped Work ist besser als instabiles Systemverhalten.

---

## 12. Messung erfolgt am Kern

CPU-Messungen müssen kernnah sein.

Folgerungen:
- Aggregierte Werte sind sekundär.
- Mittelwerte verschleiern Realität.
- Worst-Case-Beobachtung ist verpflichtend.

---

## 13. Architekturbindung

CommanderLink bindet sich explizit an:

- x86_64
- Little-Endian
- bekannte Cacheline-Größen
- bekannte SIMD-Breiten

Abweichungen sind neue Architekturen und erfordern neue Gesetze.

---

## 14. Schlussformel

Die CPU bestimmt das Verhalten des Systems.
Software hat sich anzupassen, nicht umgekehrt.

Dieses Gesetz ist Grundlage aller CPU-nahen Verträge,
Layouts und Laufzeitentscheidungen.


<<< END FILE: ./docs/laws/LAW_01_CPU.md

>>> START FILE: ./docs/laws/LAW_02_MEMORY.md
# LAW_02_MEMORY.md
## CommanderLink – Speicher-Gesetz (x86_64)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Struktur, Nutzung und Bewertung von Speicher
für CommanderLink auf **x86_64**-Systemen.

Es definiert physikalische Wahrheiten.
Es enthält keine Implementierungsanweisungen.

---

## 1. Speicher ist physikalisch lokal

Speicher existiert in Stufen realer Entfernung.

* Register
* L1 / L2 / L3 Cache
* DRAM
* Remote-NUMA

Folgerungen:
- Nähe bestimmt Kosten.
- Entfernung ist nicht abstrahierbar.
- Falsche Lokalität ist ein Fehler.

---

## 2. Cache-Lines sind die atomare Einheit

Die Cache-Line ist die kleinste relevante Transporteinheit.

Folgerungen:
- Alle Hot-Daten müssen cacheline-exakt sein.
- Teilweise Nutzung ist Verschwendung.
- False Sharing ist ein Designfehler.

---

## 3. Alignment ist zwingend

Alignment ist keine Optimierung, sondern Voraussetzung.

Folgerungen:
- Implizites Alignment ist verboten.
- Strukturen müssen explizit ausgerichtet sein.
- Fehlalignment erzeugt reale Zusatzlast.

---

## 4. Layout ist ein Vertrag

Speicherlayout ist Teil der ABI-Wahrheit.

Folgerungen:
- Layouts dürfen sich nicht implizit ändern.
- Compiler-Freiheiten sind einzuschränken.
- Padding muss deterministisch sein.

---

## 5. Speicherzugriff ist teurer als Rechenlogik

Ein Speicherzugriff kostet mehr als eine Rechenoperation.

Folgerungen:
- Rechenintensität ist günstiger als Speicherintensität.
- Wiederverwendung hat Vorrang vor Neuladen.
- Datenbewegung ist zu minimieren.

---

## 6. NUMA ist Realität

NUMA ist kein Sonderfall.

Folgerungen:
- Cross-NUMA-Zugriffe sind degradierte Pfade.
- Speicher gehört zu Rechenknoten.
- Migration erzeugt reale Instabilität.

---

## 7. Atomics sind physikalische Barrieren

Atomare Operationen greifen tief in die Hardware ein.

Folgerungen:
- Atomics sind teuer.
- Globale Atomics skalieren nicht.
- Ordnung ist explizit festzulegen.

---

## 8. Konsistenz kostet Zeit

Speicherkonsistenz ist nicht kostenlos.

Folgerungen:
- Strenge Ordnung ist der teuerste Zustand.
- Lockerung ist erlaubt, Unklarheit nicht.
- Memory-Order muss bewusst gewählt werden.

---

## 9. Speicher ist endlich

Speicher ist eine begrenzte Ressource.

Folgerungen:
- Wachstum ohne Obergrenze ist verboten.
- Reclaim ist Pflicht.
- OOM ist ein Designversagen.

---

## 10. Allokation ist ein Eingriff

Allokation verändert den Systemzustand.

Folgerungen:
- Dynamische Allokation im Hot-Pfad ist verboten.
- Vorab-Reservierung ist der Referenzzustand.
- Fragmentierung ist ein Fehler.

---

## 11. Freigabe ist nicht sofort

Freigabe bedeutet nicht sofortige Wiederverwendbarkeit.

Folgerungen:
- Lebenszeiten müssen klar sein.
- Wiederverwendung ohne Stabilität ist verboten.
- Dangling States sind unzulässig.

---

## 12. Sichtbarkeit ist kontrolliert

Nicht jeder Speicher ist für jeden sichtbar.

Folgerungen:
- Shared Memory ist explizit.
- Private Daten bleiben privat.
- Sichtbarkeitsgrenzen sind Verträge.

---

## 13. Architekturbindung

CommanderLink bindet sich an:

- x86_64 Speicherordnung
- Cache-Line-basierte Kohärenz
- Little-Endian Darstellung

Andere Architekturen erfordern neue Gesetze.

---

## 14. Schlussformel

Speicher bestimmt Geschwindigkeit, Stabilität und Wahrheit.

Ein fehlerhaftes Speicherdesign
kann durch keine Logik kompensiert werden.

Dieses Gesetz ist Grundlage aller Layout-,
ABI- und Runtime-Entscheidungen.

<<< END FILE: ./docs/laws/LAW_02_MEMORY.md

>>> START FILE: ./docs/laws/LAW_03_NETWORK.md
# LAW_03_NETWORK.md
## CommanderLink – Netzwerk-Gesetz (Physik des Drahts)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt alle Formen von Datenübertragung
über physische oder virtuelle Netzwerke
für CommanderLink.

Es beschreibt die physikalische Realität des Transports.
Es ignoriert abstrahierende Protokollmodelle.

---

## 1. Das Netzwerk ist ein physikalisches Medium

Ein Netzwerk ist kein logischer Kanal.

* Signale benötigen Zeit.
* Medien haben Bandbreite.
* Übertragung erzeugt Verluste.

Jede Annahme eines „idealen Links“ ist verboten.

---

## 2. Latenz ist durch Physik bestimmt

Netzwerklatenz entsteht aus:

* Ausbreitung
* Serialisierung
* Puffern
* Verarbeitung

Folgerungen:
- Latenz ist nicht konfigurierbar.
- Latenz ist richtungsabhängig.
- Jitter ist ein Fehlerzustand.

---

## 3. Bandbreite ist endlich

Bandbreite ist ein kontinuierlicher Fluss.

Folgerungen:
- Line-Rate ist ein Grenzzustand.
- Überbuchung erzeugt Instabilität.
- Bursts sind physikalisch schädlich.

---

## 4. Puffer sind Zeitverschiebung

Puffer speichern Zeit, nicht Daten.

Folgerungen:
- Große Puffer erhöhen Latenz.
- Unkontrollierte Puffer sind verboten.
- Bufferbloat ist ein Designfehler.

---

## 5. Drops sind physikalische Ereignisse

Paketverluste entstehen durch Überlast oder Störung.

Folgerungen:
- Drops sind Signale, keine Ausnahme.
- Vermeidung hat Vorrang vor Reparatur.
- Wiederholung ersetzt keine Kontrolle.

---

## 6. Backpressure ist Pflicht

Ein Empfänger bestimmt die Geschwindigkeit.

Folgerungen:
- Sender warten.
- Empfänger geben explizit frei.
- Blindes Senden ist verboten.

---

## 7. Pacing ist zwingend

Daten müssen gleichmäßig eingespeist werden.

Folgerungen:
- Zeitbasierte Steuerung ist Pflicht.
- Burst-getriebene Übertragung ist verboten.
- Gleichmäßigkeit schlägt Spitzenleistung.

---

## 8. Reihenfolge ist teuer

Geordnete Übertragung kostet Zeit und Puffer.

Folgerungen:
- Ordnung ist explizit zu fordern.
- Unordnung ist der Default.
- Erzwungene Ordnung ohne Notwendigkeit ist verboten.

---

## 9. Zuverlässigkeit kostet Bandbreite

Integrität und Wiederherstellung sind nicht kostenlos.

Folgerungen:
- Fehlerkorrektur ist adaptiv.
- Statische Sicherheitsmargen sind verboten.
- Physikalische Qualität bestimmt das Maß.

---

## 10. MTU ist eine physikalische Grenze

MTU bestimmt Effizienz und Stabilität.

Folgerungen:
- MTU ist zu messen, nicht anzunehmen.
- Fragmentierung ist verboten.
- Größer ist nur besser bei Stabilität.

---

## 11. Netzwerk-Hardware ist Teil des Systems

NICs, Switches und Treiber sind aktive Akteure.

Folgerungen:
- Offloads sind physikalische Zustände.
- Interrupts sind Störungen.
- DMA ist kein „kostenloser“ Pfad.

---

## 12. Virtuelle Netzwerke sind reale Last

Virtuelle Links verbrauchen reale Ressourcen.

Folgerungen:
- Virtualisierung ändert Physik nicht.
- Overcommit ist sichtbar.
- Abstraktion reduziert nicht die Kosten.

---

## 13. Messung erfolgt am Draht

Netzwerk-Messung muss drahtnah sein.

Folgerungen:
- End-to-End allein ist unzureichend.
- Sender- und Empfängersicht sind getrennt.
- Worst-Case bestimmt das Verhalten.

---

## 14. Architekturbindung

CommanderLink betrachtet Netzwerke primär als:

- Punkt-zu-Punkt-Flüsse
- Zeitkontinuierliche Medien
- Physikalisch begrenzte Systeme

Protokolle sind untergeordnet.

---

## 15. Schlussformel

Das Netzwerk verzeiht keine Annahmen.

Wer schneller sendet als der Empfänger aufnehmen kann,
zerstört Stabilität.

Dieses Gesetz ist Grundlage aller
Wire-, Transport- und Flow-Entscheidungen.


<<< END FILE: ./docs/laws/LAW_03_NETWORK.md

>>> START FILE: ./docs/laws/LAW_04_TIME.md
# LAW_04_TIME.md
## CommanderLink – Zeit-Gesetz (Determinismus & Ablauf)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt den Umgang mit Zeit,
Abläufen und zeitlichen Abhängigkeiten
für CommanderLink auf **x86_64**.

Zeit ist eine physikalische Größe,
kein Abstraktionsmittel.

---

## 1. Zeit ist irreversibel

Zeit verläuft nur vorwärts.

Folgerungen:
- Rückwärtskorrekturen sind verboten.
- Nachträgliche „Reparaturen“ sind physikalisch unmöglich.
- Entscheidungen müssen zum Entscheidungszeitpunkt korrekt sein.

---

## 2. Zeit ist lokal

Zeit entsteht am Ausführungsort.

Folgerungen:
- Lokale Zeitquellen haben Vorrang.
- Globale Zeit ist ein abgeleiteter Zustand.
- Synchronisation erzeugt Verzögerung.

---

## 3. Zeitmessung ist störend

Jede Zeitmessung greift in das System ein.

Folgerungen:
- Zeitmessung ist zu budgetieren.
- Übermäßige Messung verfälscht Ergebnisse.
- Messpfade dürfen Hot-Pfade nicht destabilisieren.

---

## 4. Worst-Case dominiert

Zeitliche Planung richtet sich nach dem Worst-Case.

Folgerungen:
- Durchschnittswerte sind informativ, nicht bindend.
- P99/P999 sind Mindestanforderungen.
- Ungebundene Latenzen sind verboten.

---

## 5. Jitter ist ein Fehler

Zeitliche Schwankung ist Instabilität.

Folgerungen:
- Jitter ist zu minimieren, nicht zu akzeptieren.
- Glättung ist Pflicht.
- Burst-Verhalten erzeugt Jitter.

---

## 6. Deadlines sind physikalische Grenzen

Eine Deadline ist eine reale Grenze.

Folgerungen:
- Verpasste Deadlines sind Fehlerzustände.
- Spätes Ergebnis ist kein Ergebnis.
- Deadline-Überschreitungen sind sichtbar zu machen.

---

## 7. Blockierung ist Zeitvernichtung

Blockierende Operationen vernichten Zeit.

Folgerungen:
- Ungebundene Blockierung ist verboten.
- Warten ohne obere Grenze ist verboten.
- Fortschritt muss messbar sein.

---

## 8. Planung ersetzt Hoffnung

Zeitplanung ist verpflichtend.

Folgerungen:
- Jeder Ablauf benötigt ein Zeitbudget.
- Überziehung ist ein Vertragsbruch.
- Elastizität ist explizit zu definieren.

---

## 9. Asynchronität ist nicht kostenlos

Asynchronität verlagert Zeit, sie eliminiert sie nicht.

Folgerungen:
- Asynchrone Pfade benötigen Kontrolle.
- Entkopplung ohne Rückmeldung ist verboten.
- Jeder asynchrone Pfad braucht Backpressure.

---

## 10. Zeitdomänen sind getrennt

Unterschiedliche Zeitdomänen dürfen nicht vermischt werden.

Folgerungen:
- CPU-Zeit ≠ Netzwerkzeit ≠ IO-Zeit.
- Übersetzung kostet Zeit.
- Domänenwechsel sind explizit zu markieren.

---

## 11. Zeitbasierte Steuerung schlägt Ereignisreaktion

Zeitsteuerung ist stabiler als reine Ereignissteuerung.

Folgerungen:
- Periodische Kontrolle ist Pflicht.
- Ereignisstürme sind instabil.
- Reaktion ohne Zeitkontext ist verboten.

---

## 12. Messfehler sind Zeitfehler

Unpräzise Zeitmessung erzeugt falsche Entscheidungen.

Folgerungen:
- Zeitauflösung muss bekannt sein.
- Drift ist zu erkennen.
- Ungenaue Zeit ist ein Risiko.

---

## 13. Architekturbindung

CommanderLink bindet sich an:

- x86_64 Zeitquellen
- deterministische Zeitpfade
- bekannte Takt- und Drift-Eigenschaften

Andere Architekturen benötigen eigene Zeitgesetze.

---

## 14. Schlussformel

Zeit ist der härteste Zwang im System.

Ein System, das Zeit nicht kontrolliert,
wird von ihr kontrolliert.

Dieses Gesetz ist Grundlage aller
Scheduler-, Pacing- und Ablaufverträge.

<<< END FILE: ./docs/laws/LAW_04_TIME.md

>>> START FILE: ./docs/laws/LAW_05_POWER.md
# LAW_05_POWER.md
## CommanderLink – Energie- & Leistungs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Energieaufnahme, Leistungszustände
und deren Auswirkungen auf das Systemverhalten
für CommanderLink.

Energie ist eine physikalische Zwangsgröße.

---

## 1. Leistung ist Energie pro Zeit

Leistung entsteht ausschließlich durch Energieverbrauch.

Folgerungen:
- Rechenleistung ist kein abstrakter Wert.
- Jede Operation kostet messbare Energie.
- Unbudgetierter Verbrauch ist verboten.

---

## 2. Energiequellen sind begrenzt

Energiezufuhr ist endlich.

Folgerungen:
- Power-Limits sind harte Grenzen.
- Überschreitung erzwingt Korrektur.
- Ignorieren von Limits ist ein Systemfehler.

---

## 3. Leistungszustände sind diskret

Power-States sind endlich und hardwaredefiniert.

Folgerungen:
- Übergänge kosten Zeit.
- Häufige Wechsel erzeugen Instabilität.
- Unkontrollierte Zustandswechsel sind verboten.

---

## 4. Thermik folgt Energie

Temperatur ist eine Folge von Energie.

Folgerungen:
- Thermische Effekte sind verzögert.
- Prävention ist Pflicht.
- Reaktion allein ist zu spät.

---

## 5. Turbo ist opportunistisch

Leistungsreserven sind nicht garantiert.

Folgerungen:
- Turbo darf nicht eingeplant werden.
- Planung erfolgt auf Basis garantierter Zustände.
- Turbo ist ein Bonus, kein Vertrag.

---

## 6. Drosselung ist korrektes Verhalten

Drosselung schützt das System.

Folgerungen:
- Drosselung ist kein Fehler.
- Verdrängung von Arbeit ist erlaubt.
- Instabilität ist schlimmer als Langsamkeit.

---

## 7. Energieeffizienz ist Pflicht

Maximaler Verbrauch ohne Nutzen ist verboten.

Folgerungen:
- Energie pro Arbeitseinheit ist maßgeblich.
- Ineffiziente Pfade sind zu eliminieren.
- Idle-Verbrauch ist zu minimieren.

---

## 8. Leistungsspitzen sind schädlich

Spitzenbelastung destabilisiert.

Folgerungen:
- Glättung ist Pflicht.
- Burst-Leistung ohne Budget ist verboten.
- Gleichmäßigkeit erhöht Stabilität.

---

## 9. Energie ist messpflichtig

Ohne Messung keine Kontrolle.

Folgerungen:
- Energie- und Power-Messungen sind verpflichtend.
- Schätzungen ersetzen keine Messung.
- Messqualität ist offenzulegen.

---

## 10. Energie bestimmt Scheduling

Arbeit wird nach Energiezustand geplant.

Folgerungen:
- Hohe Last erfordert niedrige Energieintensität.
- Scheduling ohne Power-Kontext ist ungültig.
- Energetische Rückkopplung ist Pflicht.

---

## 11. Energie dominiert Performance

Mehr Energie ist nicht automatisch mehr Leistung.

Folgerungen:
- Effizienz schlägt rohe Leistung.
- Überhitzung zerstört Durchsatz.
- Stabilität hat Vorrang.

---

## 12. Architekturbindung

CommanderLink bindet sich an:

- reale Power-Limits der Hardware
- bekannte Power-States
- messbare Energiepfade

Abweichungen erfordern neue Gesetze.

---

## 13. Schlussformel

Energie ist der stille Regulator aller Systeme.

Wer Energie ignoriert,
verliert Kontrolle über Zeit und Stabilität.

Dieses Gesetz ist Grundlage aller
Budget-, Gate- und Fallback-Mechanismen.


<<< END FILE: ./docs/laws/LAW_05_POWER.md

>>> START FILE: ./docs/laws/LAW_06_SCHEDULING.md
# LAW_06_SCHEDULING.md
## CommanderLink – Ausführungs- & Scheduling-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Planung, Reihenfolge und Ausführung von Arbeit
in CommanderLink.

Scheduling ist eine physikalische Disziplin,
keine abstrakte Verwaltungsaufgabe.

---

## 1. Arbeit ist endlich

Arbeit existiert nur, wenn sie ausführbar ist.

Folgerungen:
- Unausführbare Arbeit ist Last.
- Geplante Arbeit ohne Ressourcen ist verboten.
- Warteschlangen ersetzen keine Kapazität.

---

## 2. Scheduling ist Ressourcenbindung

Scheduling bindet reale Ressourcen.

Folgerungen:
- Jede geplante Einheit reserviert Zeit, Energie und Speicher.
- Planung ohne Ressourcenbindung ist ungültig.
- Überplanung ist ein Designfehler.

---

## 3. Priorität ist physikalisch

Priorität entsteht aus Notwendigkeit, nicht aus Wunsch.

Folgerungen:
- Zeitkritische Arbeit dominiert.
- Interaktive Pfade haben Vorrang.
- Hintergrundarbeit ist verdrängbar.

---

## 4. Fairness ist sekundär

Stabilität schlägt Fairness.

Folgerungen:
- Gleichbehandlung ist kein Ziel.
- Kritische Pfade dürfen bevorzugt werden.
- Starvation ist erlaubt, Instabilität nicht.

---

## 5. Preemption ist Verlust

Verdrängung zerstört Fortschritt.

Folgerungen:
- Preemption ist zu minimieren.
- Kurze, abgeschlossene Einheiten sind vorzuziehen.
- Lange, nicht unterbrechbare Arbeit ist verboten.

---

## 6. Arbeitseinheiten sind endlich

Jede Arbeitseinheit benötigt klare Grenzen.

Folgerungen:
- Unbegrenzte Tasks sind verboten.
- Fortschritt muss messbar sein.
- Abbruchpfade sind Pflicht.

---

## 7. Rückstau ist korrektes Verhalten

Backlog signalisiert physikalische Grenzen.

Folgerungen:
- Rückstau ist sichtbar zu machen.
- Ablehnung ist besser als Überlast.
- Drop vor Chaos.

---

## 8. Zeitbudget ist verbindlich

Jede Arbeit erhält ein Zeitbudget.

Folgerungen:
- Budgetüberschreitung ist ein Fehler.
- Arbeit darf gestoppt werden.
- Elastizität ist explizit zu definieren.

---

## 9. Koordination kostet Zeit

Abstimmung zwischen Einheiten erzeugt Overhead.

Folgerungen:
- Zentrale Koordination ist teuer.
- Lokale Entscheidungen sind stabiler.
- Globale Locks sind verboten.

---

## 10. Reihenfolge ist ein Vertrag

Ausführungsreihenfolge beeinflusst Ergebnis.

Folgerungen:
- Ordnung ist explizit festzulegen.
- Implizite Reihenfolgen sind verboten.
- Nebenläufigkeit ohne Ordnung ist instabil.

---

## 11. Stillstand ist ein Zustand

Idle ist kein Fehler.

Folgerungen:
- Leerlauf ist energetisch korrekt.
- Künstliche Auslastung ist verboten.
- Ruhe stabilisiert Systeme.

---

## 12. Messung steuert Scheduling

Ohne Messung keine Planung.

Folgerungen:
- Laufzeiten sind zu erfassen.
- Abweichungen sind zu reagieren.
- Planung ohne Rückkopplung ist blind.

---

## 13. Architekturbindung

CommanderLink Scheduling bindet sich an:

- reale CPU-Kerne
- bekannte Preemption-Mechanismen
- messbare Laufzeiten

Andere Modelle erfordern eigene Gesetze.

---

## 14. Schlussformel

Scheduling entscheidet über Stabilität.

Wer mehr plant als ausführen kann,
verliert Kontrolle über das System.

Dieses Gesetz ist Grundlage aller
Executor-, Loop- und Ablaufmodelle.


<<< END FILE: ./docs/laws/LAW_06_SCHEDULING.md

>>> START FILE: ./docs/laws/LAW_07_IO.md
# LAW_07_IO.md
## CommanderLink – Ein-/Ausgabe-Gesetz (I/O & Gerätepfade)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt alle Formen von Ein- und Ausgabe
zwischen CPU, Speicher und externen Geräten
für CommanderLink.

I/O ist physikalische Interaktion, keine Abstraktion.

---

## 1. I/O ist langsamer als Rechenlogik

Jeder I/O-Vorgang ist teurer als lokale Berechnung.

Folgerungen:
- I/O ist zu minimieren.
- Berechnung vor Transfer.
- Vermeidung schlägt Beschleunigung.

---

## 2. Geräte sind eigenständige Akteure

Geräte besitzen eigene Zustände und Latenzen.

Folgerungen:
- Geräteverhalten ist nicht deterministisch steuerbar.
- Wartezeiten sind real.
- Gerätefehler sind physikalische Zustände.

---

## 3. Pfade bestimmen Kosten

Der I/O-Pfad definiert Latenz und Stabilität.

Folgerungen:
- Direkte Pfade sind vorzuziehen.
- Umwege erhöhen Jitter.
- Verborgene Pfade sind verboten.

---

## 4. DMA ist kein kostenloser Transport

DMA verlagert Arbeit, eliminiert sie nicht.

Folgerungen:
- Cache-Kohärenz kostet Zeit.
- Synchronisation ist verpflichtend.
- Blindes DMA ist verboten.

---

## 5. Blockierende I/O ist Zeitvernichtung

Blockierung hält Ressourcen fest.

Folgerungen:
- Blockierende I/O im Hot-Pfad ist verboten.
- Zeitlich gebundene Operationen sind Pflicht.
- Fortschritt muss beobachtbar sein.

---

## 6. Asynchrone I/O erfordert Kontrolle

Asynchronität erzeugt Nebenläufigkeit.

Folgerungen:
- Rückmeldung ist Pflicht.
- Backpressure ist zwingend.
- Unkontrollierte Parallel-I/O ist verboten.

---

## 7. Puffer sind Zustandsverschiebung

I/O-Puffer verschieben Zeit und Verantwortung.

Folgerungen:
- Puffergrößen sind zu begrenzen.
- Implizite Puffer sind verboten.
- Große Puffer erhöhen Latenz.

---

## 8. Reihenfolge ist geräteabhängig

Geräte können Reihenfolgen ändern.

Folgerungen:
- Ordnung darf nicht angenommen werden.
- Explizite Ordnung kostet Zeit.
- Ordnung nur bei Notwendigkeit.

---

## 9. Fehler sind normal

I/O-Fehler entstehen aus Physik.

Folgerungen:
- Fehlerpfade sind gleichwertig.
- Wiederholung ist begrenzt.
- Endlose Retries sind verboten.

---

## 10. Bandbreite ist geteilt

Geräte teilen sich Busse und Controller.

Folgerungen:
- Konkurrenz ist einzukalkulieren.
- Exklusive Annahmen sind verboten.
- Überlast ist sichtbar zu machen.

---

## 11. Initialisierung ist I/O

Geräteinitialisierung kostet Zeit und Energie.

Folgerungen:
- Initialisierung ist zu budgetieren.
- Späte Initialisierung ist riskant.
- On-Demand ohne Grenze ist verboten.

---

## 12. Messung erfolgt am Gerät

I/O-Messung muss gerätenah sein.

Folgerungen:
- Host-Sicht allein ist unzureichend.
- Wartezeiten sind zu messen.
- Worst-Case dominiert.

---

## 13. Architekturbindung

CommanderLink bindet sich an:

- reale Busse und Controller
- bekannte DMA- und Interrupt-Modelle
- messbare Gerätepfade

Abweichungen erfordern neue Gesetze.

---

## 14. Schlussformel

I/O ist die langsamste Wahrheit im System.

Wer I/O unterschätzt,
zerstört Zeit, Energie und Stabilität.

Dieses Gesetz ist Grundlage aller
Geräte-, DMA- und Transferverträge.


<<< END FILE: ./docs/laws/LAW_07_IO.md

>>> START FILE: ./docs/laws/LAW_08_SECURITY.md
# LAW_08_SECURITY.md
## CommanderLink – Sicherheits- & Vertrauens-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Sicherheit, Vertrauen und Integrität
aller Komponenten, Pfade und Interaktionen
in CommanderLink.

Sicherheit ist ein physikalischer und systemischer Zustand,
kein Zusatzmerkmal.

---

## 1. Vertrauen ist nicht implizit

Kein Bestandteil ist per Existenz vertrauenswürdig.

Folgerungen:
- Initialer Zustand ist **nicht vertrauenswürdig**.
- Vertrauen muss explizit entstehen.
- Implizites Vertrauen ist verboten.

---

## 2. Integrität ist physikalisch

Integrität bedeutet Unverändertheit unter realen Bedingungen.

Folgerungen:
- Daten können beschädigt werden.
- Übertragung ist fehleranfällig.
- Speicher ist nicht perfekt.

---

## 3. Sicherheit kostet Ressourcen

Sicherheitsmechanismen verbrauchen Zeit, Energie und Speicher.

Folgerungen:
- Sicherheit ist zu budgetieren.
- Unbudgetierte Sicherheit ist verboten.
- Unsichtbare Kosten sind ein Fehler.

---

## 4. Sichtbarkeit ist Voraussetzung für Sicherheit

Was nicht sichtbar ist, kann nicht geschützt werden.

Folgerungen:
- Sicherheitszustände müssen messbar sein.
- Verdeckte Entscheidungen sind verboten.
- Blindes Vertrauen ist unzulässig.

---

## 5. Authentizität ist eindeutig

Identitäten müssen eindeutig bestimmbar sein.

Folgerungen:
- Mehrdeutige Identitäten sind verboten.
- Identitätswechsel ist ein Zustand.
- Identitätsverlust ist ein Fehler.

---

## 6. Autorisierung ist zustandsabhängig

Berechtigung hängt vom aktuellen Zustand ab.

Folgerungen:
- Statische Berechtigungen sind unzureichend.
- Kontext bestimmt Zugriff.
- Überprivilegierung ist verboten.

---

## 7. Geheimnisse sind Last

Geheime Daten erzeugen dauerhafte Verantwortung.

Folgerungen:
- Geheimnisse sind zu minimieren.
- Lebensdauer ist zu begrenzen.
- Persistenz ohne Notwendigkeit ist verboten.

---

## 8. Kryptographie ist Physik

Kryptographie unterliegt Zeit, Energie und Implementierung.

Folgerungen:
- Kryptographie ist kein Allheilmittel.
- Falsche Nutzung erzeugt Scheinsicherheit.
- Implementierungsfehler sind Sicherheitsfehler.

---

## 9. Fehler sind Angriffsflächen

Fehlerzustände erhöhen Angriffsrisiken.

Folgerungen:
- Fehlerpfade sind abzusichern.
- Undefined Behavior ist verboten.
- Recovery darf keine Lücken öffnen.

---

## 10. Isolation ist relativ

Isolation ist niemals absolut.

Folgerungen:
- Grenzen sind zu definieren.
- Seiteneffekte sind einzukalkulieren.
- Vertrauen endet an der Grenze.

---

## 11. Reduktion schlägt Komplexität

Komplexität ist ein Sicherheitsrisiko.

Folgerungen:
- Minimalismus erhöht Sicherheit.
- Überflüssige Mechanismen sind zu entfernen.
- Vielfalt ohne Kontrolle ist verboten.

---

## 12. Sicherheit ist dynamisch

Sicherheitszustände ändern sich über Zeit.

Folgerungen:
- Vertrauen kann entzogen werden.
- Re-Evaluierung ist Pflicht.
- Dauerhafte Annahmen sind verboten.

---

## 13. Architekturbindung

CommanderLink Sicherheit bindet sich an:

- reale Hardware-Eigenschaften
- messbare Zustände
- explizite Vertrauensübergänge

Abweichungen erfordern neue Gesetze.

---

## 14. Schlussformel

Sicherheit ist kein Zustand, den man erreicht,
sondern ein Zustand, den man aufrechterhält.

Wer Sicherheit voraussetzt,
hat sie bereits verloren.

Dieses Gesetz ist Grundlage aller
Trust-, Join- und Integritätsverträge.


<<< END FILE: ./docs/laws/LAW_08_SECURITY.md

>>> START FILE: ./docs/laws/LAW_09_MEASUREMENT.md
# LAW_09_MEASUREMENT.md
## CommanderLink – Mess- & Wahrheits-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Messung, Beobachtung und Ableitung von Wahrheit
in CommanderLink.

Messung ist Teil des Systems,
nicht ein externes Werkzeug.

---

## 1. Ohne Messung keine Wahrheit

Nicht gemessene Zustände sind unbekannt.

Folgerungen:
- Annahmen ohne Messung sind verboten.
- Schätzung ersetzt keine Messung.
- Unsichtbarkeit ist ein Fehlerzustand.

---

## 2. Messung ist invasiv

Jede Messung verändert das System.

Folgerungen:
- Messkosten sind zu budgetieren.
- Messung darf Stabilität nicht gefährden.
- Unkontrollierte Messung ist verboten.

---

## 3. Messung ist zeitgebunden

Messwerte sind nur zum Messzeitpunkt gültig.

Folgerungen:
- Veraltete Messwerte sind zu kennzeichnen.
- Zeitstempel sind Pflicht.
- Kontextlose Messungen sind wertlos.

---

## 4. Nähe bestimmt Qualität

Je näher die Messung an der Physik,
desto höher ihre Qualität.

Folgerungen:
- Hardware-nahe Messung hat Vorrang.
- Abgeleitete Werte sind sekundär.
- Fernbeobachtung ist degradiert.

---

## 5. Qualität ist explizit

Jeder Messwert besitzt eine Qualitätsstufe.

Folgerungen:
- Direkt gemessen schlägt geschätzt.
- Fehlende Qualität ist ein Fehler.
- Vergleich ohne Qualitätsangabe ist verboten.

---

## 6. Worst-Case ist maßgeblich

Extremwerte bestimmen das Systemverhalten.

Folgerungen:
- Mittelwerte sind informativ, nicht bindend.
- P99/P999 sind Mindestanforderung.
- Ausreißer sind relevante Signale.

---

## 7. Kontinuität schlägt Ereignis

Stetige Messung ist stabiler als punktuelle.

Folgerungen:
- Periodische Erfassung ist Pflicht.
- Ereignisstürme verzerren Realität.
- Lücken sind sichtbar zu machen.

---

## 8. Interpretation ist getrennt von Messung

Messung liefert Daten, nicht Bedeutung.

Folgerungen:
- Rohdaten sind unverfälscht zu erhalten.
- Interpretation ist nachgelagert.
- Vermischung ist verboten.

---

## 9. Aggregation verschleiert Wahrheit

Aggregation verliert Information.

Folgerungen:
- Aggregation ist explizit zu kennzeichnen.
- Rohwerte bleiben zugänglich.
- Überaggregation ist ein Fehler.

---

## 10. Messpfade sind passiv

Messung darf keine Steuerung ausüben.

Folgerungen:
- Beobachter sind lesend.
- Aktive Eingriffe sind getrennt.
- Rückkopplung erfolgt nur über definierte Pfade.

---

## 11. Vollständigkeit ist relativ

Nicht alles ist messbar.

Folgerungen:
- Unmessbares ist zu deklarieren.
- Falsche Genauigkeit ist verboten.
- Unsicherheit ist offen zu legen.

---

## 12. Wahrheit ist konsistent

Widersprüchliche Messungen sind Fehler.

Folgerungen:
- Quellenkonflikte sind sichtbar zu machen.
- Prioritäten sind festzulegen.
- Inkonsistenz erfordert Klärung.

---

## 13. Architekturbindung

CommanderLink Messung bindet sich an:

- hardware-nahe Sensorik
- zeitlich determinierte Erfassung
- explizite Qualitätskennzeichnung

Andere Messmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Was nicht korrekt gemessen wird,
kann nicht kontrolliert werden.

Messung ist die einzige Quelle von Wahrheit.

Dieses Gesetz ist Grundlage aller
Monitoring-, Telemetrie- und Audit-Verträge.


<<< END FILE: ./docs/laws/LAW_09_MEASUREMENT.md

>>> START FILE: ./docs/laws/LAW_10_FAILURE.md
# LAW_10_FAILURE.md
## CommanderLink – Fehler-, Ausfall- & Degradations-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt den Umgang mit Fehlern, Ausfällen,
Degradation und Wiederherstellung
in CommanderLink.

Fehler sind unvermeidliche physikalische Zustände,
keine Sonderfälle.

---

## 1. Fehler sind normal

Fehler entstehen aus Physik, Last und Zeit.

Folgerungen:
- Fehlerfreiheit ist keine Annahme.
- Fehlerzustände sind einplanbar.
- Überraschungsfehler sind Designfehler.

---

## 2. Fehler sind Zustände, keine Ereignisse

Ein Fehler ist ein anhaltender Zustand.

Folgerungen:
- Fehler haben Dauer.
- Übergänge sind explizit.
- Kurzzeitige Maskierung ersetzt keine Behandlung.

---

## 3. Degradation ist korrektes Verhalten

Leistungsreduktion erhält Stabilität.

Folgerungen:
- Degradation ist erlaubt.
- Instabilität ist verboten.
- Volle Leistung ist kein Anspruch.

---

## 4. Fail-Stop schlägt Fail-Chaos

Stillstand ist besser als unkontrolliertes Verhalten.

Folgerungen:
- Kontrollierter Abbruch ist zulässig.
- Ungebremste Weiterverarbeitung ist verboten.
- Schutz geht vor Fortschritt.

---

## 5. Recovery kostet Zeit

Wiederherstellung ist kein Nullkostenpfad.

Folgerungen:
- Recovery ist zu budgetieren.
- Häufiges Recovery ist ein Fehlerindikator.
- Endloses Recovery ist verboten.

---

## 6. Zustand vor Neustart ist relevant

Neustart löscht keine Realität.

Folgerungen:
- Vorzustände sind zu berücksichtigen.
- Blindes Reset ist verboten.
- Persistente Fehler müssen erkannt werden.

---

## 7. Isolation begrenzt Schaden

Fehler dürfen sich nicht unkontrolliert ausbreiten.

Folgerungen:
- Fehlerdomänen sind zu definieren.
- Kaskadierung ist zu verhindern.
- Isolation ist Pflicht.

---

## 8. Zeit bestimmt Fehlerwirkung

Je länger ein Fehler andauert,
desto größer der Schaden.

Folgerungen:
- Früherkennung ist entscheidend.
- Verzögerte Reaktion verschärft Schäden.
- Ignorieren ist verboten.

---

## 9. Teilfunktion schlägt Totalausfall

Reduzierte Funktion ist besser als keine.

Folgerungen:
- Graceful Degradation ist Pflicht.
- Kernfunktionen haben Vorrang.
- Komfortfunktionen sind verzichtbar.

---

## 10. Fehler müssen sichtbar sein

Unsichtbare Fehler sind gefährlich.

Folgerungen:
- Fehlerzustände sind zu messen.
- Maskierung ohne Kennzeichnung ist verboten.
- Beobachtbarkeit ist Pflicht.

---

## 11. Automatik schlägt manuelle Intervention

Automatische Reaktion ist schneller als Mensch.

Folgerungen:
- Automatische Schutzmechanismen sind Pflicht.
- Manuelle Eingriffe sind sekundär.
- Mensch ist nicht im Hot-Pfad.

---

## 12. Fehlerhistorie ist relevant

Vergangene Fehler beeinflussen Zukunft.

Folgerungen:
- Fehlerverläufe sind zu speichern.
- Wiederholungen sind zu erkennen.
- Lernen ist verpflichtend.

---

## 13. Architekturbindung

CommanderLink Fehlerbehandlung bindet sich an:

- reale Ausfallmodi der Hardware
- messbare Zustandsübergänge
- zeitabhängige Wirkung

Andere Modelle erfordern neue Gesetze.

---

## 14. Schlussformel

Ein System ohne Fehlerstrategie
ist bereits gescheitert.

Stabilität entsteht nicht durch Vermeidung von Fehlern,
sondern durch kontrollierten Umgang mit ihnen.

Dieses Gesetz ist Grundlage aller
Fallback-, Gate- und Recovery-Verträge.


<<< END FILE: ./docs/laws/LAW_10_FAILURE.md

>>> START FILE: ./docs/laws/LAW_11_CONTROL.md
# LAW_11_CONTROL.md
## CommanderLink – Steuerungs- & Interlock-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Steuerung, Rückkopplung,
Interlocks und Eingriffsmechanismen
in CommanderLink.

Steuerung ist ein physikalischer Regelkreis,
kein abstraktes Kommandomodell.

---

## 1. Steuerung setzt Messung voraus

Ohne Messung keine Kontrolle.

Folgerungen:
- Unbeobachtete Steuerung ist verboten.
- Steuerentscheidungen ohne aktuelle Daten sind ungültig.
- Verzögerte Messung reduziert Wirksamkeit.

---

## 2. Regelkreise sind zeitabhängig

Jeder Regelkreis besitzt eine Reaktionszeit.

Folgerungen:
- Zu schnelle Regelung erzeugt Instabilität.
- Zu langsame Regelung ist wirkungslos.
- Regelperioden sind explizit festzulegen.

---

## 3. Rückkopplung ist zwingend

Steuerung ohne Rückmeldung ist Blindflug.

Folgerungen:
- Jede Aktion benötigt Feedback.
- Fehlendes Feedback erzwingt Degradation.
- Positive Rückkopplung ist zu begrenzen.

---

## 4. Interlocks haben Vorrang

Interlocks schützen vor physikalischem Schaden.

Folgerungen:
- Interlocks übersteuern Logik.
- Interlocks sind nicht abschaltbar.
- Umgehung ist verboten.

---

## 5. Hysterese ist Pflicht

Sofortige Umschaltung erzeugt Flattern.

Folgerungen:
- Zustandswechsel benötigen Hysterese.
- Grenzwerte sind nicht punktuell.
- Flatterzustände sind Fehler.

---

## 6. Steuerung ist minimal-invasiv

Eingriffe verändern das System.

Folgerungen:
- Kleinster wirksamer Eingriff ist vorzuziehen.
- Übersteuerung ist Ausnahme.
- Dauerhafte Eingriffe sind zu vermeiden.

---

## 7. Lokale Kontrolle schlägt globale

Lokale Regelung ist stabiler als zentrale.

Folgerungen:
- Dezentralität reduziert Latenz.
- Zentrale Steuerung ist teuer.
- Globale Entscheidungen sind begrenzt einzusetzen.

---

## 8. Priorität schützt Kernfunktionen

Nicht alle Funktionen sind gleichwertig.

Folgerungen:
- Schutz kritischer Pfade hat Vorrang.
- Komfortfunktionen sind abschaltbar.
- Steuerung folgt Funktionshierarchie.

---

## 9. Automatik ist der Default

Maschinelle Reaktion ist schneller als Mensch.

Folgerungen:
- Automatische Steuerung ist Pflicht.
- Manuelle Eingriffe sind nachrangig.
- Menschliche Reaktion ist außerhalb des Regelkreises.

---

## 10. Eskalation ist gestuft

Nicht jeder Zustand erfordert Maximalreaktion.

Folgerungen:
- Mehrstufige Reaktion ist Pflicht.
- Sofortiger Hard-Stop nur bei Gefahr.
- Eskalationspfade sind definiert.

---

## 11. Kontrolle ist reversibel

Steuermaßnahmen dürfen rückgängig gemacht werden.

Folgerungen:
- Dauerhafte Sperren sind zu vermeiden.
- Rückkehr in stabilen Zustand ist Ziel.
- Irreversible Eingriffe sind Ausnahmefälle.

---

## 12. Steuerung ist sichtbar

Kontrollzustände müssen beobachtbar sein.

Folgerungen:
- Aktive Interlocks sind sichtbar zu machen.
- Eingriffe sind zu kennzeichnen.
- Unsichtbare Kontrolle ist verboten.

---

## 13. Architekturbindung

CommanderLink Steuerung bindet sich an:

- messbare Zustände
- zeitgebundene Regelkreise
- physikalisch begründete Interlocks

Andere Modelle erfordern neue Gesetze.

---

## 14. Schlussformel

Steuerung entscheidet über Überleben.

Ein System ohne Interlocks
verwechselt Freiheit mit Instabilität.

Dieses Gesetz ist Grundlage aller
Gate-, Budget- und Schutzmechanismen.


<<< END FILE: ./docs/laws/LAW_11_CONTROL.md

>>> START FILE: ./docs/laws/LAW_12_IDENTITY.md
# LAW_12_IDENTITY.md
## CommanderLink – Identitäts- & Existenz-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Identität, Existenz und Zuordnung
aller Einheiten in CommanderLink.

Identität ist eine physikalisch und systemisch
verankerte Eigenschaft, kein symbolischer Name.

---

## 1. Existenz geht Identität voraus

Eine Einheit muss existieren, bevor sie identifiziert werden kann.

Folgerungen:
- Nicht existierende Einheiten sind ungültig.
- Phantom-Identitäten sind verboten.
- Existenz ist messbar.

---

## 2. Identität ist eindeutig

Jede Einheit besitzt genau eine Identität.

Folgerungen:
- Mehrdeutigkeit ist verboten.
- Kollisionen sind Fehlerzustände.
- Identitätswechsel ist ein Ereignis.

---

## 3. Identität ist stabil

Identität ändert sich nicht spontan.

Folgerungen:
- Identitätsänderung ist explizit.
- Implizite Neuzuweisung ist verboten.
- Stabilität schlägt Komfort.

---

## 4. Identität ist lokal verankert

Identität entsteht aus realen Eigenschaften.

Folgerungen:
- Physikalische Merkmale haben Vorrang.
- Abgeleitete Identitäten sind sekundär.
- Rein symbolische Identitäten sind degradiert.

---

## 5. Identität ist überprüfbar

Identität muss validierbar sein.

Folgerungen:
- Nicht prüfbare Identitäten sind unzulässig.
- Validierung ist wiederholbar.
- Einmalige Prüfung ist unzureichend.

---

## 6. Identität ist zustandsabhängig

Identität kann aktiv, passiv oder entzogen sein.

Folgerungen:
- Zustand ist Teil der Identität.
- Ungültige Zustände sind sichtbar zu machen.
- Nutzung ohne gültigen Zustand ist verboten.

---

## 7. Zugehörigkeit ist nicht transitiv

Vertrauen überträgt sich nicht automatisch.

Folgerungen:
- Jede Beziehung ist separat zu bewerten.
- Implizite Gruppenzugehörigkeit ist verboten.
- Kettenvertrauen ist degradiert.

---

## 8. Identität hat Lebenszeit

Identitäten entstehen und enden.

Folgerungen:
- Lebensdauer ist zu definieren.
- Verwaiste Identitäten sind Fehler.
- Wiederverwendung ohne Reset ist verboten.

---

## 9. Mehrfachidentitäten sind explizit

Eine Einheit kann mehrere Rollen haben,
aber keine impliziten Identitäten.

Folgerungen:
- Rollen sind explizit zu deklarieren.
- Überlagerung ohne Trennung ist verboten.
- Konflikte sind sichtbar zu machen.

---

## 10. Identität bestimmt Zugriff

Zugriff ist an Identität gebunden.

Folgerungen:
- Zugriff ohne Identität ist verboten.
- Identitätsverlust entzieht Zugriff.
- Minimaler Zugriff ist Pflicht.

---

## 11. Identität ist beobachtbar

Identitätszustände müssen sichtbar sein.

Folgerungen:
- Aktive Identitäten sind erkennbar.
- Entzogene Identitäten sind markiert.
- Unsichtbare Existenz ist verboten.

---

## 12. Identität ist nicht anonym

Anonymität existiert nicht auf Systemebene.

Folgerungen:
- Jede Aktion ist zuordenbar.
- Unklare Urheberschaft ist ein Fehler.
- Verschleierung ist unzulässig.

---

## 13. Architekturbindung

CommanderLink Identität bindet sich an:

- reale Hardware- oder Systemmerkmale
- deterministische Ableitung
- überprüfbare Zustände

Andere Identitätsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Ohne Identität keine Kontrolle.

Ein System, das nicht weiß, wer handelt,
kann nicht sicher, stabil oder deterministisch sein.

Dieses Gesetz ist Grundlage aller
Join-, Trust- und Zugriffskontrollverträge.


<<< END FILE: ./docs/laws/LAW_12_IDENTITY.md

>>> START FILE: ./docs/laws/LAW_13_STATE.md
# LAW_13_STATE.md
## CommanderLink – Zustands- & Kontinuitäts-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Zustände, Zustandsübergänge
und Kontinuität aller Komponenten in CommanderLink.

Zustand ist eine physikalisch reale Tatsache,
keine logische Abstraktion.

---

## 1. Zustand ist vollständig

Ein Zustand beschreibt die gesamte relevante Realität
einer Einheit zu einem Zeitpunkt.

Folgerungen:
- Teilzustände sind unzulässig.
- Implizite Annahmen sind verboten.
- Unvollständige Zustände sind Fehler.

---

## 2. Zustand ist eindeutig

Zu jedem Zeitpunkt existiert genau ein gültiger Zustand.

Folgerungen:
- Überlagerte Zustände sind verboten.
- Ambivalenz ist ein Fehlerzustand.
- Gleichzeitige Mehrzustände sind unzulässig.

---

## 3. Zustandsübergänge sind diskret

Ein Übergang trennt zwei Zustände eindeutig.

Folgerungen:
- Übergänge sind explizit.
- Implizite Übergänge sind verboten.
- Übergangsdauer ist ein messbarer Zeitraum.

---

## 4. Übergänge kosten Zeit

Jeder Zustandswechsel verbraucht Zeit und Ressourcen.

Folgerungen:
- Übergänge sind zu budgetieren.
- Häufige Wechsel erzeugen Instabilität.
- Flattern ist ein Fehler.

---

## 5. Vorheriger Zustand ist relevant

Der vorherige Zustand beeinflusst den nächsten.

Folgerungen:
- Zustandslosigkeit ist verboten.
- Reset ohne Kontext ist unzulässig.
- Historie beeinflusst Verhalten.

---

## 6. Initialzustand ist definiert

Jede Einheit besitzt einen klaren Anfangszustand.

Folgerungen:
- Implizite Initialisierung ist verboten.
- Unbekannter Startzustand ist ein Fehler.
- Initialzustand ist überprüfbar.

---

## 7. Endzustand ist definiert

Auch Beendigung ist ein Zustand.

Folgerungen:
- Unsauberes Ende ist unzulässig.
- Ressourcenfreigabe ist Teil des Zustands.
- Zombie-Zustände sind verboten.

---

## 8. Zustand ist beobachtbar

Aktuelle Zustände müssen sichtbar sein.

Folgerungen:
- Verborgene Zustände sind verboten.
- Beobachtbarkeit ist Pflicht.
- Verzögerte Sichtbarkeit ist zu kennzeichnen.

---

## 9. Zustand ist konsistent

Zustand darf sich nicht selbst widersprechen.

Folgerungen:
- Inkonsistenz ist ein Fehlerzustand.
- Widersprüche erfordern sofortige Klärung.
- Teilreparaturen sind unzulässig.

---

## 10. Persistenz ist explizit

Nicht jeder Zustand ist persistent.

Folgerungen:
- Persistenz ist zu deklarieren.
- Implizite Persistenz ist verboten.
- Flüchtige Zustände sind kenntlich zu machen.

---

## 11. Zustandskopien sind Momentaufnahmen

Kopierte Zustände altern sofort.

Folgerungen:
- Kopien sind zeitlich gebunden.
- Nutzung ohne Zeitkontext ist verboten.
- Snapshots ersetzen keine Live-Sicht.

---

## 12. Zustand steuert Verhalten

Logik folgt Zustand, nicht umgekehrt.

Folgerungen:
- Verhalten ohne Zustandsbasis ist verboten.
- Zustand bestimmt erlaubte Aktionen.
- Missachtung führt zu Instabilität.

---

## 13. Architekturbindung

CommanderLink Zustandsmodell bindet sich an:

- messbare Systemrealität
- zeitlich diskrete Übergänge
- deterministische Zustandsdefinitionen

Andere Zustandsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Zustand ist die Wahrheit eines Systems.

Ein System ohne klares Zustandsmodell
verliert Kontinuität, Kontrolle und Determinismus.

Dieses Gesetz ist Grundlage aller
Lifecycle-, Recovery- und Kontrollmechanismen.


<<< END FILE: ./docs/laws/LAW_13_STATE.md

>>> START FILE: ./docs/laws/LAW_14_INTERFACE.md
# LAW_14_INTERFACE.md
## CommanderLink – Schnittstellen- & Grenz-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt alle Schnittstellen, Übergänge
und Grenzflächen zwischen Komponenten,
Subsystemen und externen Umgebungen
in CommanderLink.

Eine Schnittstelle ist eine physikalische und logische Grenze,
kein Komfortmechanismus.

---

## 1. Jede Schnittstelle ist eine Grenze

Schnittstellen trennen Verantwortlichkeiten und Zustände.

Folgerungen:
- Grenzen sind explizit zu definieren.
- Implizite Übergänge sind verboten.
- Grenzverletzungen sind Fehler.

---

## 2. Übergänge kosten Zeit und Ressourcen

Jeder Schnittstellenübertritt erzeugt Overhead.

Folgerungen:
- Übergänge sind zu minimieren.
- Ketten von Schnittstellen sind instabil.
- Versteckte Übergänge sind verboten.

---

## 3. Schnittstellen sind Verträge

Eine Schnittstelle definiert erlaubtes Verhalten.

Folgerungen:
- Vertragsverletzungen sind Fehler.
- Kulanzverhalten ist verboten.
- Fehlertoleranz ist explizit zu regeln.

---

## 4. Eingaben sind feindlich

Alle Eingaben gelten als potenziell fehlerhaft.

Folgerungen:
- Validierung ist Pflicht.
- Vertrauen ohne Prüfung ist verboten.
- Grenzprüfung ist nicht optional.

---

## 5. Ausgaben sind verbindlich

Ausgaben haben reale Wirkung.

Folgerungen:
- Falsche Ausgaben sind Fehler.
- Unvollständige Ausgaben sind unzulässig.
- Mehrdeutige Ausgaben sind verboten.

---

## 6. Richtung ist relevant

Schnittstellen sind nicht symmetrisch.

Folgerungen:
- Sender- und Empfängerrollen sind getrennt.
- Verantwortlichkeiten sind eindeutig.
- Umkehr ohne Vertrag ist verboten.

---

## 7. Versionierung ist Zustandswechsel

Änderungen an Schnittstellen sind Zustandsübergänge.

Folgerungen:
- Versionen sind explizit.
- Implizite Änderungen sind verboten.
- Abwärtskompatibilität ist kein Automatismus.

---

## 8. Stabilität schlägt Flexibilität

Stabile Schnittstellen sind wichtiger als flexible.

Folgerungen:
- Erweiterung schlägt Änderung.
- Änderung ist Ausnahme.
- Brechende Änderungen sind sichtbar zu machen.

---

## 9. Fehler gehören zur Schnittstelle

Fehlerfälle sind Teil des Vertrags.

Folgerungen:
- Fehlerausgaben sind definiert.
- Schweigen ist verboten.
- Teilantworten sind kenntlich zu machen.

---

## 10. Schnittstellen sind messbar

Grenzübergänge müssen beobachtbar sein.

Folgerungen:
- Latenz ist zu messen.
- Fehlerquoten sind sichtbar.
- Dunkle Schnittstellen sind verboten.

---

## 11. Isolation ist Pflicht

Schnittstellen begrenzen Schadensausbreitung.

Folgerungen:
- Fehler dürfen Grenzen nicht durchbrechen.
- Seiteneffekte sind zu minimieren.
- Kopplung ist zu reduzieren.

---

## 12. Minimalismus ist Sicherheit

Jede zusätzliche Funktion erhöht Risiko.

Folgerungen:
- Minimale Schnittstellen sind vorzuziehen.
- Überladung ist verboten.
- Unbenutzte Pfade sind zu entfernen.

---

## 13. Architekturbindung

CommanderLink Schnittstellen binden sich an:

- explizite Verträge
- messbare Übergänge
- deterministische Grenzdefinitionen

Andere Schnittstellenmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Schnittstellen entscheiden über Ordnung oder Chaos.

Ein System mit unscharfen Grenzen
kann weder sicher noch stabil sein.

Dieses Gesetz ist Grundlage aller
ABI-, API- und Wire-Verträge.


<<< END FILE: ./docs/laws/LAW_14_INTERFACE.md

>>> START FILE: ./docs/laws/LAW_15_CONFIGURATION.md
# LAW_15_CONFIGURATION.md
## CommanderLink – Konfigurations- & Parameter-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Konfiguration, Parameterisierung
und alle einstellbaren Werte
in CommanderLink.

Konfiguration verändert physikalisches Verhalten
und ist kein Komfortmerkmal.

---

## 1. Konfiguration ist Eingriff

Jede Konfiguration verändert den Systemzustand.

Folgerungen:
- Konfigurationsänderungen sind Zustandswechsel.
- Unbeabsichtigte Änderungen sind Fehler.
- Laufzeitänderungen sind besonders kritisch.

---

## 2. Default ist ein Vertrag

Ein Default-Wert ist eine bewusste Entscheidung.

Folgerungen:
- Defaults müssen stabil sein.
- Unsichere Defaults sind verboten.
- „Unkonfiguriert“ ist kein Zustand.

---

## 3. Konfiguration ist endlich

Nicht alles darf konfigurierbar sein.

Folgerungen:
- Physikalische Grenzen sind nicht konfigurierbar.
- Kernverhalten ist fest.
- Überkonfiguration ist ein Designfehler.

---

## 4. Konfiguration ersetzt keine Logik

Parameter dürfen keine fehlende Steuerung kompensieren.

Folgerungen:
- Parameter ohne Regelkreis sind verboten.
- Manuelle Feinabstimmung ersetzt keine Kontrolle.
- Magische Werte sind unzulässig.

---

## 5. Konfiguration ist deterministisch

Gleiche Konfiguration erzeugt gleiches Verhalten.

Folgerungen:
- Kontextabhängige Interpretation ist verboten.
- Zufällige Initialisierung ist unzulässig.
- Reihenfolgeeffekte sind zu vermeiden.

---

## 6. Konfiguration ist validierbar

Jede Konfiguration muss prüfbar sein.

Folgerungen:
- Ungültige Konfigurationen sind abzulehnen.
- Grenzwerte sind explizit.
- Teilgültigkeit ist verboten.

---

## 7. Konfiguration ist sichtbar

Aktive Konfigurationen müssen beobachtbar sein.

Folgerungen:
- Versteckte Parameter sind verboten.
- Laufende Werte sind einsehbar.
- Abweichungen sind erkennbar.

---

## 8. Konfiguration ist versioniert

Änderungen an Konfigurationen sind nachvollziehbar.

Folgerungen:
- Versionierung ist Pflicht.
- Implizite Migration ist verboten.
- Rollback muss möglich sein.

---

## 9. Konfiguration ist minimal

Weniger Parameter erhöhen Stabilität.

Folgerungen:
- Reduktion schlägt Flexibilität.
- Selten genutzte Parameter sind zu entfernen.
- Sonderfälle sind zu eliminieren.

---

## 10. Konfiguration folgt Physik

Parameter dürfen physikalische Realität nicht verletzen.

Folgerungen:
- Wunschwerte sind irrelevant.
- Physikalische Messung schlägt Konfiguration.
- Konflikte erzwingen Korrektur.

---

## 11. Konfiguration ist kein Geheimnis

Konfiguration ist kein Sicherheitsmechanismus.

Folgerungen:
- Versteckte Werte bieten keine Sicherheit.
- Sicherheit erfolgt an anderer Stelle.
- Obfuskation ist verboten.

---

## 12. Konfiguration endet an der Grenze

Externe Konfiguration darf interne Gesetze nicht brechen.

Folgerungen:
- Schnittstellen begrenzen Konfiguration.
- Überschreibung ohne Vertrag ist verboten.
- Externe Kontrolle ist eingeschränkt.

---

## 13. Architekturbindung

CommanderLink Konfiguration bindet sich an:

- deterministische Parameter
- explizite Validierung
- messbares Verhalten

Andere Konfigurationsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Konfiguration ist Macht über das System.

Wer Konfiguration ungezügelt zulässt,
tauscht Kontrolle gegen Chaos.

Dieses Gesetz ist Grundlage aller
Policy-, Tuning- und Betriebsverträge.


<<< END FILE: ./docs/laws/LAW_15_CONFIGURATION.md

>>> START FILE: ./docs/laws/LAW_16_DEPLOYMENT.md
# LAW_16_DEPLOYMENT.md
## CommanderLink – Ausrollungs- & Betriebs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Auslieferung, Inbetriebnahme,
Betrieb und Stilllegung
von CommanderLink.

Deployment ist ein physikalischer und organisatorischer Eingriff,
kein logistischer Nebenschritt.

---

## 1. Deployment verändert Realität

Jede Ausrollung verändert den Systemzustand.

Folgerungen:
- Deployment ist ein Zustandswechsel.
- Teildeployment ist ein Fehlerzustand.
- Ungesteuertes Deployment ist verboten.

---

## 2. Betrieb ist der Normalzustand

Der Betrieb ist kein Sonderfall.

Folgerungen:
- Betrieb bestimmt Designentscheidungen.
- Testzustände sind degradiert.
- Produktionsrealität hat Vorrang.

---

## 3. Inbetriebnahme ist kritisch

Der Start ist der fragilste Zustand.

Folgerungen:
- Initiale Last ist zu begrenzen.
- Schutzmechanismen sind aktiv.
- Optimismus ist verboten.

---

## 4. Stilllegung ist ein Zustand

Abschaltung ist Teil des Lebenszyklus.

Folgerungen:
- Geordnete Stilllegung ist Pflicht.
- Ressourcenfreigabe ist verbindlich.
- Abbruch ohne Cleanup ist verboten.

---

## 5. Rollout ist gestuft

Großflächige Änderungen erhöhen Risiko.

Folgerungen:
- Stufenweises Ausrollen ist Pflicht.
- Beobachtung zwischen Stufen ist notwendig.
- Sofortige Vollausrollung ist verboten.

---

## 6. Rollback ist Pflicht

Jede Änderung muss rückgängig gemacht werden können.

Folgerungen:
- Rückkehrpfade sind vorzuhalten.
- Einweg-Deployments sind verboten.
- Rollback-Zeit ist zu budgetieren.

---

## 7. Umgebung ist Teil des Systems

Hardware, OS und Topologie beeinflussen Verhalten.

Folgerungen:
- Umgebung ist zu erfassen.
- Annahmen über Umgebung sind verboten.
- Drift ist zu erkennen.

---

## 8. Betrieb erzeugt Verschleiß

Langzeitbetrieb verändert Systeme.

Folgerungen:
- Alterung ist einzukalkulieren.
- Ressourcenverhalten driftet.
- Periodische Neubewertung ist Pflicht.

---

## 9. Automatik schlägt manuelle Pflege

Dauerbetrieb erfordert Automatisierung.

Folgerungen:
- Manuelle Routinen sind fehleranfällig.
- Automatische Überwachung ist Pflicht.
- Mensch ist nicht der Regelkreis.

---

## 10. Updates sind Zustandswechsel

Aktualisierung ist kein Detail.

Folgerungen:
- Updates sind zu planen.
- Nebenwirkungen sind zu erwarten.
- Live-Updates ohne Schutz sind verboten.

---

## 11. Konfigurationsdrift ist Fehler

Abweichungen vom Sollzustand sind kritisch.

Folgerungen:
- Drift ist zu erkennen.
- Selbstheilung ist vorzusehen.
- Stiller Drift ist verboten.

---

## 12. Betrieb ist messpflichtig

Ein System ohne Betriebsdaten ist blind.

Folgerungen:
- Laufzeitmessung ist Pflicht.
- Langzeittrends sind relevant.
- Kurzsichtige Beobachtung ist unzureichend.

---

## 13. Architekturbindung

CommanderLink Betrieb bindet sich an:

- reale Betriebsumgebungen
- messbare Langzeitzustände
- kontrollierte Zustandswechsel

Andere Betriebsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Ein System, das nur im Labor funktioniert,
existiert nicht.

Stabiler Betrieb ist der einzige gültige Beweis
für Korrektheit.

Dieses Gesetz ist Grundlage aller
Release-, Update- und Betriebsverträge.


<<< END FILE: ./docs/laws/LAW_16_DEPLOYMENT.md

>>> START FILE: ./docs/laws/LAW_17_GOVERNANCE.md
# LAW_17_GOVERNANCE.md
## CommanderLink – Entscheidungs-, Autoritäts- & Änderungs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Entscheidungsfindung, Autorität,
Änderungen und Eskalation
innerhalb von CommanderLink.

Governance ist Teil der Systemstabilität,
keine organisatorische Nebensache.

---

## 1. Gesetze stehen über Implementierungen

Gesetze definieren die Realität des Systems.

Folgerungen:
- Implementierungen müssen Gesetzen folgen.
- Abweichungen sind Fehler.
- Nachträgliche Rechtfertigung ist verboten.

---

## 2. Änderungen sind Zustandswechsel

Jede Änderung verändert Systemverhalten.

Folgerungen:
- Änderungen sind explizit zu deklarieren.
- Implizite Änderungen sind verboten.
- Änderung ohne Freigabe ist unzulässig.

---

## 3. Freigabe ist bindend

Nicht freigegebene Artefakte existieren nicht.

Folgerungen:
- Vorläufige Zustände sind gekennzeichnet.
- Nutzung ohne Freigabe ist verboten.
- Freigabe ist ein klarer Akt.

---

## 4. Konsistenz schlägt Fortschritt

Inkonsistenter Fortschritt ist Rückschritt.

Folgerungen:
- Konsistenz hat Vorrang.
- Teilweise Aktualisierung ist verboten.
- Widersprüche sind sofort zu klären.

---

## 5. Autorität ist eindeutig

Entscheidungen benötigen eine klare Quelle.

Folgerungen:
- Mehrfachautorität ist verboten.
- Unklare Zuständigkeit ist ein Fehler.
- Eskalation ist definiert.

---

## 6. Eskalation ist strukturiert

Konflikte werden nicht ignoriert.

Folgerungen:
- Eskalationspfade sind bekannt.
- Blockaden sind sichtbar.
- Stillstand ohne Entscheidung ist verboten.

---

## 7. Rücknahme ist erlaubt

Fehlentscheidungen sind korrigierbar.

Folgerungen:
- Revidieren ist kein Scheitern.
- Festhalten an Fehlern ist verboten.
- Korrektur erfolgt offen.

---

## 8. Dokumente sind Verträge

Schriftliche Artefakte sind bindend.

Folgerungen:
- Unklare Dokumente sind ungültig.
- Widersprüchliche Dokumente sind Fehler.
- Mündliche Annahmen existieren nicht.

---

## 9. Versionierung ist Wahrheit

Der Stand eines Dokuments ist eindeutig.

Folgerungen:
- Versionen sind explizit.
- „Aktuell“ ohne Version ist verboten.
- Historie ist nachvollziehbar.

---

## 10. Stabilität begrenzt Änderung

Nicht alles darf jederzeit geändert werden.

Folgerungen:
- Kern-Gesetze sind stabil.
- Änderungen erfordern Begründung.
- Änderungsdruck ersetzt keine Notwendigkeit.

---

## 11. Transparenz ist Pflicht

Entscheidungen sind nachvollziehbar.

Folgerungen:
- Verborgene Änderungen sind verboten.
- Begründungen sind sichtbar.
- Unklare Motive sind unzulässig.

---

## 12. Governance ist messbar

Auch Entscheidungsprozesse erzeugen Signale.

Folgerungen:
- Verzögerungen sind sichtbar.
- Konflikthäufung ist ein Indikator.
- Governance-Versagen ist ein Systemfehler.

---

## 13. Architekturbindung

CommanderLink Governance bindet sich an:

- verbindliche Gesetze
- explizite Freigaben
- nachvollziehbare Entscheidungen

Andere Governance-Modelle erfordern neue Gesetze.

---

## 14. Schlussformel

Ohne klare Autorität gibt es keine Stabilität.

Ein System ohne Governance
zerfällt nicht technisch,
sondern durch Entscheidungen.

Dieses Gesetz ist Grundlage aller
Freeze-, Review- und Freigabeprozesse.


<<< END FILE: ./docs/laws/LAW_17_GOVERNANCE.md

>>> START FILE: ./docs/laws/LAW_18_DOCUMENTATION.md
# LAW_18_DOCUMENTATION.md
## CommanderLink – Dokumentations- & Wissens-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Erstellung, Pflege und Gültigkeit
aller schriftlichen Artefakte
in CommanderLink.

Dokumentation ist Teil des Systems,
nicht Begleitmaterial.

---

## 1. Dokumentation ist Wahrheitsträger

Was nicht dokumentiert ist, gilt als nicht existent.

Folgerungen:
- Implizites Wissen ist verboten.
- Annahmen ohne Dokument sind ungültig.
- Dokumentation ist bindend.

---

## 2. Gesetze schlagen Erläuterungen

Normative Texte haben Vorrang vor erklärenden.

Folgerungen:
- Gesetze definieren Verhalten.
- Kommentare erklären, ändern aber nichts.
- Widerspruch zugunsten der Norm.

---

## 3. Präzision schlägt Lesbarkeit

Eindeutigkeit hat Vorrang vor Stil.

Folgerungen:
- Mehrdeutige Formulierungen sind verboten.
- Umgangssprache ist unzulässig.
- Interpretationsfreiheit ist ein Fehler.

---

## 4. Vollständigkeit ist Pflicht

Teilwissen erzeugt Fehlverhalten.

Folgerungen:
- Lücken sind explizit zu kennzeichnen.
- Unvollständige Dokumente sind unfertig.
- Schweigen ist kein Default.

---

## 5. Dokumentation ist versioniert

Jeder Stand ist eindeutig identifizierbar.

Folgerungen:
- Versionsangabe ist Pflicht.
- Zeitliche Einordnung ist notwendig.
- „Letzter Stand“ ohne Referenz ist verboten.

---

## 6. Aktualität ist ein Zustand

Veraltete Dokumentation ist ein Fehler.

Folgerungen:
- Drift zwischen System und Text ist unzulässig.
- Änderungen erzwingen Aktualisierung.
- Stille Veralterung ist verboten.

---

## 7. Trennung von Norm und Kommentar

Normative und erklärende Inhalte sind getrennt.

Folgerungen:
- Gesetze enthalten keine Tutorials.
- Beispiele sind nicht normativ.
- Vermischung ist verboten.

---

## 8. Dokumentation ist maschinenlesbar denkbar

Dokumente müssen strukturiert sein.

Folgerungen:
- Klare Kapitelstruktur ist Pflicht.
- Referenzen sind eindeutig.
- Freitext ohne Struktur ist degradiert.

---

## 9. Redundanz ist kontrolliert

Mehrfachnennung erzeugt Inkonsistenz.

Folgerungen:
- Single Source of Truth ist anzustreben.
- Redundanz erfordert Synchronisation.
- Abweichungen sind Fehler.

---

## 10. Dokumentation ist überprüfbar

Texte müssen prüfbar widerspruchsfrei sein.

Folgerungen:
- Selbstwiderspruch ist verboten.
- Querverweise sind korrekt zu halten.
- Ungültige Referenzen sind Fehler.

---

## 11. Dokumentation ist öffentlich im Projekt

Versteckte Dokumente existieren nicht.

Folgerungen:
- Alle bindenden Texte sind auffindbar.
- Private Regeln sind verboten.
- Transparenz ist Pflicht.

---

## 12. Dokumentation endet nicht

Wissen altert, Systeme ändern sich.

Folgerungen:
- Pflege ist dauerhaft.
- Einmal schreiben reicht nicht.
- Stillstand ist Verfall.

---

## 13. Architekturbindung

CommanderLink Dokumentation bindet sich an:

- normative Markdown-Gesetze
- eindeutige Versionierung
- konsistente Terminologie

Andere Dokumentationsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Ein undokumentiertes System
ist nicht kontrollierbar.

Wer Dokumentation vernachlässigt,
überlässt die Wahrheit dem Zufall.

Dieses Gesetz ist Grundlage aller
Review-, Freeze- und Implementierungsphasen.


<<< END FILE: ./docs/laws/LAW_18_DOCUMENTATION.md

>>> START FILE: ./docs/laws/LAW_19_IMPLEMENTATION.md
# LAW_19_IMPLEMENTATION.md
## CommanderLink – Implementierungs- & Ableitungs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt die Ableitung von Implementierungen
aus den CommanderLink-Gesetzen.

Implementierung ist die physikalische Realisierung von Recht,
nicht dessen Interpretation.

---

## 1. Gesetze sind primär

Implementierungen existieren ausschließlich zur Umsetzung der Gesetze.

Folgerungen:
- Implementierungen haben keine Eigenautorität.
- „Funktioniert in der Praxis“ rechtfertigt keinen Gesetzesbruch.
- Optimierung ohne Gesetzesgrundlage ist verboten.

---

## 2. Ableitung ist deterministisch

Aus Gesetzen folgt genau ein erlaubter Lösungsraum.

Folgerungen:
- Mehrdeutige Ableitungen sind unzulässig.
- Implizite Annahmen sind verboten.
- Jeder Designschritt muss rückführbar sein.

---

## 3. Kein Code ohne Gesetz

Code ohne gesetzliche Grundlage ist nicht existent.

Folgerungen:
- Jedes Modul referenziert mindestens ein Gesetz.
- Unreferenzierter Code ist zu entfernen.
- „Vorbereitender Code“ ist verboten.

---

## 4. Implementierung respektiert Physik

Kein Code darf physikalische Realität abstrahieren oder ignorieren.

Folgerungen:
- Worst-Case-Pfad ist maßgeblich.
- Undefined Behavior ist verboten.
- Heuristik ohne Messung ist unzulässig.

---

## 5. Einfachheit ist bindend

Komplexität ist ein Implementierungsrisiko.

Folgerungen:
- Der einfachste gesetzeskonforme Ansatz ist zu wählen.
- Cleverness ohne Notwendigkeit ist verboten.
- Komplexität erfordert explizite Rechtfertigung.

---

## 6. Sichtbarkeit ist Pflicht

Implementiertes Verhalten muss beobachtbar sein.

Folgerungen:
- Stille Effekte sind verboten.
- Interne Zustände sind messbar zu machen.
- Debug-Pfad ist kein Sonderpfad.

---

## 7. Fehlerpfade sind gleichwertig

Fehlerpfade sind Teil der Implementierung.

Folgerungen:
- Fehlerpfade sind vollständig implementiert.
- Abkürzungen im Fehlerfall sind verboten.
- Recovery ist kein Nachgedanke.

---

## 8. Performance ist kein Selbstzweck

Performance dient Stabilität und Determinismus.

Folgerungen:
- Schnell, aber instabil ist ungültig.
- Vorhersagbarkeit schlägt Spitzenleistung.
- Optimierung ohne Messgrundlage ist verboten.

---

## 9. Portabilität ist nachrangig

Physikalische Korrektheit hat Vorrang vor Portabilität.

Folgerungen:
- x86_64 ist Referenzarchitektur.
- Abstraktion darf keine Kosten verschleiern.
- Andere Architekturen benötigen neue Gesetze.

---

## 10. Implementierung ist überprüfbar

Code muss überprüfbar sein.

Folgerungen:
- Klarheit schlägt Kürze.
- Deterministisches Verhalten ist beweisbar.
- Verifikation ist vorgesehen.

---

## 11. Implementierung ist austauschbar

Kein Implementierungsdetail ist sakrosankt.

Folgerungen:
- Austausch ohne Gesetzesänderung ist möglich.
- Lock-in durch Implementation ist verboten.
- Verhalten bleibt konstant.

---

## 12. Freeze ist bindend

Freigegebene Implementierungen sind eingefroren.

Folgerungen:
- Änderungen erfordern neue Freigabe.
- Stillen Drift gibt es nicht.
- Hotfix ohne Gesetz ist verboten.

---

## 13. Architekturbindung

CommanderLink Implementierungen binden sich an:

- x86_64 Physik
- explizite Gesetze
- deterministische Ableitung

Andere Implementierungsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Implementierung ist Ausführung von Recht.

Ein System, das seine Gesetze nicht einhalten kann,
ist nicht falsch implementiert –
es ist falsch entworfen.

Dieses Gesetz ist Grundlage aller
Header-, Code- und Build-Artefakte.


<<< END FILE: ./docs/laws/LAW_19_IMPLEMENTATION.md

>>> START FILE: ./docs/laws/LAW_20_VERIFICATION.md
# LAW_20_VERIFICATION.md
## CommanderLink – Verifikations-, Test- & Beweis-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz regelt Verifikation, Test, Nachweis
und Beweisführung
für CommanderLink.

Verifikation ist der Beweis der Gesetzestreue,
nicht eine Qualitätsvermutung.

---

## 1. Verifikation ist Pflicht

Unverifiziertes Verhalten ist ungültig.

Folgerungen:
- Jede relevante Eigenschaft ist zu verifizieren.
- Vertrauen ohne Nachweis ist verboten.
- Nicht prüfbares Verhalten ist unzulässig.

---

## 2. Gesetze definieren Tests

Tests leiten sich aus Gesetzen ab, nicht umgekehrt.

Folgerungen:
- Jeder Test referenziert mindestens ein Gesetz.
- Tests ohne Gesetzesbezug sind zu entfernen.
- Änderung eines Gesetzes erzwingt Testanpassung.

---

## 3. Worst-Case ist der Referenzfall

Verifikation erfolgt am schlimmsten Fall.

Folgerungen:
- Durchschnittstests sind unzureichend.
- Grenzfälle sind Pflicht.
- Erfolg im Best-Case ist irrelevant.

---

## 4. Determinismus ist beweispflichtig

Deterministisches Verhalten muss nachgewiesen werden.

Folgerungen:
- Wiederholbarkeit ist Pflicht.
- Abweichungen sind Fehler.
- Flaky Tests sind unzulässig.

---

## 5. Messung schlägt Simulation

Reale Messung hat Vorrang vor Modellannahmen.

Folgerungen:
- Hardware-nahe Tests sind Referenz.
- Simulation ist degradiert.
- Annahmen ohne Messung sind verboten.

---

## 6. Störung ist Teil des Tests

Tests müssen Störungen einschließen.

Folgerungen:
- Überlast, Hitze, Jitter sind zu provozieren.
- Ideale Bedingungen sind unzureichend.
- Robustheit ist zu beweisen.

---

## 7. Fehlerpfade sind primär

Fehlerpfade sind gleichwertig zu testen.

Folgerungen:
- Fehlerfalltests sind Pflicht.
- Recovery ist zu verifizieren.
- Untestbare Fehlerpfade sind verboten.

---

## 8. Langzeitverhalten ist relevant

Kurztests reichen nicht aus.

Folgerungen:
- Dauerläufe sind Pflicht.
- Drift ist zu erkennen.
- Stabilität über Zeit ist nachzuweisen.

---

## 9. Isolation ist überprüfbar

Grenzen müssen standhalten.

Folgerungen:
- Fehler dürfen Grenzen nicht überschreiten.
- Kaskaden sind zu testen.
- Isolation ohne Nachweis ist ungültig.

---

## 10. Regression ist sichtbar

Einmal korrektes Verhalten bleibt korrekt.

Folgerungen:
- Regressionstests sind Pflicht.
- Stillen Verschlechterungen sind verboten.
- Jede Abweichung ist zu begründen.

---

## 11. Beweise sind reproduzierbar

Nachweise müssen wiederholbar sein.

Folgerungen:
- Testumgebung ist definiert.
- Abhängigkeiten sind dokumentiert.
- Zufälligkeit ist ausgeschlossen.

---

## 12. Verifikation endet nicht

Änderung erzwingt neue Verifikation.

Folgerungen:
- Freigabe ist zeitgebunden.
- Alternde Nachweise sind ungültig.
- Pflege ist dauerhaft.

---

## 13. Architekturbindung

CommanderLink Verifikation bindet sich an:

- reale x86_64 Hardware
- messbare Zustände
- gesetzesgeleitete Testableitung

Andere Verifikationsmodelle erfordern neue Gesetze.

---

## 14. Schlussformel

Was nicht bewiesen ist,
gilt als falsch.

Verifikation ist kein Schritt im Prozess,
sondern die Existenzbedingung des Systems.

Dieses Gesetz ist Grundlage aller
Test-, Audit- und Freigabeentscheidungen.


<<< END FILE: ./docs/laws/LAW_20_VERIFICATION.md

>>> START FILE: ./docs/laws/LAW_21_SCOPE.md
# LAW_21_SCOPE.md
## CommanderLink – Geltungs-, Abschluss- & Vollständigkeits-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Geltungsbereich

Dieses Gesetz definiert den Geltungsrahmen,
die Vollständigkeit und den Abschluss
des CommanderLink-Gesetzeswerks.

Es legt fest, wann das System als vollständig,
konsistent und handlungsfähig gilt.

---

## 1. Das Gesetzeswerk ist geschlossen

Die Menge der Gesetze definiert den vollständigen Handlungsraum.

Folgerungen:
- Verhalten außerhalb der Gesetze ist unzulässig.
- Implizite Regeln existieren nicht.
- Ergänzungen erfolgen nur durch neue Gesetze.

---

## 2. Nicht geregeltes Verhalten ist verboten

Fehlende Regel ist kein Freiraum.

Folgerungen:
- Unregulierte Fälle sind Designfehler.
- Schweigen bedeutet Verbot.
- Lücken erzwingen Gesetzeserweiterung.

---

## 3. Gesetze sind hierarchisch konsistent

Alle Gesetze müssen widerspruchsfrei sein.

Folgerungen:
- Niedrigere Gesetze dürfen höhere nicht verletzen.
- Konflikte sind aufzulösen, nicht zu umgehen.
- Inkonsistenz blockiert Implementierung.

---

## 4. Physik bleibt oberste Instanz

Kein Gesetz darf physikalischer Realität widersprechen.

Folgerungen:
- LAW_00_PHYSICS ist absolut.
- Ableitung darf Physik nicht relativieren.
- Widerspruch erzwingt Revision.

---

## 5. Vollständigkeit ist überprüfbar

Das Gesetzeswerk muss überprüfbar vollständig sein.

Folgerungen:
- Jeder Systembereich ist abgedeckt.
- Ungeregelte Domänen sind sichtbar.
- „Später klären“ ist unzulässig.

---

## 6. Abschluss ist ein Zustand

Ein freigegebener Gesetzesstand ist ein stabiler Zustand.

Folgerungen:
- Freigabe erzeugt Freeze.
- Änderungen erfordern neue Version.
- Gleichzeitige Stände sind verboten.

---

## 7. Erweiterung ist strukturiert

Neue Gesetze folgen derselben Norm.

Folgerungen:
- Nummerierung ist strikt.
- Geltungsbereich ist explizit.
- Rückwirkung ist ausgeschlossen.

---

## 8. Reduktion ist erlaubt

Gesetze dürfen entfallen, wenn sie obsolet sind.

Folgerungen:
- Entfernung erfordert Begründung.
- Abhängigkeiten sind zu prüfen.
- Stille Streichung ist verboten.

---

## 9. Referenzstand ist eindeutig

Es existiert genau ein aktiver Gesetzesstand.

Folgerungen:
- Mehrdeutige Referenzen sind verboten.
- Implementierung bindet sich an einen Stand.
- Historische Stände sind archiviert.

---

## 10. Gesetze sind zeitlos formuliert

Gesetze beschreiben Prinzipien, keine Versionen.

Folgerungen:
- Temporäre Details sind verboten.
- Zeitabhängige Annahmen sind unzulässig.
- Gültigkeit endet nur durch Revision.

---

## 11. Gesetzesverletzung ist Systemfehler

Abweichung ist kein Feature.

Folgerungen:
- Verletzungen sind sichtbar zu machen.
- Umgehung ist verboten.
- Tolerierung ist unzulässig.

---

## 12. Abschluss definiert Handlungsfähigkeit

Mit Abschluss beginnt Implementierung.

Folgerungen:
- Vor Abschluss kein Code.
- Nach Abschluss ist Code verpflichtend gesetzestreu.
- Parallelität von Gesetz und Code ist verboten.

---

## 13. Architekturbindung

CommanderLink Geltungsrahmen bindet sich an:

- physikalische Realität
- konsistente Gesetzeshierarchie
- explizite Freigabestände

---

## 14. Schlussformel

Ein System ohne klaren Geltungsrahmen
kennt keine Grenze zwischen erlaubt und verboten.

Mit diesem Gesetz ist das Fundament geschlossen.

Alles Weitere ist Ableitung.


<<< END FILE: ./docs/laws/LAW_21_SCOPE.md

>>> START FILE: ./docs/laws/LAW_22_STATUS.md
# LAW_22_STATUS.md
## CommanderLink – Stand-, Abschluss- & Start-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGEGEBEN

---

## 0. Feststellung

Das CommanderLink-Gesetzeswerk ist vollständig.

Alle relevanten Domänen sind normativ geregelt.
Es existieren keine offenen Pflichtgesetze.

---

## 1. Abschlusszustand

Der aktuelle Stand umfasst:

- LAW_00_PHYSICS bis LAW_21_SCOPE
- Geschlossene, widerspruchsfreie Hierarchie
- Vollständige Abdeckung von Physik bis Governance

Dieser Stand ist **handlungsfähig**.

---

## 2. Freeze

Mit diesem Gesetz gilt:

- Gesetzesstand ist eingefroren
- Keine impliziten Ergänzungen
- Keine parallele Gesetzesentwicklung

Änderungen erfordern neue Gesetze
oder eine explizite Revision bestehender.

---

## 3. Startfreigabe

Ab diesem Stand ist erlaubt und verpflichtend:

- Ableitung von Verträgen
- Ableitung von Headern
- Ableitung von Code

Alles Weitere ist Implementierung.

---

## 4. Schlussformel

Ja.

Wir sind auf Stand.

Alles, was folgt, ist Ableitung –  
nicht mehr Definition.


<<< END FILE: ./docs/laws/LAW_22_STATUS.md

>>> START FILE: ./docs/laws/LAW_23_SYMBIONT.md
# LAW_23_SYMBIONT.md
## CommanderLink – Symbiont-Gesetz (Koexistenz mit dem Wirtssystem)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert CommanderLink als **Symbionten**:
ein System, das mit einem Wirt (Hardware + OS + Workloads)
koexistiert, diesen schützt und verstärkt,
ohne ihn zu dominieren.

CommanderLink ist kein Parasit, kein Orchestrator
und kein Ersatz für das Betriebssystem.

---

## 1. Symbiose ist Vorrang

CommanderLink existiert nur im Zusammenspiel mit dem Wirt.

Folgerungen:
- Der Wirt hat Existenzvorrang.
- Selbstschutz des Wirts schlägt Eigeninteresse von CL.
- Verdrängung des Wirts ist verboten.

---

## 2. Nicht-Invasivität ist Grundzustand

Der Default-Zustand ist minimaler Eingriff.

Folgerungen:
- Keine exklusiven Ressourcen ohne Notwendigkeit.
- Kein Dauer-Pinning ohne Rechtfertigung.
- Kein permanenter Hot-Path ohne Nutzen.

---

## 3. Schutz schlägt Leistung

CommanderLink schützt den Wirt vor Instabilität.

Folgerungen:
- Lastreduktion ist Pflicht bei Stress.
- Eigene Arbeit wird zuerst gedrosselt.
- Durchsatzverlust ist akzeptabel, Schaden nicht.

---

## 4. Rückzug ist korrektes Verhalten

CommanderLink muss sich zurückziehen können.

Folgerungen:
- Sofortiger Rückzug bei Interaktivität des Wirts.
- Ressourcenfreigabe ist priorisiert.
- Blockieren des Wirts ist verboten.

---

## 5. Koexistenz mit dem Scheduler

CommanderLink konkurriert nicht blind mit dem OS-Scheduler.

Folgerungen:
- OS-Entscheidungen sind Signale.
- CL passt sich an Preemption an.
- Gegenscheduling ist verboten.

---

## 6. Nutzung freier Kapazität

CommanderLink nutzt bevorzugt ungenutzte Ressourcen.

Folgerungen:
- Idle-Zeiten sind Primärziel.
- Opportunistische Beschleunigung ist erlaubt.
- Zwangsnutzung ist verboten.

---

## 7. Transparenz gegenüber dem Wirt

Der Wirt darf nicht überrascht werden.

Folgerungen:
- Ressourcennutzung ist sichtbar.
- Eingriffe sind nachvollziehbar.
- Verdecktes Verhalten ist verboten.

---

## 8. Reversibilität aller Eingriffe

Jeder Eingriff muss rückgängig gemacht werden können.

Folgerungen:
- Temporäre Maßnahmen sind der Normalfall.
- Dauerhafte Bindungen sind Ausnahmefälle.
- Irreversible Zustände sind verboten.

---

## 9. Eigenbudget ist begrenzt

CommanderLink besitzt ein eigenes Budget.

Folgerungen:
- CPU-, Speicher- und I/O-Budget sind begrenzt.
- Budgetüberschreitung erzwingt Selbstreduktion.
- Fremdbudget darf nicht konsumiert werden.

---

## 10. Eigenwahrnehmung ist Pflicht

CommanderLink überwacht sich selbst.

Folgerungen:
- Eigene Kosten sind messbar.
- Eigene Fehler sind sichtbar.
- Selbstblindheit ist verboten.

---

## 11. Symbiont schlägt Optimierer

CommanderLink optimiert nicht isoliert.

Folgerungen:
- Lokale Optimierung ohne Gesamtsicht ist verboten.
- Nutzen wird systemweit bewertet.
- Schaden am Wirt entwertet jeden Gewinn.

---

## 12. Eskalation nur bei Gefahr

Aktive Eingriffe erfolgen nur bei realem Risiko.

Folgerungen:
- Präventive Dominanz ist verboten.
- Schutzinterlocks haben Vorrang.
- Eingriffstiefe ist proportional.

---

## 13. Lebenszyklus ist gekoppelt

CommanderLink folgt dem Lebenszyklus des Wirts.

Folgerungen:
- Start verzögert sich hinter dem Wirt.
- Shutdown priorisiert den Wirt.
- CL darf keinen Zombie-Zustand erzeugen.

---

## 14. Architekturbindung

CommanderLink als Symbiont bindet sich an:

- reale OS-Scheduler und Ressourcenmodelle
- messbare Systemzustände
- reversible Eingriffsmechanismen

Andere Koexistenzmodelle erfordern neue Gesetze.

---

## 15. Schlussformel

CommanderLink existiert,
um den Wirt stabiler zu machen als ohne ihn.

Wenn der Wirt leidet,
hat CommanderLink versagt.

Dieses Gesetz ist Grundlage aller
Budget-, Shadow-, Reclaim- und Rückzugsmechanismen.


<<< END FILE: ./docs/laws/LAW_23_SYMBIONT.md

>>> START FILE: ./docs/laws/LAW_24_READINESS.md
# LAW_24_READINESS.md
## CommanderLink – Startreife-, Freeze- & Ableitungs-Gesetz (Manifest/Runtime)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert:

1. Welche zusätzlichen Pflichten vor Beginn der Header-Ableitung gelten.
2. Wann die Manifest-Header begonnen werden dürfen.
3. Den verbindlichen Arbeitsablauf von Gesetz → Vertrag → Header → Code.

---

## 1. Nichts Relevantes fehlt, wenn es geregelt ist

CommanderLink gilt als „bereit zur Ableitung“ nur, wenn:

- alle systemkritischen Domänen gesetzlich geregelt sind,
- keine impliziten Annahmen verbleiben,
- und keine Kernbegriffe unbestimmt sind.

Nicht geregeltes Verhalten ist verboten.

---

## 2. Pflichtliste „vor Header“

Vor Beginn der **Manifest-Header** müssen genau diese Punkte als **normative Texte** vorliegen:

1. **Terminologie-Fixierung** (Begriffe, Zustände, Rollen; Single Meaning)
2. **Freeze-Regel** (was ist „freigegeben“, was ist „in Arbeit“)
3. **Policy-vs-Runtime Trennung** (Manifest definiert compile-time Gesetze; Runtime beschreibt Laufzeit-Wahrheit)
4. **Trust/Join Grundsatz** (Default-deny; Übergänge; Entzug)
5. **Budget & Rückzug** (Symbiont-Regelkreis; Prioritäten)
6. **Endianness/Order** (Host-Order intern; Wire-Order explizit)
7. **ABI-Determinismus** (Layout, Größen, Alignment, keine impliziten Pads)

Wenn einer dieser Punkte nicht eindeutig geregelt ist, ist Header-Start verboten.

---

## 3. Header-Startkriterium

Manifest-Header dürfen begonnen werden, wenn:

- LAW_00 bis LAW_24 freigegeben sind,
- keine Widersprüche zwischen Gesetzen existieren,
- und die Pflichtliste „vor Header“ vollständig erfüllt ist.

Ab dann gilt:
- Manifest-Header sind **Ableitung**, nicht Verhandlung.
- Änderungen an Manifest-Headern sind nur über Gesetzesrevision zulässig.

---

## 4. Reihenfolge der Ableitung

Die Ableitung erfolgt strikt in dieser Reihenfolge:

1. Manifest (compile-time Gesetze)
2. Runtime-Verträge (SHM/Wahrheit/Segmente)
3. Common-Mechanik (kleinster gemeinsamer Unterbau)
4. Tools (ABI-Report, Dumper, Validity Gates)
5. Erst danach Data Plane / Link / Flow / Monitor

Abweichung ist verboten.

---

## 5. Arbeitsmodus „Symbiont“

Der Symbiont-Charakter wird vor allem durch diese Ableitungsziele erreicht:

- Budgetierung als primäre Leitplanke
- Rückzug/Degradation als Standardpfad
- Messung als einzige Wahrheit
- Interlocks mit Vorrang
- Reversibilität aller Eingriffe

Jede Header-Entscheidung muss auf diese Ziele rückführbar sein.

---

## 6. Projektzustand (normative Einschätzung)

CommanderLink ist im Kern **richtig** aufgestellt, wenn diese Eigenschaften erfüllt sind:

- Physik-first: Gesetze dominieren jede Implementation.
- Symbiont: Schutz des Wirts ist übergeordnet.
- Determinismus/Worst-Case: keine „best effort“-Lücken.
- Messung/Wahrheit: klare Trennung von Rohdaten und Interpretation.
- Änderungsdisziplin: Freeze/Versionierung/Single Source of Truth.

Wenn eine dieser Eigenschaften praktisch verletzt wird, ist das Projekt nicht „falsch gebaut“, sondern **noch nicht fertig abgeleitet**.

---

## 7. Wann beginnen wir konkret?

Beginn der Manifest-Header ist **jetzt** erlaubt, wenn:

- Du erklärst, dass LAW_00–LAW_24 als Arbeitsstand gelten,
- und wir die Pflichtliste (Abschnitt 2) als bereits erfüllt betrachten.

Ab dem Moment ist der nächste Schritt verbindlich:
**Manifest Paket 0: cl_manifest_base.h + cl_manifest_terms.h (nur Begriffe/Enums/States, keine Runtime-Layouts).**

---

## 8. Schlussformel

Es gibt keine „magische Restliste“ außerhalb der Gesetze.
Was wir beachten müssen, ist Disziplin:

- nichts implizit lassen,
- nichts doppelt definieren,
- nichts ohne Freigabe bauen.

Header beginnen, sobald du den LAW-Stand freigibst.


<<< END FILE: ./docs/laws/LAW_24_READINESS.md

>>> START FILE: ./docs/laws/LAW_25_CONFORMANCE.md
```markdown
# LAW_25_CONFORMANCE.md
## CommanderLink – Konformitäts- & Cacheline-Gesetz (Physics-First Proof)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert, was „konform“ bedeutet, und setzt die
nicht verhandelbaren Prüfkriterien für:

- Physics-first
- x86_64-first
- Cacheline-Exaktheit
- ABI-/Layout-Determinismus

Es beantwortet die Frage „Sind wir fertig?“ ausschließlich über
prüfbare Kriterien.

---

## 1. Law-Bedarf

Es besteht **kein weiterer Pflicht-LAW-Bedarf**, wenn und nur wenn
die in diesem Gesetz festgelegten Konformitätskriterien erfüllt sind.

Wenn ein Kriterium nicht erfüllt ist, besteht automatisch Law-Bedarf:
entweder Revision bestehender Gesetze oder neues Gesetz für die Lücke.

---

## 2. Definition „Physics-first konform“

Ein Artefakt ist Physics-first konform, wenn:

- es keine Annahme über ideale Ressourcen trifft,
- es Worst-Case dominiert,
- es messbasiert steuert,
- es Interlocks respektiert,
- und es reversible Degradation/Rückzug besitzt.

Fehlt eine dieser Eigenschaften, ist es nicht konform.

---

## 3. Definition „Cacheline-exakt“

Cacheline-exakt bedeutet:

- Jede **Hot-/kritische** Einheit ist exakt **64 Byte** groß.
- Jede zusammengesetzte Einheit ist ein **ganzzahliges Vielfaches** von 64 Byte.
- Keine impliziten Pads beeinflussen die Größe.
- Kein Feldlayout ist compiler-abhängig.

„Ungefähr 64B“ ist verboten.

---

## 4. Alignment-Anforderungen (x86_64)

Für CommanderLink gilt normativ:

- **64B** ist die Basiseinheit für Hot-State.
- Alignment auf **64B** ist für Hot-Blöcke Pflicht.
- Strides/Records sind Vielfache von 64B.
- Segment-/Page-Boundaries sind explizit.

Abweichung ist verboten.

---

## 5. SHM-/ABI-Layout-Anforderungen

Für alle SHM-/Runtime-Strukturen gilt:

- Keine `packed`-Layouts.
- Keine Annahmen über fehlendes Compiler-Padding.
- Feldreihenfolge folgt Alignment-Realität.
- End-Padding ist explizit und berechnet, nicht geraten.
- Jede Größe wird durch `_Static_assert` erzwungen.

Wenn ein Struct ohne harte Größenasserts existiert, ist es nicht konform.

---

## 6. „x64 ausgerichtet“ bedeutet 64B, nicht „x64“

Der Begriff „x64 ausgerichtet“ ist in CommanderLink verbindlich als
**64-Byte cacheline aligned** zu verstehen.

Jede andere Interpretation ist verboten.

---

## 7. Konformitätsnachweis ist Pflicht

Konformität ist nur gültig, wenn sie bewiesen ist durch:

- Compile-time Layout-Beweise (Größe/Offset/Alignment)
- Laufzeit-Sanity Checks (optional, aber erlaubt)
- ABI-Report als single source of truth

Ohne Nachweis gilt „nicht konform“.

---

## 8. Aktueller Stand (normative Antwort)

Aus den Gesetzen allein folgt:

- Die Forderung nach Physics-first ist vollständig abgedeckt.
- Die Forderung nach Cacheline-Exaktheit ist vollständig abgedeckt.
- Ob „alles exakt an 64B Cachelines ausgerichtet“ ist,
  kann **nicht** durch Gesetze behauptet werden, sondern nur durch Nachweis.

Daher gilt aktuell normativ:

- **Gesetzlich konformierbar:** JA.
- **Faktisch bewiesen konform:** NUR, wenn ABI-/Layout-Beweise vorliegen.

---

## 9. Startkriterium für Manifest-Header unter Cacheline-Anspruch

Manifest-Header dürfen nur begonnen werden, wenn:

- die Cacheline-Regeln dieses Gesetzes als oberste ABI-Norm akzeptiert sind,
- und jede geplante Manifest-/Runtime-Struktur
  eine verpflichtende Static-Assert-Strategie besitzt.

---

## 10. Schlussformel

LAW-Bedarf: NEIN, sofern diese Konformitätsdefinition akzeptiert ist.

Physics-first: JA, normativ vollständig.

Cacheline-Exaktheit: als Pflicht definiert,
aber als Tatsache erst bewiesen, wenn der Layout-Nachweis existiert.

Damit ist der nächste zwingende Schritt:
Konformitätsnachweis als Ableitungsartefakt (ABI-Report/Static-Asserts),
und dann Manifest-Header.
```


<<< END FILE: ./docs/laws/LAW_25_CONFORMANCE.md

>>> START FILE: ./docs/laws/LAW_26_LAYOUT.md
# LAW_26_LAYOUT.md
## CommanderLink – Layout-, Padding- & „packed“-Verbot-Gesetz (SHM/ABI)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz regelt verbindlich:

- Struktur-Layout (SHM/ABI)
- Padding/Alignment-Determinismus
- Umgang mit Compiler-Freiheiten
- Verbot von `packed` und verwandten Mechanismen

Ziel: physikalisch korrektes, deterministisches, cacheline-exaktes Layout
ohne Undefined Behavior und ohne implizite Drift.

---

## 1. `packed` ist verboten

Für alle CommanderLink Datenstrukturen gilt:

- `__attribute__((packed))` ist verboten.
- `#pragma pack(...)` ist verboten.
- „packed member access“ in SHM ist verboten.
- Jegliche Form der erzwungenen Misalignment-Serialisierung im Speicherlayout ist verboten.

Begründungen sind irrelevant.
Verstoß ist ein Systemfehler.

---

## 2. Keine impliziten Padding-Annahmen

Es ist verboten anzunehmen, dass:

- der Compiler „kein Padding“ einfügt,
- Padding „schon passt“,
- oder Feldreihenfolgen „egal“ sind.

Feldreihenfolge ist physikalisch wirksam und ist deterministisch zu wählen.

---

## 3. Layout-Determinismus ist Pflicht

Jede SHM-/ABI-relevante Struktur muss:

- Größe deterministisch festlegen,
- Offsets deterministisch festlegen,
- und Alignment-Anforderungen explizit erfüllen.

Für jede Struktur gilt:
- `_Static_assert(sizeof(T) == N)`
- `_Static_assert(_Alignof(T) == A)` sofern relevant
- `_Static_assert(offsetof(T, field) == K)` für kritische Felder

Ohne diese Beweise ist die Struktur ungültig.

---

## 4. Cacheline-Block-Primat (64B)

Für SHM/Runtime gilt:

- 64B ist die atomare Layout-Einheit.
- Hot/Warm/Cold-Einheiten sind 64B-Blöcke.
- Records/Strides sind Vielfache von 64B.

Teil-Cachelines als „Record“ sind verboten.

---

## 5. Zugriffssicherheit schlägt Bitdichte

Bitdichte ist nachrangig gegenüber:

- Alignment-Korrektheit
- Load/Store-Sicherheit
- deterministischem Verhalten

Daher gilt:
- Keine bitfield-basierten SHM-Layouts.
- Keine misaligned Multi-Byte-Felder.
- Keine „Wire-Layout im SHM“.

---

## 6. Wire und SHM sind strikt getrennt

Es ist verboten, Wire-Formate (LE/packed/bitted)
direkt in SHM-Strukturen abzubilden.

Folgerungen:
- Wire ist serialisiert, SHM ist nativ.
- Wire-Parsing/Encoding ist ein expliziter Schritt.
- Endianness-Konversion ist explizit und lokal.

---

## 7. Erlaubte Mittel zur Layout-Fixierung

Erlaubt sind ausschließlich:

- natürliche Feldreihenfolge nach Alignment (u64 → u32 → u16 → u8)
- explizite End-Padding-Felder (z. B. `uint8_t pad[...]`)
- 64B-Normflächen (z. B. `uint8_t raw[64]`) als Blockrahmen
- `_Static_assert`-Beweise

Nicht erlaubt:
- `aligned(64)` auf Substrukturen als Layout-Trick,
  wenn es implizite Padding-Drift erzeugt.
- 0-Byte Pads.
- compilerabhängige Extensions als Ersatz für Beweise.

---

## 8. Alias- und UB-Regeln

Für SHM-Daten gilt:

- Strict-Aliasing-Tricks sind verboten.
- Reinterpret-Casts zur Feldsicht sind verboten, wenn UB möglich ist.
- Notwendige Typumdeutung erfolgt über sichere Mechanik (z. B. Kopiersemantik).

Ein UB-Risiko macht den Datensatz ungültig.

---

## 9. Prüfpflicht

Jede Build-Konfiguration muss Layoutfehler als Hard-Fail behandeln:

- Warnings über „packed member access“ sind Hard-Fail.
- Size/Align/Offset-Drift ist Hard-Fail.
- Unterschiedliche Compiler-Ergebnisse sind Hard-Fail.

Ein Build, der solche Fehler toleriert, ist nicht CommanderLink.

---

## 10. Schlussformel

`packed` ist in CommanderLink nicht nur unerwünscht,
sondern physikalisch unzulässig.

Layout wird nicht „gemacht“,
Layout wird **bewiesen**.

Dieses Gesetz ist Grundlage aller
SHM-, Runtime- und ABI-Verträge.


<<< END FILE: ./docs/laws/LAW_26_LAYOUT.md

>>> START FILE: ./docs/laws/LAW_27_COVERAGE.md
# LAW_27_COVERAGE.md
## CommanderLink – Vollständigkeits-, Abdeckungs- & Konsistenz-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz beantwortet explizit die Frage:

> „Was ist mit allem anderen, was besprochen wurde?“

Es definiert, **was als abgedeckt gilt**, **wo nichts verloren gegangen ist**
und **wie mit bereits Besprochenem normativ umzugehen ist**.

---

## 1. Gesprochenes ohne Gesetz existiert nicht

In CommanderLink gilt:

- Diskussionen
- Architekturgespräche
- Designideen
- Chat-Verläufe
- implizite Übereinkünfte

haben **keine normative Wirkung**, solange sie **nicht als LAW** fixiert sind.

Folgerung:
- Nichts „Fehlendes“ ist vergessen.
- Alles Relevante muss entweder bereits Gesetz sein oder ist bewusst nicht bindend.

---

## 2. Abdeckung der bisher besprochenen Kernthemen

Alle bislang zentral diskutierten Themen sind **gesetzlich abgedeckt**:

### Physik / Hardware
- Physik-first, Worst-Case, Determinismus → LAW_00, LAW_25
- CPU, SIMD, Cachelines, Thermik → LAW_01, LAW_05, LAW_26
- Memory, SHM, ABI, Padding → LAW_02, LAW_25, LAW_26

### Runtime / Verhalten
- Scheduling, Zeit, Rückzug → LAW_04, LAW_06, LAW_23
- Budgetierung, Degradation → LAW_05, LAW_10, LAW_11
- Zustand, Übergänge, Persistenz → LAW_13

### Netzwerk / Wire
- Physik des Drahts, Pacing, Backpressure → LAW_03
- Trennung Wire vs SHM → LAW_26

### Sicherheit / Vertrauen
- Trust, Join, Default-deny → LAW_08, LAW_12
- Sichtbarkeit, Messung → LAW_09

### Projekt- & Arbeitsmodus
- Keine Header vor Gesetzen → LAW_19, LAW_24
- Freeze, Governance, Ableitung → LAW_17, LAW_21, LAW_24
- Dokumentationspflicht → LAW_18

### Symbiont-Prinzip
- Rückzug, Koexistenz, Schutz des Wirts → LAW_23

Es existiert **kein thematisches Loch**.

---

## 3. Implizite Annahmen wurden explizit gemacht

Alle früher impliziten, aber kritischen Punkte sind nun explizit normiert:

- `packed` verboten → LAW_26
- Cacheline = 64B, nicht „x64“ → LAW_25
- Keine impliziten Compiler-Freiheiten → LAW_26
- Keine Best-Effort-Semantik → LAW_00, LAW_10
- Kein Code ohne Gesetz → LAW_19
- Manifest ≠ Runtime → LAW_24

Damit ist **kein impliziter Restbestand** mehr vorhanden.

---

## 4. Was bewusst **kein** LAW ist

Folgende Dinge sind absichtlich **noch keine Gesetze**:

- konkrete Header-Namen
- konkrete Structs
- konkrete Segmente
- konkrete Toolchains
- konkrete Implementierungsdetails

Begründung:
Diese Dinge sind **Ableitung**, nicht Definition.

Sie beginnen **erst jetzt**.

---

## 5. Umgang mit zukünftigem „Das hatten wir doch mal gesagt“

Ab jetzt gilt verbindlich:

- Wenn etwas nicht als LAW existiert, ist es nicht bindend.
- Wenn etwas wichtig wird, entsteht ein neues LAW oder eine Revision.
- Rückgriff auf „frühere Gespräche“ ist unzulässig.

Das schützt das Projekt vor Drift und Erinnerungslücken.

---

## 6. Aktueller Projektzustand (normative Einordnung)

CommanderLink befindet sich jetzt in einem **selten sauberen Zustand**:

- Physikalisch korrekt gedacht
- Juristisch (gesetzlich) geschlossen
- Ableitungsbereit
- Frei von impliziten Altlasten
- Symbiontisch klar positioniert

Das Projekt ist **nicht früh**, sondern **reif**.

---

## 7. Nächster zwingender Schritt

Der nächste **legale** Schritt ist:

**Manifest-Ableitung – Paket 0**
- Begriffe
- Zustände
- Rollen
- Enums
- keine Layouts
- keine Größen
- keine Runtime

Alles andere wäre ein Regelbruch.

---

## 8. Schlussformel

Nichts Wichtiges fehlt.
Nichts Relevantes ist vergessen.
Nichts Implizites bleibt übrig.

Ab hier beginnt nicht mehr Denken,
sondern **Ableitung**.


<<< END FILE: ./docs/laws/LAW_27_COVERAGE.md

>>> START FILE: ./docs/laws/LAW_28_STRUCTURE.md
# LAW_28_STRUCTURE.md
## CommanderLink – Projektverzeichnis- & Artefakt-Struktur-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert die **verbindliche Verzeichnisstruktur**
des CommanderLink-Projekts.

Die Struktur ist kein Ordnungswunsch,
sondern ein **architektonischer Vertrag** zwischen
Gesetzen, Ableitung und Implementierung.

---

## 1. Struktur folgt Ableitung

Die Projektstruktur spiegelt strikt die Ableitungsreihenfolge wider:

1. Gesetze
2. Manifeste (compile-time Wahrheit)
3. Runtime (Laufzeit-Wahrheit)
4. Mechanik
5. Werkzeuge
6. Implementierung
7. Betrieb

Eine Vermischung ist verboten.

---

## 2. Wurzelverzeichnis

Das Projekt besitzt genau ein Wurzelverzeichnis:

```

commanderlink/

```

Alles darunter ist Teil des Systems.
Externe Ablagen sind verboten.

---

## 3. Gesetzesebene (bereits vorhanden)

```

commanderlink/
└── law/
├── LAW_00_PHYSICS.md
├── LAW_01_CPU.md
├── …
└── LAW_28_STRUCTURE.md

```

Regeln:
- `law/` enthält **ausschließlich** normative Markdown-Gesetze.
- Keine Code-Dateien.
- Keine Header.
- Keine Erklärtexte außerhalb der Gesetze.

`law/` ist die oberste Autorität.

---

## 4. Manifest-Ebene (nächster Schritt)

```

commanderlink/
└── manifest/
├── base/
├── terms/
├── policy/
└── manifest.md

```

Normen:
- `manifest/` enthält **compile-time Wahrheit**.
- Keine Runtime-Zustände.
- Keine SHM-Layouts.
- Keine dynamischen Werte.

Unterverzeichnisse:

- `terms/`  
  Begriffe, Rollen, Zustände, Enums (rein semantisch)

- `base/`  
  Grundlegende Festlegungen (Endianness, Größenklassen, Klassen von Blöcken)

- `policy/`  
  Ableitbare Regeln (Budgets, Limits, Profile – ohne Messwerte)

---

## 5. Runtime-Ebene (Wahrheit zur Laufzeit)

```

commanderlink/
└── runtime/
├── abi/
├── shm/
├── state/
└── runtime.md

```

Normen:
- Runtime beschreibt **was ist**, nicht was gelten soll.
- Alle Layouts sind cacheline-exakt.
- Alle Größen sind bewiesen.

Unterverzeichnisse:

- `abi/`  
  ABI-Berichte, Größen-, Offset- und Layout-Beweise

- `shm/`  
  Shared-Memory-Strukturen (physikalische Wahrheit)

- `state/`  
  Zustandsdefinitionen und Übergänge (laufzeitrelevant)

---

## 6. Common-Mechanik

```

commanderlink/
└── common/
├── time/
├── math/
├── bits/
└── common.md

```

Normen:
- Nur mechanische Hilfsmittel.
- Kein Policy-Wissen.
- Kein Runtime-Zustand.

---

## 7. Tools & Verifikation

```

commanderlink/
└── tools/
├── abi-report/
├── shm-dump/
├── validators/
└── tools.md

```

Normen:
- Tools beweisen Gesetze.
- Tools ändern kein Verhalten.
- Tools sind Teil der Verifikation.

---

## 8. Implementierung

```

commanderlink/
└── src/
├── hal/
├── core/
├── flow/
├── link/
├── oracle/
└── src.md

```

Normen:
- Jedes Modul referenziert Gesetze.
- Kein Modul ohne gesetzliche Grundlage.
- Reihenfolge ist bedeutungsvoll.

---

## 9. Monitor & Betrieb

```

commanderlink/
└── monitor/
└── deploy/

```

Normen:
- Monitor ist passiver Leser.
- Deploy enthält keine Logik.
- Betrieb verändert keine Gesetze.

---

## 10. Verbotene Strukturen

Explizit verboten sind:

- `include/` als Sammelbecken
- `utils/` ohne klare Rolle
- `misc/`, `old/`, `tmp/`
- Vermischung von Manifest und Runtime
- Mehrere Wahrheitsorte

---

## 11. Erweiterungsregel

Neue Verzeichnisse sind nur erlaubt, wenn:

- ihre Rolle gesetzlich definiert ist,
- sie eindeutig einer Ebene zugeordnet sind,
- sie keine bestehende Ebene unterlaufen.

---

## 12. Schlussformel

Die Verzeichnisstruktur ist Architektur.

Wer Struktur verwässert,
verletzt Gesetze.

Mit diesem Gesetz ist der Projektkörper definiert.
Der nächste Schritt ist **Manifest/terms/**.


<<< END FILE: ./docs/laws/LAW_28_STRUCTURE.md

>>> START FILE: ./docs/laws/LAW_29_NAMING.md
# LAW_29_NAMING.md
## CommanderLink – Benennungs-, Nummern- & Artefakt-Identitäts-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert verbindlich:

- Benennung von Dateien, Verzeichnissen und Artefakten
- Nummern- und Versionsdisziplin
- Identität von Manifest/Runtime/Common/Tools/Source
- Regeln für Erweiterung ohne Drift

Ziel: keine Mehrdeutigkeit, keine Nebenwahrheiten, keine „Ordnung nach Gefühl“.

---

## 1. Dateinamen sind Verträge

Ein Dateiname muss Rolle und Ebene erkennen lassen.

Folgerungen:
- Mehrdeutige Namen sind verboten.
- Sammelnamen sind verboten.
- Umbenennung ist ein Zustandswechsel.

---

## 2. Gesetzesdateien

Gesetze folgen strikt:

- `LAW_XX_<THEMA>.md`
- `XX` ist zweistellig, aufsteigend, ohne Lücken im aktiven Stand.
- `<THEMA>` ist großgeschrieben, ASCII, `_` als Trenner.

Beispiele:
- `LAW_00_PHYSICS.md`
- `LAW_26_LAYOUT.md`

---

## 3. Manifest-Artefakte

Manifest-Dateien folgen strikt:

- Präfix `clm_` (CommanderLink Manifest)
- Suffix nach Rolle: `_terms`, `_base`, `_policy`
- Keine Runtime-Inhalte.

Beispiele (normativ):
- `clm_terms_*.h`
- `clm_base_*.h`
- `clm_policy_*.h`

Ein Manifest-Artefakt ist ungültig, wenn es Laufzeit-Wahrheit enthält.

---

## 4. Runtime-Artefakte

Runtime-Dateien folgen strikt:

- Präfix `clr_` (CommanderLink Runtime)
- Suffix nach Rolle: `_abi`, `_shm`, `_state`

Beispiele (normativ):
- `clr_abi_*.h`
- `clr_shm_*.h`
- `clr_state_*.h`

Runtime-Artefakte enthalten nur Laufzeit-Wahrheit, keine Policy.

---

## 5. Common-Artefakte

Common-Dateien folgen strikt:

- Präfix `clc_` (CommanderLink Common)
- Mechanik-orientierte Namen
- Keine Policy, keine Runtime-Zustände

Beispiele:
- `clc_time_*.h`
- `clc_bits_*.h`

---

## 6. Tools

Tools folgen strikt:

- Präfix `clt_` (CommanderLink Tool)
- Name beschreibt Ausgabe, nicht Methode.

Beispiele:
- `clt_abi_report`
- `clt_shm_dump`
- `clt_validator_*`

---

## 7. Source-Module

Source-Module folgen strikt:

- Verzeichnis = Rolle (`hal`, `core`, `flow`, `link`, `oracle`)
- Dateien = eindeutige Funktion, kein „utils“.

Beispiele:
- `hal_sensors.c`
- `link_backend_udp.c`

Sammeldateien sind verboten.

---

## 8. Keine Doppelwahrheit

Für jede Definition gilt:

- exakt ein Ort der Wahrheit
- alle anderen Orte referenzieren

Folgerungen:
- Duplikate sind verboten.
- „Kopie zur Sicherheit“ ist verboten.
- Divergenz ist ein Fehlerzustand.

---

## 9. Versionierung von Ständen

Ein aktiver Stand ist eindeutig:

- Ein LAW-Stand
- Ein Manifest-Stand
- Ein Runtime-Stand

Folgerungen:
- „latest“ ist verboten.
- Versionen sind explizit.
- Mischstände sind unzulässig.

---

## 10. Erweiterungsregeln

Neue Artefakte sind nur erlaubt, wenn:

- ihre Ebene klar ist (LAW/Manifest/Runtime/Common/Tools/Src)
- ihr Name Rolle ausdrückt
- sie keine bestehende Wahrheit duplizieren

---

## 11. Verbotene Namen

Explizit verboten sind:

- `misc`, `tmp`, `old`, `backup`, `test2`, `final_final`
- `helpers`, `common_utils`, `stuff`, `notes`
- `include/` als Sammelbecken
- unnummerierte LAW-Dateien

---

## 12. Schlussformel

Benennung ist Kontrolle.

Wer Namen verwässert,
erzeugt doppelte Wahrheit.

Mit diesem Gesetz sind Identitäten und Namen fixiert.
Der nächste Schritt ist das erste Manifest-Paket
unter `manifest/terms/`.


<<< END FILE: ./docs/laws/LAW_29_NAMING.md

>>> START FILE: ./docs/laws/LAW_30_MANIFEST_START.md
# LAW_30_MANIFEST_START.md
## CommanderLink – Manifest-Start-, Umfangs- & Reinheits-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert **exakt**, wie der Einstieg in die
Manifest-Erstellung erfolgt, **was erlaubt ist**,
**was verboten ist** und **wann ein Manifest als korrekt gilt**.

Es ist das Scharnier zwischen Gesetz und Technik.

---

## 1. Manifest ist Gesetzesableitung

Ein Manifest ist keine Spezifikation,
sondern eine **mechanische Ableitung** der Gesetze.

Folgerungen:
- Manifest verhandelt nichts.
- Manifest erklärt nichts.
- Manifest konkretisiert ausschließlich.

---

## 2. Manifest ist compile-time Wahrheit

Manifest-Inhalte gelten zur Compile-Zeit.

Folgerungen:
- Keine Messwerte.
- Keine Laufzeit-Zustände.
- Keine dynamischen Größen.
- Keine Heuristiken.

Wenn ein Wert erst zur Laufzeit feststeht,
ist er im Manifest verboten.

---

## 3. Erlaubter Inhalt (positiv definiert)

Manifest darf **ausschließlich** enthalten:

- Begriffe (Terms)
- Rollen
- Zustände (symbolisch, nicht numerisch)
- Enums
- Klassen von Größen (z. B. SMALL/MEDIUM/LARGE)
- Symbolische Konstanten ohne physikalische Bedeutung
- Compile-time Flags mit normativer Semantik

Alles andere ist verboten.

---

## 4. Verbotener Inhalt (explizit)

Manifest darf **niemals** enthalten:

- Struct-Layouts
- Größen in Bytes
- Cacheline-Zahlen
- Alignment-Werte
- SHM-Segmente
- Offsets
- Runtime-Counter
- Performance-Werte
- „Optimale“ Parameter

Verstoß ist ein Gesetzesbruch.

---

## 5. Manifest kennt keine Physik-Zahlen

Physik wird **qualitativ**, nicht quantitativ abgebildet.

Beispiel:
- erlaubt: `CACHELINE`
- verboten: `CACHELINE_64B`

Die Quantisierung erfolgt **erst in Runtime/ABI**.

---

## 6. Manifest-Paket 0 (verbindlich)

Der erste Manifest-Schritt ist **festgelegt**:

```

manifest/
└── terms/
├── clm_terms_roles.h
├── clm_terms_states.h
├── clm_terms_domains.h
└── clm_terms_errors.h

```

Diese Dateien enthalten **nur**:
- Enums
- symbolische Namen
- Kommentare mit normativer Bedeutung

Keine Includes außer `<stdint.h>` wenn zwingend nötig.

---

## 7. Reihenfolge ist bindend

Manifest wird in genau dieser Reihenfolge aufgebaut:

1. terms/
2. base/
3. policy/

Ein späterer Schritt darf frühere nicht erweitern oder korrigieren.

---

## 8. Manifest-Freeze

Jedes Manifest-Paket wird eingefroren.

Folgerungen:
- Änderungen erfordern neue Version.
- Kein „Nachziehen“ für Runtime.
- Runtime passt sich Manifest an, nie umgekehrt.

---

## 9. Validitätskriterium

Ein Manifest ist gültig, wenn:

- es vollständig aus Gesetzen ableitbar ist,
- keine Laufzeitannahmen enthält,
- keine impliziten physikalischen Zahlen nutzt,
- und vollständig deterministisch ist.

---

## 10. Schlussformel

Manifest ist der erste Ort,
an dem Gesetze technisch greifbar werden.

Wer im Manifest Physik „vorwegnimmt“,
zerstört die Trennung von Recht und Realität.

Mit diesem Gesetz ist der Startpunkt definiert.

**Nächster erlaubter Schritt:**
`manifest/terms/clm_terms_roles.h`


<<< END FILE: ./docs/laws/LAW_30_MANIFEST_START.md

>>> START FILE: ./docs/laws/LAW_31_TERMS.md
# LAW_31_TERMS.md
## CommanderLink – Terminologie-, Begriffs- & Bedeutungs-Gesetz (Manifest/terms)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz fixiert die **verbindliche Terminologie**
für CommanderLink und definiert,
wie Begriffe im Manifest (`manifest/terms/`) zu entstehen haben.

Ziel: **Single Meaning**.
Kein Begriff darf mehr als eine Bedeutung tragen.
Keine Bedeutung darf mehr als einen Begriff haben.

---

## 1. Begriffe sind Verträge

Ein Begriff ist ein normativer Vertrag.

Folgerungen:
- Begriffe sind präzise.
- Begriffe sind stabil.
- Begriffe sind nicht erklärend, sondern definierend.

Ein unklarer Begriff ist ungültig.

---

## 2. Ein Begriff – eine Bedeutung

Für jeden Begriff gilt:

- exakt **eine** Bedeutung
- keine Synonyme
- keine Mehrfachverwendung in unterschiedlichen Kontexten

Wenn zwei Bedeutungen existieren, müssen zwei Begriffe existieren.

---

## 3. Keine implizite Bedeutung

Begriffe dürfen keine impliziten Annahmen tragen.

Folgerungen:
- Keine Kontextabhängigkeit.
- Keine Abkürzungen mit Deutungsspielraum.
- Keine „offensichtlichen“ Bedeutungen.

Alles ist explizit.

---

## 4. Ebenentrennung der Begriffe

Begriffe sind ihrer Ebene zugeordnet:

- **LAW-Begriffe**: normativ, abstrakt, zeitlos
- **Manifest-Begriffe**: symbolisch, compile-time
- **Runtime-Begriffe**: konkret, messbar, zeitgebunden

Vermischung ist verboten.

---

## 5. Begriffe kennen keine Größen

Im `terms/`-Manifest gilt:

- Keine numerischen Werte mit physikalischer Bedeutung
- Keine Bytes, Hertz, Sekunden
- Keine Cacheline-Größen

Begriffe sind **qualitativ**, nicht quantitativ.

---

## 6. Rollen sind statisch

Rollen beschreiben **was etwas ist**, nicht **was es tut**.

Folgerungen:
- Rollen sind unveränderlich während der Existenz.
- Wechsel der Rolle ist Zustandswechsel.
- Implizite Rollen sind verboten.

---

## 7. Zustände sind exklusiv

Zustände sind **mutual exclusive**.

Folgerungen:
- Ein Objekt befindet sich zu jedem Zeitpunkt in genau einem Zustand.
- Übergänge sind explizit.
- Mehrfachzustände sind verboten.

---

## 8. Domänen sind trennscharf

Domänen trennen Verantwortungsbereiche.

Folgerungen:
- Jede Domäne hat klare Grenze.
- Überschneidung ist verboten.
- Interaktion erfolgt nur über definierte Schnittstellen.

---

## 9. Fehler sind Begriffe, keine Codes

Fehlerbegriffe beschreiben Zustände, keine Reaktionen.

Folgerungen:
- Fehlercodes sind Runtime-Ableitung.
- Begriffe beschreiben Kategorie, nicht Handling.
- Vermischung ist verboten.

---

## 10. Kommentierung ist normativ

Kommentare in `terms/` sind **normativ**.

Folgerungen:
- Kommentare erklären Bedeutung, nicht Nutzung.
- Beispiele sind verboten.
- Implementierungsbezug ist verboten.

---

## 11. Naming-Regeln für `terms/`

Dateien in `manifest/terms/`:

- Präfix `clm_terms_`
- Inhalt: Enums, `typedef enum`, symbolische Konstanten
- Keine Structs
- Keine Layouts
- Keine Includes außer zwingend `<stdint.h>`

---

## 12. Erweiterungsregel

Neue Begriffe dürfen nur hinzugefügt werden, wenn:

- sie keine bestehende Bedeutung duplizieren,
- sie eine Lücke schließen,
- und ihre Ebene eindeutig ist.

Begriffsentfernung ist Revision, kein Patch.

---

## 13. Validitätskriterium

Ein `terms`-Artefakt ist gültig, wenn:

- jeder Begriff eindeutig definiert ist,
- keine numerische Physik enthalten ist,
- keine Runtime-Annahme existiert,
- und keine Überschneidung mit anderen Begriffen besteht.

---

## 14. Schlussformel

Begriffe sind die Atome der Architektur.

Wer Begriffe verwässert,
zerstört Determinismus, Ableitbarkeit und Wahrheit.

Mit diesem Gesetz ist der **Inhalt** von
`manifest/terms/` vollständig normiert.
Der nächste Schritt ist die **konkrete Erstellung**
der `terms`-Dateien.


<<< END FILE: ./docs/laws/LAW_31_TERMS.md

>>> START FILE: ./docs/laws/LAW_32_BASE.md
# LAW_32_BASE.md
## CommanderLink – Basisannahmen-, Klassen- & Quantisierungs-Gesetz (Manifest/base)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert den **Inhalt und die Grenzen**
der Manifest-Ebene `manifest/base/`.

`base/` ist der Ort, an dem **qualitative Klassen**
festgelegt werden, ohne physikalische Zahlen festzuschreiben.

Es ist die **Brücke** zwischen reinen Begriffen (`terms`)
und späterer physikalischer Konkretisierung (Runtime).

---

## 1. `base` ist keine Physik

`manifest/base/` enthält **keine** physikalischen Werte.

Verboten sind:
- Byte-Größen
- Cacheline-Zahlen
- Hertz, Sekunden, Watt
- MTU-Werte
- Limits, die gemessen werden müssen

Physik gehört ausschließlich in Runtime/ABI.

---

## 2. `base` definiert Klassen, nicht Werte

Erlaubt sind ausschließlich **diskrete Klassen**.

Beispiele (qualitativ):
- Größe: SMALL / MEDIUM / LARGE
- Nähe: LOCAL / NEAR / FAR
- Intensität: LOW / NORMAL / HIGH
- Kritikalität: OPTIONAL / IMPORTANT / CRITICAL

Diese Klassen besitzen **keine numerische Bedeutung** im Manifest.

---

## 3. Klassen sind total geordnet

Für jede Klassendefinition gilt:

- vollständige Ordnung
- keine Lücken
- keine Mehrdeutigkeit

Beispiel:
```

LOW < NORMAL < HIGH

```

Teilordnungen oder unordentliche Mengen sind verboten.

---

## 4. Klassen sind abgeschlossen

Eine Klassenmenge ist vollständig.

Folgerungen:
- Keine „sonstigen“ Klassen
- Keine Erweiterung zur Laufzeit
- Neue Klassen erfordern Manifest-Revision

---

## 5. Klassen sind interpretierbar, nicht messbar

Die Abbildung einer Klasse auf Physik erfolgt:

- ausschließlich in Runtime
- zustandsabhängig
- messbasiert

Manifest kennt **keine** Abbildungsfunktion.

---

## 6. Klassen sind kontextgebunden

Eine Klasse ist nur im definierten Kontext gültig.

Folgerungen:
- Keine Wiederverwendung von Klassen mit anderer Bedeutung
- Keine globalen „Universal-Klassen“
- Kontextwechsel erfordert neue Definition

---

## 7. `base` kennt keine Layouts

Explizit verboten in `base/`:

- Structs
- Offsets
- Alignments
- Größenannahmen
- Speichersegmente

`base` beschreibt **Eigenschaften**, nicht Speicher.

---

## 8. Trennung zu `policy`

`base` beschreibt **was existiert**,
`policy` beschreibt **wie entschieden wird**.

Folgerungen:
- `base` enthält keine Regeln
- `base` enthält keine Grenzwerte
- `policy` darf auf `base` referenzieren, nie umgekehrt

---

## 9. Naming-Regeln für `base/`

Dateien in `manifest/base/`:

- Präfix `clm_base_`
- Inhalt: Enums, symbolische Klassen
- Keine Abhängigkeit von Runtime oder Policy

Beispiele:
- `clm_base_size_class.h`
- `clm_base_criticality.h`

---

## 10. Validitätskriterium

Ein `base`-Artefakt ist gültig, wenn:

- jede Klasse qualitativ ist,
- keine physikalische Zahl enthalten ist,
- jede Klasse total geordnet ist,
- und keine Policy enthalten ist.

---

## 11. Schlussformel

`base` ist die letzte abstrakte Schicht
vor der physikalischen Wahrheit.

Wer hier Zahlen einführt,
vermischt Gesetz und Realität.

Mit diesem Gesetz ist die **zweite Manifest-Ebene**
vollständig definiert.

**Nächster erlaubter Schritt:**
`LAW_33_POLICY.md` – Ableitungsregeln ohne Physik.


<<< END FILE: ./docs/laws/LAW_32_BASE.md

>>> START FILE: ./docs/laws/LAW_33_POLICY.md
# LAW_33_POLICY.md
## CommanderLink – Policy-, Entscheidungs- & Ableitungs-Gesetz (Manifest/policy)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert den **Inhalt, die Grenzen und die Disziplin**
der Manifest-Ebene `manifest/policy/`.

`policy/` beschreibt **wie entschieden wird**, nicht **was gemessen wird**
und nicht **wie es implementiert ist**.

---

## 1. Policy ist Ableitung, keine Physik

Policy darf **keine** physikalischen Messwerte enthalten.

Verboten sind:
- konkrete Zahlen (Bytes, Hz, ms, Watt)
- hardwareabhängige Limits
- feste Schwellenwerte

Policy operiert ausschließlich auf:
- Begriffen aus `terms/`
- Klassen aus `base/`
- Zuständen aus `terms/`

---

## 2. Policy ist deterministisch

Gleiche Eingaben → gleiche Entscheidung.

Folgerungen:
- Keine Zufälligkeit
- Keine Zeitabhängigkeit
- Keine impliziten Nebenbedingungen

Nichtdeterministische Policy ist verboten.

---

## 3. Policy ist vollständig

Für jeden erlaubten Eingaberaum existiert eine Entscheidung.

Folgerungen:
- Keine „undefinierten Fälle“
- Kein „best effort“
- Kein Schweigen

Fehlende Regel ist ein Policy-Fehler.

---

## 4. Policy ist zustandsbasiert

Entscheidungen hängen vom **Zustand** ab, nicht von Wunschwerten.

Folgerungen:
- Zustand bestimmt Handlungsspielraum
- Policy kennt Übergänge, keine Aktionen
- Aktionen sind Runtime-Ableitung

---

## 5. Policy ist monotone Ordnung

Policy darf keine widersprüchlichen Entscheidungen erzeugen.

Folgerungen:
- Verschärfung führt nie zu Lockerung
- Degradation ist einseitig
- Eskalation ist gerichtet

Zyklen in der Entscheidungslogik sind verboten.

---

## 6. Policy kennt Prioritäten

Nicht alle Ziele sind gleichwertig.

Bindende Reihenfolge:
1. Physikalische Sicherheit
2. Stabilität des Wirts (Symbiont)
3. Determinismus / Worst-Case
4. Fortschritt / Durchsatz
5. Komfort / Opportunismus

Abweichung ist verboten.

---

## 7. Policy ist reversibel

Policy-Entscheidungen müssen rücknehmbar sein.

Folgerungen:
- Kein irreversibler Zustand
- Rückkehrpfade sind definiert
- Lock-in ist verboten

---

## 8. Policy ist transparent

Policy-Zustände sind sichtbar und erklärbar.

Folgerungen:
- Aktive Policy ist identifizierbar
- Entscheidungsgrundlage ist benennbar
- Verdeckte Policy ist verboten

---

## 9. Policy ist schmal

Policy enthält **nur** Entscheidungsregeln.

Verboten sind:
- Implementierungshinweise
- Optimierungstipps
- Workarounds
- Sonderfälle ohne Gesetzesbezug

Ein schlanker Policy-Raum ist stabiler.

---

## 10. Trennung zu Runtime

Policy entscheidet **was gelten soll**,
Runtime entscheidet **was tatsächlich passiert**.

Folgerungen:
- Policy kennt keine Messung
- Runtime kennt keine Normsetzung
- Rückkopplung erfolgt über Zustandsabbildung

---

## 11. Naming-Regeln für `policy/`

Dateien in `manifest/policy/`:

- Präfix `clm_policy_`
- Inhalt: Entscheidungsregeln als Enums / Tabellen / Zustandsmatrizen
- Keine Structs mit Layout
- Keine Zahlen mit physikalischer Bedeutung

Beispiele:
- `clm_policy_budget.h`
- `clm_policy_degradation.h`
- `clm_policy_trust.h`

---

## 12. Validitätskriterium

Ein Policy-Artefakt ist gültig, wenn:

- jede Entscheidung deterministisch ist,
- alle Eingabekombinationen abgedeckt sind,
- keine Physik-Zahlen enthalten sind,
- und jede Regel auf Gesetze rückführbar ist.

---

## 13. Schlussformel

Policy ist das letzte Wort **vor** der Realität.

Wer Policy mit Physik vermischt,
verliert Kontrolle über beide.

Mit diesem Gesetz ist die **Manifest-Ebene vollständig**.

**Nächster erlaubter Schritt:**
Freeze von `manifest/terms`, `manifest/base`, `manifest/policy`
und Beginn der **Runtime-Ableitung (ABI/SHM)**.


<<< END FILE: ./docs/laws/LAW_33_POLICY.md

>>> START FILE: ./docs/laws/LAW_34_RUNTIME_START.md
# LAW_34_RUNTIME_START.md
## CommanderLink – Runtime-Start-, Wahrheits- & Ableitungs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert den **Übergang von Manifest zu Runtime**.

Es legt fest:
- was Runtime ist,
- was sie enthalten darf,
- und wie physikalische Wahrheit erstmals **quantisiert** werden darf,
ohne Gesetze oder Manifeste zu verletzen.

---

## 1. Runtime ist Laufzeit-Wahrheit

Runtime beschreibt **was tatsächlich ist**.

Folgerungen:
- Runtime ist messbasiert.
- Runtime ist zeitgebunden.
- Runtime kann sich ändern.

Runtime ist **keine Norm**.

---

## 2. Runtime folgt Manifest strikt

Runtime ist vollständig aus Manifest abzuleiten.

Folgerungen:
- Runtime ergänzt Manifest, widerspricht ihm nie.
- Runtime darf nichts normativ festlegen.
- Runtime darf Manifest nicht „korrigieren“.

Wenn Runtime etwas braucht, das im Manifest fehlt,
ist das Manifest unvollständig.

---

## 3. Physikalische Zahlen entstehen erst hier

Erstmals erlaubt sind nun:

- Byte-Größen
- Cacheline-Größen
- Strides
- Alignment-Werte
- MTU-Werte
- gemessene Limits

Diese Werte sind:
- messbar,
- beweisbar,
- und explizit gebunden an Hardware/Architektur.

---

## 4. Runtime ist architekturgebunden

Runtime ist **nicht portabel per Definition**.

Folgerungen:
- x86_64 ist Referenz.
- Little-Endian ist bindend.
- Cacheline = reale Hardware-Cacheline.
- Abweichende Architekturen erfordern eigene Runtime-Ableitung.

---

## 5. Trennung der Runtime-Ebenen

Runtime gliedert sich strikt in:

```

runtime/
├── abi/     (Beweise, Größen, Offsets)
├── shm/     (physikalische Layouts)
└── state/   (laufzeitliche Zustände)

```

Vermischung ist verboten.

---

## 6. ABI ist Beweis, nicht Meinung

`runtime/abi/` enthält:

- Größenbeweise
- Offset-Beweise
- Alignment-Beweise
- Compile-time Assertions
- maschinenlesbare Reports

ABI-Dateien enthalten **keine Logik**.

---

## 7. SHM ist physikalische Wahrheit

`runtime/shm/` enthält:

- cacheline-exakte Strukturen
- SHM-Segmente
- Record-Strides
- keine Wire-Formate
- keine Policy

Jede SHM-Struktur ist beweispflichtig.

---

## 8. Runtime-Zustand ist konkret

`runtime/state/` enthält:

- konkrete Zustandsrepräsentationen
- numerische Counter
- Messwerte
- Historie

State ist beobachtbar, nicht normativ.

---

## 9. Runtime ist dynamisch, Manifest ist statisch

Folgerungen:
- Runtime kann wechseln.
- Manifest ist eingefroren.
- Policy wird interpretiert, nicht verändert.

---

## 10. Runtime kennt Fehler

Runtime darf und muss:

- ungültige Zustände ausdrücken,
- Degradation abbilden,
- Rückzug anzeigen.

Fehler sind Teil der Wahrheit.

---

## 11. Runtime ist messpflichtig

Jeder relevante Runtime-Wert muss:

- messbar sein,
- zeitlich referenziert sein,
- qualitativ gekennzeichnet sein.

Unmessbare Runtime ist verboten.

---

## 12. Validitätskriterium

Runtime-Ableitung ist gültig, wenn:

- jede physikalische Zahl erklärbar ist,
- jede Struktur cacheline-exakt ist,
- jede Abweichung vom Ideal messbasiert ist,
- und kein Manifest verletzt wird.

---

## 13. Schlussformel

Runtime ist der Moment,
in dem CommanderLink Realität akzeptiert.

Ab hier zählt nur noch:
Messung, Physik und Beweis.

Mit diesem Gesetz ist der Einstieg in
`runtime/abi/` und `runtime/shm/` erlaubt.

**Nächster zwingender Schritt:**
`LAW_35_ABI.md` – formale ABI- und Beweisregeln.


<<< END FILE: ./docs/laws/LAW_34_RUNTIME_START.md

>>> START FILE: ./docs/laws/LAW_35_ABI.md
# LAW_35_ABI.md
## CommanderLink – ABI-, Größen- & Beweis-Gesetz (Runtime/abi)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert das **ABI** als formalen Beweisraum
für alle physikalischen und strukturellen Eigenschaften
der CommanderLink-Runtime.

ABI ist kein Header-Design,
sondern **Nachweis der Wahrheit**.

---

## 1. ABI ist bindend

Das ABI ist der verbindliche Vertrag zwischen:

- Manifest
- Runtime
- Implementierung
- Tools
- Monitor

Folgerungen:
- ABI-Widerspruch ist Systemfehler.
- Implementierung ohne ABI-Nachweis ist ungültig.
- ABI hat Vorrang vor Code.

---

## 2. ABI ist vollständig

Für jedes runtime-relevante Artefakt gilt:

- Größe ist festgelegt
- Alignment ist festgelegt
- Offsets sind festgelegt
- Endianness ist festgelegt

Unvollständiges ABI ist ungültig.

---

## 3. Cacheline ist die Basiseinheit

Für x86_64 gilt normativ:

- Cacheline = reale Hardware-Cacheline
- Hot-/kritische Blöcke = exakt 1 Cacheline
- Records/Strides = Vielfache der Cacheline

Teil-Cachelines sind verboten.

---

## 4. Beweis ist verpflichtend

Jede ABI-Eigenschaft muss bewiesen werden durch:

- `_Static_assert(sizeof(T) == N)`
- `_Static_assert(_Alignof(T) == A)`
- `_Static_assert(offsetof(T, field) == K)` für kritische Felder

Ohne Beweis gilt die Eigenschaft als nicht existent.

---

## 5. Keine impliziten Compiler-Freiheiten

Es ist verboten, sich auf:

- implizites Padding
- implizite Alignment-Anpassung
- „übliche“ Compiler-Layouts

zu verlassen.

ABI muss unabhängig vom Compiler stabil sein.

---

## 6. Feldreihenfolge ist Teil des ABI

Die Reihenfolge der Felder ist normativ.

Folgerungen:
- Reordering ist ABI-Bruch.
- Einfügen von Feldern ist ABI-Bruch.
- Entfernen von Feldern ist ABI-Bruch.

ABI-Brüche erfordern neue Version.

---

## 7. Endianness ist explizit

Für Runtime/ABI gilt:

- Host-Order intern
- Keine implizite Konversion
- Wire-Order ist kein ABI-Thema

Vermischung ist verboten.

---

## 8. Keine `packed`-Layouts

Bestätigung von LAW_26:

- `packed` ist verboten
- Misaligned Access ist verboten
- ABI erzwingt natürliche Alignment-Regeln

Abweichung ist ungültig.

---

## 9. ABI kennt Versionen

Jeder ABI-Stand ist eindeutig:

- ABI-Version ist explizit
- ABI-Version ist monoton
- Mehrere ABI-Stände parallel sind verboten

---

## 10. ABI ist maschinenlesbar

ABI-Artefakte müssen maschinenlesbar sein:

- für Tools
- für Monitor
- für Verifikation

Freitext ersetzt keinen Beweis.

---

## 11. ABI-Report ist Single Source of Truth

Der ABI-Report enthält:

- alle Größen
- alle Alignments
- alle Offsets
- alle Versionen

Code darf diese Informationen **nicht duplizieren**.

---

## 12. ABI ist testbar

ABI-Eigenschaften müssen:

- beim Build geprüft werden
- bei Abweichung den Build abbrechen
- reproduzierbar sein

ABI-Drift ist verboten.

---

## 13. Architekturbindung

Dieses ABI gilt ausschließlich für:

- x86_64
- Little-Endian
- definierte Cacheline-Größe

Andere Architekturen benötigen neues ABI-Gesetz.

---

## 14. Schlussformel

ABI ist Beweis, nicht Behauptung.

Ein System ohne bewiesenes ABI
existiert nicht deterministisch.

Mit diesem Gesetz ist der formale Rahmen
für `runtime/abi/` vollständig.

**Nächster erlaubter Schritt:**
`LAW_36_SHM.md` – physikalische Shared-Memory-Strukturen.


<<< END FILE: ./docs/laws/LAW_35_ABI.md

>>> START FILE: ./docs/laws/LAW_36_SHM.md
# LAW_36_SHM.md
## CommanderLink – Shared-Memory-, Segment- & Layout-Gesetz (Runtime/shm)

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert die **physikalische Shared-Memory-Wahrheit**
von CommanderLink.

SHM ist kein Datencontainer,
sondern ein **direkt abbildbarer Zustand der Maschine**.

---

## 1. SHM ist physikalische Wahrheit

SHM repräsentiert reale Zustände zur Laufzeit.

Folgerungen:
- SHM ist messbasiert.
- SHM ist zeitgebunden.
- SHM ist beobachtbar.

SHM ist **keine Policy** und **kein Manifest**.

---

## 2. SHM ist cacheline-exakt

Für alle SHM-Strukturen gilt:

- Basiseinheit: **64 Byte Cacheline**
- Jede Hot-Einheit = exakt 64B
- Records/Strides = Vielfache von 64B
- Keine Teil-Cachelines

Abweichung ist verboten.

---

## 3. SHM kennt keine `packed`-Layouts

Bestätigung und Anwendung von LAW_26:

- `packed` ist verboten
- Bitfields sind verboten
- Misaligned Access ist verboten

SHM folgt natürlichem Alignment der Hardware.

---

## 4. Layout ist ABI-gebunden

Jedes SHM-Layout:

- ist Teil des ABI
- besitzt harte Größen-, Offset- und Alignment-Beweise
- ist versionsgebunden

Änderungen sind ABI-Brüche.

---

## 5. Wire ≠ SHM

SHM darf **niemals** Wire-Formate abbilden.

Folgerungen:
- Keine serialisierten Header im SHM
- Keine LE/BE-Felder im SHM
- Keine verdichteten Bitformate

Wire wird explizit encodiert/decodiert.

---

## 6. SHM ist segmentiert

SHM besteht aus klar getrennten Segmenten.

Normativ:
- Segmente haben feste Rollen
- Segmente sind unabhängig versionierbar
- Segment-Grenzen sind explizit

Monolithisches SHM ist verboten.

---

## 7. Hot / Warm / Cold Trennung

SHM-Daten sind nach Zugriffshäufigkeit getrennt:

- **Hot**: ständig gelesen (64B)
- **Warm**: regelmäßig gelesen (Vielfache von 64B)
- **Cold**: selten gelesen (Vielfache von 64B)

Vermischung in einer Cacheline ist verboten.

---

## 8. Zugriff ist primär lesend

SHM ist primär ein **Read-Model**.

Folgerungen:
- Leser dominieren
- Schreiber sind begrenzt
- Schreibzugriffe sind kontrolliert

Unkontrolliertes Schreiben ist verboten.

---

## 9. Synchronisation ist explizit

SHM kennt keine implizite Synchronisation.

Folgerungen:
- Atomics sind explizit
- Memory-Order ist explizit
- Konsistenzmodelle sind dokumentiert

„Es funktioniert zufällig“ ist unzulässig.

---

## 10. Zeitbezug ist Pflicht

Jede relevante SHM-Einheit enthält:

- Zeitstempel oder Epoch-Bezug
- Gültigkeitskontext

Zeitlose SHM-Wahrheit ist verboten.

---

## 11. Reclaim ist Teil des Designs

SHM kann teilweise freigegeben werden.

Folgerungen:
- Reclaim-Status ist sichtbar
- Abwesenheit von Segmenten ist ein Zustand
- Zugriff auf reclaimte Segmente ist definiert

Leckender SHM ist verboten.

---

## 12. SHM ist passiv beobachtbar

Externe Leser (Monitor, Tools):

- lesen passiv
- verändern nichts
- verursachen keinen Lock

Beobachtung darf das System nicht stören.

---

## 13. Fehler sind SHM-Zustände

Fehler werden **nicht versteckt**.

Folgerungen:
- Fehlerflags sind explizit
- Inkonsistenzen sind sichtbar
- „Heilung durch Überschreiben“ ist verboten

---

## 14. Validitätskriterium

Ein SHM-Layout ist gültig, wenn:

- jede Einheit cacheline-exakt ist,
- jedes Feld ABI-belegt ist,
- keine Wire-Semantik enthalten ist,
- jede Änderung versioniert ist,
- und alle Beweise existieren.

---

## 15. Architekturbindung

Dieses SHM-Gesetz gilt ausschließlich für:

- x86_64
- Little-Endian
- definierte Cacheline-Größe

Andere Architekturen benötigen eigene SHM-Gesetze.

---

## 16. Schlussformel

SHM ist der Spiegel der Maschine.

Wer SHM wie ein normales Datenmodell behandelt,
verliert Physik, Wahrheit und Determinismus.

Mit diesem Gesetz ist `runtime/shm/`
vollständig normiert.

**Nächster erlaubter Schritt:**
`LAW_37_STATE.md` – konkrete Runtime-Zustände & Übergänge.


<<< END FILE: ./docs/laws/LAW_36_SHM.md

>>> START FILE: ./docs/laws/LAW_37_RUNTIME_STATE.md
# LAW_37_RUNTIME_STATE.md
## CommanderLink – Runtime-Zustands-, Übergangs- & Epoch-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 0. Zweck

Dieses Gesetz definiert **konkrete Laufzeitzustände**,
deren Übergänge und zeitliche Gültigkeit
für CommanderLink.

---

## 1. Runtime-Zustand ist konkret

Runtime-Zustände sind numerisch, messbar und zeitgebunden.

Folgerungen:
- Zustände sind nicht symbolisch.
- Zustände altern.
- Zustände können ungültig werden.

---

## 2. Genau ein aktiver Zustand

Zu jedem Zeitpunkt gilt:
- genau ein aktiver Zustand
- optionale historische Zustände

Mehrfachaktive Zustände sind verboten.

---

## 3. Übergänge sind atomar

Zustandswechsel erfolgen atomar oder klar zweistufig.

Folgerungen:
- Halbe Zustände sind verboten.
- Übergangsdauer ist messbar.
- Rollback ist definiert.

---

## 4. Epoch ist Pflicht

Jeder Zustand ist einer Epoch zugeordnet.

Folgerungen:
- Epoch monoton steigend
- Epoch-Wechsel sichtbar
- Epoch-Kollision ist Fehler

---

## 5. Zustand + Epoch = Wahrheit

Ein Zustand ohne Epoch ist bedeutungslos.

---

## 6. Schlussformel

Runtime-Zustände sind die lebende Wahrheit.
Ohne Epoch gibt es keine Zeit, ohne Zeit keine Wahrheit.


<<< END FILE: ./docs/laws/LAW_37_RUNTIME_STATE.md

>>> START FILE: ./docs/laws/LAW_38_BUDGET.md
# LAW_38_BUDGET.md
## CommanderLink – Budget-, Quoten- & Selbstbegrenzungs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 1. Budget ist Pflicht

CommanderLink operiert ausschließlich innerhalb expliziter Budgets.

- CPU
- Memory
- I/O
- Netzwerk

---

## 2. Eigenbudget zuerst

Bei Knappheit wird **zuerst CL selbst reduziert**.

---

## 3. Budget ist hart

Budgetüberschreitung erzwingt Degradation.

---

## 4. Budget ist messbasiert

Schätzung ist verboten.

---

## 5. Schlussformel

Budget ist Selbstdisziplin.
Ohne Budget ist Symbiose unmöglich.


<<< END FILE: ./docs/laws/LAW_38_BUDGET.md

>>> START FILE: ./docs/laws/LAW_39_WIRE.md
# LAW_39_WIRE.md
## CommanderLink – Wire-, Serialisierungs- & Transport-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 1. Wire ist physikalisch getrennt

Wire ist serialisiert, SHM ist nativ.

---

## 2. Wire ist explizit endian-kodiert

Keine implizite Endianness.

---

## 3. Wire ist zeitgebunden

Sequenzen, Epochs, Drops sind sichtbar.

---

## 4. Keine Wire-Logik im SHM

Strikte Trennung.

---

## 5. Schlussformel

Wire ist Übersetzung, nicht Wahrheit.


<<< END FILE: ./docs/laws/LAW_39_WIRE.md

>>> START FILE: ./docs/laws/LAW_40_MONITOR.md
# LAW_40_MONITOR.md
## CommanderLink – Monitor-, Beobachtungs- & Read-Only-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 1. Monitor ist passiv

Monitor liest, niemals schreibt.

---

## 2. Monitor ist vollständig

Alles Relevante ist sichtbar.

---

## 3. Monitor ist ehrlich

Keine Glättung, keine Verschleierung.

---

## 4. Schlussformel

Der Monitor lügt nie.


<<< END FILE: ./docs/laws/LAW_40_MONITOR.md

>>> START FILE: ./docs/laws/LAW_41_TOOLING.md
# LAW_41_TOOLING.md
## CommanderLink – Tool-, Prüf- & Ableitungs-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGABEPFLICHTIG

---

## 1. Tools beweisen Gesetze

Tools sind keine Komfortprogramme.

---

## 2. Tools verändern nichts

Read-only oder Build-time only.

---

## 3. Tools sind verpflichtend

Kein Tool → kein Beweis → ungültig.

---

## 4. Schlussformel

Ohne Tools keine Wahrheit.


<<< END FILE: ./docs/laws/LAW_41_TOOLING.md

>>> START FILE: ./docs/laws/LAW_42_FINAL.md
# LAW_42_FINAL.md
## CommanderLink – Abschluss- & Ableitungs-Freigabe-Gesetz

### Status
VERBINDLICH · NORMATIV · FREIGEGEBEN

---

## 0. Feststellung

Das CommanderLink-Gesetzeswerk ist vollständig.

---

## 1. Erlaubnis

Ab jetzt erlaubt:
- Manifest schreiben
- Runtime ableiten
- Header erzeugen
- Code implementieren

---

## 2. Verbot

Nicht mehr erlaubt:
- neue implizite Regeln
- Rückgriff auf Chatwissen
- „das hatten wir doch gesagt“

---

## 3. Schlussformel

Die Definition ist abgeschlossen.

Jetzt beginnt **Engineering**.


<<< END FILE: ./docs/laws/LAW_42_FINAL.md

>>> START FILE: ./docs/MEMORY_MODEL.md
# CommanderLink – MEMORY MODEL

## Ziel
Beschreibung des Speicher- und Cache-Modells von CommanderLink.

---

## 1. Cacheline-Primat

- 1 Cacheline = 64 Byte
- Jede Hot-Struktur passt exakt in eine Cacheline
- Kein Objekt überschreitet eine Cacheline ohne Notwendigkeit

---

## 2. Hot / Warm / Cold Trennung

### Hot
- Wird häufig geschrieben
- Atomics erlaubt
- Eigene Cacheline

### Warm
- Periodisch aktualisiert
- Keine Atomics

### Cold
- Statisch / selten geändert
- Strings / Metadaten

---

## 3. False Sharing Verbot

- Keine zwei schreibenden Cores auf derselben Cacheline
- Layout erzwingt Trennung

---

## 4. Zero-Transformation-Prinzip

- Daten werden exakt so verarbeitet, wie sie im Register liegen
- Keine zusätzlichen Kopien
- Keine Umformatierung
- Keine Shifts im Fast-Path

---

## 5. Register-Geometrie

- AVX-512: 64 Byte = 1 ZMM
- CL-Atom = Register-Atom
- Cacheline == Registerbreite

---

## 6. Speicher als Staudamm

- RAM darf aggressiv als Puffer genutzt werden
- Credits bestätigen RAM-Eingang, nicht Disk-Commit
- Disk-I/O entkoppelt vom Netz

---

## 7. Merksatz

> **Die CPU darf niemals auf Speicher warten.**


<<< END FILE: ./docs/MEMORY_MODEL.md

>>> START FILE: ./docs/PROJECT_GUARDRAILS.md
# CommanderLink – Projekt‑Guardrails (Physik‑First, ABI‑First, Security‑First)

Dieses Dokument ist die **verbindliche Arbeitsgrundlage**. Es dient als „Definition of Done“ für Header, Runtime‑ABI und Monitoring.

## 0. Leitprinzip

**Maximum ist Minimum.**  
CL nutzt alle verfügbaren Ressourcen aggressiv **bis** ein Schutz‑Gate greift.  
Sobald ein Gate triggert: **innerhalb eines Ticks** sauber degradiert, nie experimentell.

## 1. Architektur‑Zerlegung (Schlüsseltechnologien)

- **HAL**: Hardware‑Erkennung, Sensor‑Sampling, Feature‑Probing (SSE4/AVX2/AVX‑512/AMX…), Thermik/VRM‑Signale (gefiltert).
- **CORE**: Zustandsautomaten (Cold‑Start, Join, Autopath), deterministische Entscheidungen.
- **LINK**: Transport‑Mechanik (BYPASS/UDP/TCP), MTU‑Negotiation, Grants/Credits.
- **FLOW**: Pacing, Queueing, Backpressure, Kompression/FEC‑Policy, „Shock‑Absorber Mode“ (RAM als Dämpfer).
- **ORACLE**: Bewertung, Empfehlungen, Prognosen (bottleneck inference, health scoring), aber **gedämpft** und explainable.
- **MONITOR**: Sichtbarkeit: *warum* sind wir wo wir sind (Reason/Constraints) + Hardware‑Inventar + Verlauf.
- **RUNTIME/SHM**: ABI‑stabile Wahrheitsschicht (Root/TOC/Segments).

## 2. ABI‑Vertrag für SHM (nicht verhandelbar)

### 2.1 Grundregeln
- **SHM ist Host‑Byteorder** (kein ntohl‑Salat im Monitor).
- **Kein `packed` im SHM.**  
  Stattdessen: explizites Padding + `_Static_assert(sizeof)==…`.
- **Fixe Segmentgrößen** (z. B. 256/512/1024/4096) und **Fix‑Alignment** (mind. 64B; Root 4096).
- **Union‑Normflächen** sind erlaubt/erwünscht:
  - `uint8_t raw[64]`, `raw[256]`, `raw[4096]` als ABI‑Anker
  - darüber strukturierte Sichten (Hot/Warm/Cold)
- **Keine 0‑Sized Arrays**, keine flex arrays in SHM‑Segmenten.
- **Append‑Only**: Felder werden nur hinten ergänzt; für Umbrüche: `schema_version` bump.

### 2.2 Atomics & Memory‑Order
- `_Atomic` nur dort, wo Reader/Writer parallel sind.
- Für jedes Atomic‑Feld: Kommentar, ob `relaxed` genügt oder `acquire/release` benötigt wird.
- `volatile` ist **kein** Synchronisationsersatz.

### 2.3 ABI‑Prüfpflicht
- Jede Änderung an `include/cl_runtime/*` muss durch:
  - `cl_abi_report` (Alignof/sizeof/offsets)
  - `cl_shm_dump` (TOC‑Kohärenz)
  - `make monitor` (Header‑Konsistenz)

## 3. Wire‑Vertrag (OOB / Data‑Plane)

### 3.1 OOB Wire
- Wire‑Structs sind **packed**.
- Zahlenfelder sind **explizit little‑endian** (`*_le`).
- Größen müssen exakt passen: `hdr32`, `beacon64`, `hello128`, `grant128` via `_Static_assert`.

### 3.2 Zero‑Trust: „Beacon ist untrusted“
- **Beacon** dient nur der Sichtbarkeit („seen“) und grobem Capability‑Hinweis.
- **Keine** Autorisierung anhand Beacon.
- Join/Trust entsteht erst via **Hello/Grant** mit Auth‑Tag + Anti‑Replay.

## 4. Join Policy (Security‑First, paranoid)

### 4.1 Ziel
- Kein Fremdgerät darf „aus Versehen“ Partner werden, nur weil es im selben L2/L3 auftaucht.
- Default: **deny**. Allow nur, wenn Join‑Policy es gestattet.

### 4.2 Mindestmechaniken
- `mesh_tag64` als Domain‑Trennung (mehrere Meshes im selben LAN).
- `node_tag64` als Identität.
- Anti‑Replay: monotones `epoch` pro Sender/Peer.
- Auth‑Tag (truncated) für Hello/Grant.
- Rate‑Limit/Backoff: gegen Flood/Join‑Storm.
- Fail‑Safe: bei Unsicherheit → `PASSIVE_MONITORING` oder `OOB_ONLY`.

### 4.3 Praxis‑Szenario: „10G + 1G Mischverkabelung“
- Peers können über unterschiedliche NICs sichtbar sein (10G MikroTik + 1G Fritz‑LAN).
- Join muss explizit entscheiden:
  - **welcher** physische Pfad (NIC/Route) ist „data eligible“
  - welche Pfade sind nur OOB/Discovery
- Ergebnis: kein „Bridging“, kein Default‑Route‑Hack.

## 5. Autopath & Fallback (Stabilität vor Turbo)

- Baseline immer möglich: **UDP**.
- Upgrade auf BYPASS nur nach Probe + Health‑Check + Hysterese.
- Sofort‑Downgrade bei Fehlern (Penalty Box).
- TCP ist Rettungsboot, nicht Standard.

## 6. Sensorik/VRM/Thermik (Reality‑Filter)

- VRM/Board/Power‑Sensoren sind oft noisy.  
  → Sie dürfen **nicht** das Micro‑Pacing im Fast‑Path steuern.
- Regel: VRM/Power ist **Safety Cutoff** mit Hysterese/Glättung (Trend‑Filter).
- Wenn kritisch: sofort dämpfen (Constraints setzen), aber kein Zickzack.

## 7. „Maximum‑Minimum“ Performance‑Policy

- Kompression/FEC/Vector‑Pfad dürfen hochskalieren, wenn:
  - Bottleneck == Netzwerk
  - CPU Budget verfügbar
  - Thermik nicht kritisch
  - User‑Interaktivität nicht leidet (Shadow/Reclaim)
- Wenn Bottleneck == Storage/Senke → Backpressure statt „mehr CPU“.

## 8. Watchdog (geplant / Erweiterung)

- Watchdog darf CL neu starten, weil Fail‑Open das OS stabil hält.
- Jeder Restart muss:
  - Grund/Reason/Constraints loggen (System‑Log‑Ordner)
  - im SHM „Forensics“ die letzten 5 Events führen
  - Monitor: Dashboard‑Status „Watchdog active“ + Historie

## 9. Code‑Stil (menschenlesbar, deutsch dokumentiert)

- Header‑Kommentare und Feld‑Kommentare **Deutsch**.
- Strukturen klar segmentieren (Hot/Warm/Cold).
- Keine „Workarounds“ die ABI verschleiern: jedes Padding ist bewusst und kommentiert.
- PRI‑Makros (`PRIu64` etc.) in Monitor‑Formatierung verwenden.

## 10. Definition of Done (für jede Änderung)

- Kompiliert auf Linux + FreeBSD/GhostBSD + OmniOS (mindestens Header‑/Tool‑Build).
- ABI‑Report: `RESULT: ABI_STABLE`.
- OOB‑Wire: `_Static_assert` für alle Message‑Sizes grün.
- Monitor liest ohne nt…‑Konvertierung und erklärt *warum* (Reason).


<<< END FILE: ./docs/PROJECT_GUARDRAILS.md

>>> START FILE: ./docs/SECURITY_AND_JOIN_POLICY.md
# CommanderLink – SECURITY & JOIN POLICY

## Ziel
Paranoide, deterministische Join-Regeln ohne Heuristik.

---

## 1. Grundsatz

> **Kein Peer ist vertrauenswürdig, bevor er es bewiesen hat.**

---

## 2. Mesh-Identität

- `mesh_tag64`: Domain-Identität
- `node_tag64`: Hardware-Identität

Beide:
- deterministisch
- persistent
- nicht erratbar

---

## 3. Beacon (untrusted)

- Sichtbarkeit
- Caps-Anzeige
- Kein Vertrauen

---

## 4. Hello / HelloAck

- Authentifiziert
- Geometrie-Aushandlung
- Overlay-IP
- Gates

---

## 5. Grant

- Credits
- FEC/CRC-Parameter
- Accept-Mode
- TTL

Ohne gültigen Grant:
- kein Senden

---

## 6. Replay-Schutz

- Epoch pro Peer
- Strict Monotonicity

---

## 7. Fail-Safe

- Bei Fehler → PASSIVE
- Overlay-Routen entfernen
- OS übernimmt

---

## 8. Merksatz

> **Security ist ein Zustand, kein Feature.**


<<< END FILE: ./docs/SECURITY_AND_JOIN_POLICY.md

>>> START FILE: ./docs/SPEC_EXEC_CTX_64.md
# CommanderLink SPEC: Execution Context 64B (Host)

## 1. Status
Normativ. Dieses Dokument definiert das einzige zulässige Host-Objekt für die Fastpath-Verarbeitung: `cl_exec_ctx_64_t`.

## 2. Physikalische Wahrheit
- Der Execution Context ist exakt 64 Byte groß (eine Cacheline).
- `raw[64]` ist die Normfläche. Feldsicht ist sekundär.
- Host-Order ist intern verbindlich.
- Wire-Endianness ist ausschließlich im Wire-Protokoll relevant.

## 3. Verbote
- Keine Pointer im Execution Context.
- Kein `packed`.
- Keine compilerabhängigen Layoutannahmen.
- Keine variablen Längenstrukturen im Context.

## 4. Ingest/Egress
- Ingest expandiert Wire-Header + lokale Metadaten deterministisch in `cl_exec_ctx_64_t`.
- Egress darf ausschließlich aus `cl_exec_ctx_64_t` plus separater Payload-Region erzeugen.
- Der Context ist nie der Payload selbst, sondern die Verarbeitungseinheit/Metadaten.

## 5. SIMD-Prinzip
- SIMD-first: Fastpath arbeitet primär auf `HOT` (16B) und den festen Kopf-Feldern.
- SIMD-Breite (SSE4/AVX2/AVX-512) ist eine Policy/Gate-Entscheidung; der Context bleibt invariant.

## 6. PHV / Zero-Transformation
- `payload_quantum`, `headroom`, `tailroom` sind deterministische Parameter.
- Zero-Transformation ist der Default: Keine impliziten Kopien/Reshapes.
- Transformationen (z.B. LZ4/FEC) sind explizit und müssen über Flags/Policy sichtbar sein.

## 7. Audit/Forensik
- AUX-Felder sind minimal und dürfen den Fastpath nicht destabilisieren.
- Detaillierte Forensik ist außerhalb des 64B-Contexts zu führen (History/Forensics-Segmente).


<<< END FILE: ./docs/SPEC_EXEC_CTX_64.md

>>> START FILE: ./docs/TYPES_AND_ABI.md
# CommanderLink – TYPES & ABI CONTRACT

## Zweck
Dieses Dokument definiert verbindlich,
welche C-Datentypen in CommanderLink erlaubt sind
und wo sie eingesetzt werden dürfen.

Es verhindert ABI-Drift, Padding-Fehler und Plattform-Inkonsistenzen.

---

## 1. Grundregel

> **Shared Memory und Wire sind heilig.**

Alles, was dort liegt, muss:
- exakt
- reproduzierbar
- ABI-stabil
- endian-klar
sein.

---

## 2. Erlaubte Typen in SHM & Wire

### 2.1 Integer

Erlaubt:
- `uint8_t`
- `uint16_t`
- `uint32_t`
- `uint64_t`
- `int16_t`, `int32_t`, `int64_t` (nur wenn nötig)

Nicht erlaubt:
- `int`
- `long`
- `size_t`
- `bool`
- `enum` ohne explizite Größe

---

### 2.2 Atomics

Erlaubt:
- `_Atomic(uint8_t)`
- `_Atomic(uint32_t)`
- `_Atomic(uint64_t)`

Verwendung:
- Counters
- Flags
- Epochs

Nicht erlaubt:
- Atomics auf Structs
- Atomics auf Arrays

---

### 2.3 Bitfelder

**Verboten.**

Bitfelder sind ABI- und Endian-abhängig.

Stattdessen:
- Bitmasken in `uint32_t` oder `uint64_t`

---

### 2.4 Floating Point

In SHM/Wire:
- **verboten**

Stattdessen:
- `*_permille`
- `*_ppm`
- `*_x10`, `*_x100`

---

## 3. Typen im Hot Path (intern)

Erlaubt:
- `uint_fast32_t`, `uint_fast64_t`
- `size_t` (nur lokal)
- `uintptr_t`
- SIMD-Typen (`__m128i`, `__m256i`, `__m512i`)

Nicht erlaubt:
- Speicherung dieser Typen im SHM/Wire

---

## 4. Endianness-Regeln

- SHM: **Host-Order**
- Wire: **Little-Endian** (`*_le`)

Konvertierung:
- Nur an der Wire-Grenze
- Niemals im Monitor

---

## 5. Alignment-Regeln

- Cacheline-Einheiten: exakt 64 Byte
- Root-Strukturen: 4096 Byte
- DMA-Segmente: 4096 Byte

Kein implizites Compiler-Padding erlaubt.

---

## 6. Schema-Versionierung

Jede SHM-Root-Struktur enthält:
- `schema_version`
- `endian_magic`

Neue Felder:
- nur in reservierten Bereichen
- Schema-Version erhöhen

---

## 7. ABI-Tests

Pflicht:
- `_Static_assert(sizeof(...))`
- `_Static_assert(_Alignof(...))`
- `cl_abi_report` grün

Ohne ABI-Grün kein Merge.

---

## 8. Merksatz

> **Alles, was nicht exakt ist, ist ein Bug.**


<<< END FILE: ./docs/TYPES_AND_ABI.md

>>> START FILE: ./docs/WATCHDOG_AND_FORENSICS.md
# CommanderLink – WATCHDOG & FORENSICS

## Ziel
Automatische Selbstheilung ohne Datenverlust.

---

## 1. Watchdog-Aufgabe

- Überwacht CL-Prozess
- Erkennt Deadlocks / Panics
- Restartet CL

---

## 2. Restart-Regeln

- Immer Fail-Open
- Keine Kernel-Abhängigkeit
- Kein System-Neustart

---

## 3. Forensik-Log

Bei jedem Restart:
- Zeitstempel
- Grund
- letzter Path-State
- letzte Constraint-Flags

---

## 4. Monitor-Integration

- Watchdog-Status sichtbar
- Letzte 5 Restart-Events
- Lesbare Zeitformate

---

## 5. Merksatz

> **Ein Neustart ist kein Fehler, sondern Wartung.**


<<< END FILE: ./docs/WATCHDOG_AND_FORENSICS.md

>>> START FILE: ./docs/WATCHDOG.md
# CommanderLink Watchdog (FINAL)
Datei: docs/WATCHDOG.md

## Zweck
Der Watchdog stellt sicher, dass CommanderLink sich selbst heilen kann:
- Bei Stall oder Panic wird CL neu gestartet.
- Das OS bleibt stabil (Fail-open).

## Prinzipien
- Fail-open für OS: cl0 ist non-persistent; routes sind /32; keine Default-Route Änderungen.
- Fail-closed für CL Data Plane: Bei Unsicherheit TX locked, OOB optional.
- Restart erfolgt über Supervisor (systemd/rc.d/SMF), nicht durch Systemreboot.

## Fortschritt vs. Liveness
Liveness bedeutet: Modul tickt.
Fortschritt bedeutet: System bewegt sich (commit_epoch/seq_cnt/peer seen).

## Restart-Log
Der Watchdog schreibt beim Restart einen Logeintrag in:
- /var/log/commanderlink/cl_watchdog.log

Format: eine Zeile pro Restart (maschinenlesbar)
- ts_ns=<uint64>
- reason=<wd_reason>
- module=<wd_module>
- last_progress_ns=<uint64>
- last_commit_epoch=<uint64>
- backend=<enum>
- profile=<enum>
- constraints=0x...
- mesh=<short>
- node=<short>
- restart_count=<u32>

Zeitumwandlung in lesbar erfolgt im Monitor (age/uptime).

## Monitor Pflichtanzeige
Dashboard:
- WATCHDOG: OK/WARN/STALL/PANIC (farbig, bold bei nicht OK)
- RESTARTS: total count
- LAST: age + reason/module

Forensics:
- zeigt die letzten 5 Restart-bezogenen Events

## Forensics Events (append-only)
- WD_RESTART_REQUEST
- WD_SELF_EXIT
- WD_HARD_KILL
- WD_RESTARTED


<<< END FILE: ./docs/WATCHDOG.md

>>> START FILE: ./docs/ZERO_LAWS_2.md
# CommanderLink – KANONISCHE GESETZE (aus diesem Gespräch)
## Stand: konsolidiert, ZERO-Abweichung, physics-first

---

## LAW_00_PHYSICS_FIRST

Physik ist die oberste Autorität.

Wenn elektrische, thermische, zeitliche oder speicherphysikalische Realität
einer Spezifikation, Konvention oder Implementationsannahme widerspricht,
gilt immer die Physik.

Spezifikationen sind Untergrenzen, niemals Designziele.

---

## LAW_01_WORST_CASE_BOUNDEDNESS

Jeder Pfad in CommanderLink muss worst-case-begrenzt sein.

Unbounded Loops, implizite Backoffs, adaptive Heuristiken ohne harte Grenzen
sind verboten.

Worst-Case-Stabilität hat Vorrang vor Durchschnittsperformance.

---

## LAW_02_SHM_IS_TRUTH

Shared Memory ist die einzige Wahrheit.

Alle Zustände existieren ausschließlich in SHM.
Logs, Events oder UI-Zustände haben keinen Wahrheitsanspruch.

---

## LAW_03_SHADOW_TO_ACTIVE_CORE_ONLY

Der Übergang von Shadow nach Active darf ausschließlich im CORE erfolgen.

Der Übergang ist atomar.
Kein anderes Modul darf Active schreiben oder Shadow „reparieren“.

---

## LAW_04_ROLE_PURITY

Rollen sind strikt getrennt:

- HAL misst und publiziert Shadow.
- CORE entscheidet und setzt Wahrheit.
- FLOW leitet ab und erzeugt Intent.
- LINK führt aus und entscheidet nicht.
- ORACLE liest und empfiehlt.
- MONITOR liest passiv.

Jede Rollenverletzung ist illegal.

---

## LAW_05_ZERO_TRANSFORMATION

Im Kern von CommanderLink sind Transformationen verboten.

Verboten sind:
- implizite Kopien
- semantische Rewrites
- implizite Format- oder Bedeutungsänderungen

Zulässig sind ausschließlich explizit vertraglich definierte Operationen
(CRC, FEC, Kompression), vollständig auditierbar und gate-gebunden.

---

## LAW_06_MINIMUM_IS_MAXIMUM

Der Mindestbetrieb von CommanderLink ist vollwertig.

„Degraded Mode“ existiert nicht.
Optimierungen sind Skalierungen, keine Rettungsmechanismen.

---

## LAW_07_MINIMUM_TRANSFER_MODE

Der Mindestübertragungsmodus von CommanderLink ist:

Ein CL-semantischer, credit- und pacing-gesteuerter Transport über UDP
ab Sekunde 0.

TCP ist kein Mindestmodus.
TCP ist ausschließlich ein Transport-Fallback, niemals Semantikträger.

CommanderLink ersetzt TCP ab dem ersten Paket.

---

## LAW_08_SENDER_WAITS

Der Sender wartet.

Senden ohne Credits, ohne Drain-Rate oder außerhalb von Pacing-Quanten
ist verboten.

Push-basierte Übertragung ist unzulässig.

---

## LAW_09_EXPLICIT_FLOW_CONTROL

Flow-Control ist explizit, sichtbar und deterministisch.

Credits, Inflight-Budgets, Burst-Caps und Rate-Ziele sind
tabellengetrieben und SHM-sichtbar.

Implizite Kernel- oder Protokollheuristiken sind unzulässig.

---

## LAW_10_AUTOMATION_WITHOUT_HEURISTICS

Automatik bedeutet deterministische Ableitung, nicht adaptive Heuristik.

Autopath, Autopacing, AutoMTU, AutoIntegrity und Autoscale
sind endliche Zustandsautomaten mit festen Tabellen und Hysterese.

LINK darf niemals autonom entscheiden.

---

## LAW_11_DEFAULT_DENY_TRUST

Join und Trust sind Default-Deny.

Ohne expliziten TRUSTED_ACTIVE-Zustand existieren:
- keine Overlay-Routen
- keine Grants
- keine Data-Plane

Fail-Open betrifft Betrieb, nicht Berechtigung.

---

## LAW_12_WATCHDOG_MANDATORY

Ein Watchdog ist verpflichtend.

Verletzungen von Invarianten, Hänger oder Vertragsbrüche
müssen deterministisch erkannt und behandelt werden.

---

## LAW_13_ABI_AND_LAYOUT_IMMUTABILITY

ABI- und SHM-Layouts sind deterministisch und unverhandelbar.

- Cacheline-Union-Prinzip
- feste Strides (256/512/1024/4096)
- kein `packed`
- explizites Padding
- Static Asserts überall

---

## LAW_14_ELASTIC_BULK_SHM

Bulk-SHM ist elastisch und jederzeit reclaimable.

- Core-SHM ist immer resident und minimal funktionsfähig.
- Bulk-SHM darf bis zum maximal verfügbaren RAM wachsen.
- Bulk-SHM darf jederzeit bis auf 0 verschwinden.

Bulk-Präsenz ist ausschließlich über `bulk_present` und `bulk_epoch`
definiert.

Bulk-Abwesenheit ist semantisch RECLAIMED, nicht „leer“.

---

## LAW_15_LIVE_REEVALUATION

CommanderLink skaliert permanent live.

Jeder Tick ist eine Neuberechnung der physikalisch zulässigen Realität.

Es existiert kein stabiler Betriebszustand,
nur ein aktuell erlaubter Zustand.

---

## LAW_16_AUDITABILITY_TO_LAST_BIT

Jedes Bit ist entweder:
- semantisch definiert
- explizit reserviert

Undefinierte Bytes sind verboten.

Der Monitor zeigt Wahrheit, nicht Interpretation.

---

## LAW_17_ZERO_DEVIATION

Abweichungen von diesen Gesetzen sind unzulässig.

Wenn Implementierung und Gesetz widersprechen,
ist die Implementierung falsch.

Diese Gesetze sind endlos gültig.


<<< END FILE: ./docs/ZERO_LAWS_2.md

>>> START FILE: ./docs/ZERO_LAWS.md
# CommanderLink – ZERO LAWS
## Endlos gültig · bitgenau · physics-first · ZERO-Abweichung

---

## ZERO_LAW_00_PHYSICS_ABSOLUTE

Physik ist die einzige Autorität.

Elektrische, thermische, zeitliche und speicherphysikalische Realität
haben immer Vorrang vor Spezifikationen, Konventionen,
Implementationen oder Meinungen.

---

## ZERO_LAW_01_ZERO_DEVIATION

Abweichungen sind unzulässig.

Es existiert kein Sonderfall, kein Debug-Modus,
keine Übergangsregel und kein späterer Fix.

Wenn Implementierung und Gesetz widersprechen,
ist die Implementierung falsch.

---

## ZERO_LAW_02_SHM_SINGLE_SOURCE_OF_TRUTH

Shared Memory ist die einzige Wahrheit.

Alle Zustände existieren ausschließlich in SHM.
Logs, Events, UI-Zustände oder Heuristiken haben keinen Wahrheitsanspruch.

---

## ZERO_LAW_03_SHADOW_TO_ACTIVE_CORE_ONLY

Der Übergang von Shadow nach Active darf ausschließlich im CORE erfolgen.

Der Übergang ist atomar.
Kein anderes Modul darf Active schreiben
oder Shadow interpretieren oder reparieren.

---

## ZERO_LAW_04_ROLE_PURITY

Rollen sind strikt getrennt und unverletzlich:

- HAL misst und publiziert Shadow.
- CORE entscheidet und setzt Wahrheit.
- FLOW leitet ab und erzeugt Intent.
- LINK führt aus und entscheidet nicht.
- ORACLE liest und empfiehlt.
- MONITOR liest passiv.

Rollenvermischung ist illegal.

---

## ZERO_LAW_05_ZERO_TRANSFORMATION

Im Kern von CommanderLink sind Transformationen verboten.

Verboten sind:
- implizite Kopien
- semantische Rewrites
- implizite Bedeutungsänderungen
- versteckte Normalisierungen

Zulässig sind ausschließlich explizit vertraglich definierte,
auditierbare Operationen unter Gate-Kontrolle.

---

## ZERO_LAW_06_MINIMUM_IS_MAXIMUM

Der Mindestbetrieb ist vollwertig.

Es existiert kein „Degraded Mode“.
Optimierungen sind Skalierungen,
keine funktionalen Rettungsmechanismen.

---

## ZERO_LAW_07_MINIMUM_TRANSFER_MODE

Der Mindestübertragungsmodus ist:

Ein CL-semantischer, credit- und pacing-gesteuerter Transport
über UDP ab Sekunde 0.

TCP ist kein Mindestmodus.
TCP ist ausschließlich Transport-Fallback.

CommanderLink ersetzt TCP ab dem ersten Paket.

---

## ZERO_LAW_08_SENDER_WAITS

Der Sender wartet.

Senden ohne Credits, ohne Drain-Rate
oder außerhalb deterministischen Pacings
ist verboten.

Push-basierte Übertragung ist unzulässig.

---

## ZERO_LAW_09_NO_IMPLICIT_HEURISTICS

Implizite Heuristiken sind verboten.

Alle Entscheidungen sind:
- tabellengetrieben
- zustandsbasiert
- worst-case-begrenzt
- SHM-sichtbar

---

## ZERO_LAW_10_WORST_CASE_BOUNDEDNESS

Jeder Pfad ist worst-case-begrenzt.

Unbounded Loops, implizite Backoffs,
opportunistische Entscheidungen
und adaptive Logik ohne harte Grenzen
sind verboten.

---

## ZERO_LAW_11_DEFAULT_DENY_TRUST

Join und Trust sind Default-Deny.

Ohne TRUSTED_ACTIVE existieren:
- keine Overlay-Routen
- keine Grants
- keine Data-Plane

Fail-Open betrifft Betrieb, nicht Berechtigung.

---

## ZERO_LAW_12_WATCHDOG_MANDATORY

Ein Watchdog ist verpflichtend.

Invariantverletzungen, Hänger
oder Vertragsbrüche müssen
deterministisch erkannt und behandelt werden.

---

## ZERO_LAW_13_ABI_AND_LAYOUT_IMMUTABLE

ABI- und SHM-Layouts sind unveränderlich.

- Cacheline-Union-Prinzip
- feste Strides
- kein `packed`
- explizites Padding
- statische Verifikation

---

## ZERO_LAW_14_ELASTIC_BULK_WITH_MINIMUM

Bulk-SHM ist elastisch und jederzeit reclaimable.

- Core-SHM ist immer resident und minimal funktionsfähig.
- Bulk-SHM darf bis zum maximal verfügbaren RAM wachsen.
- Bulk-SHM darf jederzeit bis auf 0 verschwinden.

Bulk-Abwesenheit ist semantisch RECLAIMED.

---

## ZERO_LAW_15_LIVE_REEVALUATION

CommanderLink skaliert permanent live.

Jeder Tick ist eine Neuberechnung
der physikalisch zulässigen Realität.

Es existiert kein stabiler Zustand,
nur ein aktuell erlaubter.

---

## ZERO_LAW_16_AUDITABILITY_TO_LAST_BIT

Jedes Bit ist entweder:
- semantisch definiert
- explizit reserviert

Undefinierte Bytes sind verboten.

Der Monitor zeigt Wahrheit, nicht Interpretation.

---

## ZERO_LAW_17_FINALITY

Diese Gesetze sind endlos gültig.

Sie stehen über Implementierungen,
Tools, Betriebssystemen und Meinungen.

CommanderLink ist ZERO oder nicht CommanderLink.


<<< END FILE: ./docs/ZERO_LAWS.md

>>> START FILE: ./include/cl_common/cl_align.h
#pragma once
/* ============================================================================
 * CommanderLink – Alignment/ABI Grundbausteine (Common) – FINAL
 * Datei: include/cl_common/cl_align.h
 * ============================================================================
 *
 * Zweck:
 *   Einheitliche OS-freie Makros für Alignment und Compile-Time-Gates.
 *
 * Maschinenregel:
 *   Alignment ist Geometrie (Cacheline/Page/Stride), kein Compiler-Zufall.
 * ============================================================================
 */

#include <stddef.h>
#include <stdint.h>

#if defined(__GNUC__) || defined(__clang__)
  #define CL_ALIGNAS(N) __attribute__((aligned(N)))
#else
  #define CL_ALIGNAS(N) _Alignas(N)
#endif

#define CL_STATIC_ASSERT(expr, msg) _Static_assert((expr), msg)


<<< END FILE: ./include/cl_common/cl_align.h

>>> START FILE: ./include/cl_common/cl_endian.h
#pragma once
/* ============================================================================
 * CommanderLink – Endianness Helpers (Common) – FINAL
 * Datei: include/cl_common/cl_endian.h
 * ============================================================================
 *
 * Maschinenregeln:
 *   - SHM ist Host-Order.
 *   - Wire/OOB ist explizit little-endian (_le) und wird an der Grenze konvertiert.
 * ============================================================================
 */

#include <stdint.h>

#if defined(__clang__) || defined(__GNUC__)
  #define CL_BSWAP16(x) __builtin_bswap16((uint16_t)(x))
  #define CL_BSWAP32(x) __builtin_bswap32((uint32_t)(x))
  #define CL_BSWAP64(x) __builtin_bswap64((uint64_t)(x))
#else
  static inline uint16_t CL_BSWAP16(uint16_t x) { return (uint16_t)((x<<8) | (x>>8)); }
  static inline uint32_t CL_BSWAP32(uint32_t x) {
      return ((x & 0x000000FFu) << 24) |
             ((x & 0x0000FF00u) <<  8) |
             ((x & 0x00FF0000u) >>  8) |
             ((x & 0xFF000000u) >> 24);
  }
  static inline uint64_t CL_BSWAP64(uint64_t x) {
      return ((x & 0x00000000000000FFull) << 56) |
             ((x & 0x000000000000FF00ull) << 40) |
             ((x & 0x0000000000FF0000ull) << 24) |
             ((x & 0x00000000FF000000ull) <<  8) |
             ((x & 0x000000FF00000000ull) >>  8) |
             ((x & 0x0000FF0000000000ull) >> 24) |
             ((x & 0x00FF000000000000ull) >> 40) |
             ((x & 0xFF00000000000000ull) >> 56);
  }
#endif

#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
  #define CL_HOST_IS_LE 1
#else
  #define CL_HOST_IS_LE 0
#endif

static inline uint16_t cl_host_to_le16(uint16_t v) { return CL_HOST_IS_LE ? v : CL_BSWAP16(v); }
static inline uint32_t cl_host_to_le32(uint32_t v) { return CL_HOST_IS_LE ? v : CL_BSWAP32(v); }
static inline uint64_t cl_host_to_le64(uint64_t v) { return CL_HOST_IS_LE ? v : CL_BSWAP64(v); }

static inline uint16_t cl_le16_to_host(uint16_t v) { return CL_HOST_IS_LE ? v : CL_BSWAP16(v); }
static inline uint32_t cl_le32_to_host(uint32_t v) { return CL_HOST_IS_LE ? v : CL_BSWAP32(v); }
static inline uint64_t cl_le64_to_host(uint64_t v) { return CL_HOST_IS_LE ? v : CL_BSWAP64(v); }


<<< END FILE: ./include/cl_common/cl_endian.h

>>> START FILE: ./include/cl_manifest/cl_enums.h
#pragma once
/* ============================================================================
 * CommanderLink – Enums/Flags (Manifest) – FINAL, EINZIGE WAHRHEIT
 * Datei: include/cl_manifest/cl_enums.h
 * ============================================================================
 *
 * Maschinenregel:
 *   - Alle Zustände/Flags/Reason Codes hier, keine Doppeldefinitionen.
 *   - „Maximalmodell“: UNSUPPORTED/DISABLED/IDLE/ACTIVE/UNKNOWN/FAULT sind Pflicht.
 * ============================================================================
 */

#include <stdint.h>

/* ---------------- Globale Health Bits ---------------- */
#define CL_HEALTH_OK               (1u << 0)
#define CL_HEALTH_DEGRADED         (1u << 1)
#define CL_HEALTH_FAULT            (1u << 2)

#define CL_HEALTH_OOB_OK           (1u << 8)
#define CL_HEALTH_OVERLAY_OK       (1u << 9)
#define CL_HEALTH_SECURITY_OK      (1u << 10)
#define CL_HEALTH_THERMAL_CAP      (1u << 11)
#define CL_HEALTH_VRM_CAP          (1u << 12)
#define CL_HEALTH_POWER_CAP        (1u << 13)
#define CL_HEALTH_STORAGE_CAP      (1u << 14)

/* ---------------- Feature State (Maximalmodell) ---------------- */
typedef enum {
    CL_FEAT_UNSUPPORTED = 0, /* Hardware/OS kann es nicht */
    CL_FEAT_UNKNOWN     = 1, /* könnte, aber nicht messbar / nicht bestätigt */
    CL_FEAT_DISABLED    = 2, /* möglich, aber Policy/Gate verbietet */
    CL_FEAT_IDLE        = 3, /* möglich & erlaubt, aber aktuell nicht aktiv */
    CL_FEAT_ACTIVE      = 4, /* aktiv genutzt */
    CL_FEAT_FAULT       = 5  /* defekt / Grenzwert überschritten */
} cl_feature_state_t;

/* ---------------- Budget State ---------------- */
typedef enum {
    CL_BUDGET_BOOST   = 0,
    CL_BUDGET_NORMAL  = 1,
    CL_BUDGET_SHADOW  = 2,
    CL_BUDGET_RECLAIM = 3,
    CL_BUDGET_RECOVER = 4
} cl_budget_state_t;

/* ---------------- Path State ---------------- */
typedef enum {
    CL_PATH_BOOT = 0,
    CL_PATH_PASSIVE_MONITORING,
    CL_PATH_OOB_DISCOVERY,
    CL_PATH_NEGOTIATING,
    CL_PATH_ACTIVE_BYPASS,
    CL_PATH_ACTIVE_UDP,
    CL_PATH_DEGRADED,
    CL_PATH_TCP_FALLBACK
} cl_path_state_t;

/* RX/TX Gates */
typedef enum { CL_RX_NONE=0, CL_RX_OOB_ONLY=1, CL_RX_FULL=2 } cl_rx_gate_t;
typedef enum { CL_TX_LOCKED=0, CL_TX_OOB_ONLY=1, CL_TX_ALLOWED=2 } cl_tx_gate_t;

/* ---------------- Backend Active ---------------- */
typedef enum { CL_BACKEND_NONE=0, CL_BACKEND_BYPASS, CL_BACKEND_UDP, CL_BACKEND_TCP } cl_backend_active_t;

/* Backend detail */
typedef enum {
    CL_BACKEND_DETAIL_NONE = 0,
    CL_BACKEND_DETAIL_NETMAP,
    CL_BACKEND_DETAIL_AF_XDP,
    CL_BACKEND_DETAIL_UDP_SOCKET,
    CL_BACKEND_DETAIL_TCP_SOCKET
} cl_backend_detail_t;

typedef enum { CL_BSTATE_UDP_BASE=0, CL_BSTATE_BYPASS_ACTIVE, CL_BSTATE_DEGRADED, CL_BSTATE_TCP_FALLBACK } cl_backend_state_t;

/* ---------------- Link Modes ---------------- */
typedef enum {
    CL_LINK_RAW          = 0x0001,
    CL_LINK_FLOW         = 0x0002,
    CL_LINK_FLOW_LZ4     = 0x0003,
    CL_LINK_FLOW_FEC     = 0x0004,
    CL_LINK_FLOW_LZ4_FEC = 0x0005,
    CL_LINK_OOB          = 0x00F0,
    CL_LINK_SYNC         = 0x00F1
} cl_link_mode_t;

/* ---------------- Profiles ---------------- */
typedef enum { CL_PROFILE_BASIC=0, CL_PROFILE_BALANCED=1, CL_PROFILE_HPP_PLUS=2 } cl_transfer_profile_t;

/* Thermal */
typedef enum { CL_THERM_OPTIMAL=0, CL_THERM_WARM=1, CL_THERM_HOT=2, CL_THERM_CRITICAL=3 } cl_thermal_state_t;

/* Peer online */
typedef enum { CL_PEER_UNKNOWN=0, CL_PEER_ONLINE=1, CL_PEER_OFFLINE=2 } cl_peer_state_t;

/* Trust */
typedef enum {
    CL_TRUST_UNKNOWN=0,
    CL_TRUST_SEEN_UNTRUSTED=1,
    CL_TRUST_NEGOTIATING_AUTH=2,
    CL_TRUST_TRUSTED_ACTIVE=3,
    CL_TRUST_DENIED=4
} cl_peer_trust_state_t;

/* Accept mode (Transfer semantics) */
typedef enum { CL_ACCEPT_BUFFERED=0, CL_ACCEPT_DURABLE=1 } cl_accept_mode_t;

/* CRC modes (Maximalmodell) */
typedef enum {
    CL_CRC_NONE   = 0,
    CL_CRC_CRC32C = 1,
    CL_CRC_CRC64  = 2,
    CL_CRC_CRC128 = 3
} cl_crc_mode_t;

/* FEC modes (Maximalmodell) */
typedef enum {
    CL_FEC_OFF   = 0,
    CL_FEC_XOR   = 1, /* 1-parity erasure */
    CL_FEC_RS    = 2, /* Reed-Solomon erasure (future/enterprise) */
    CL_FEC_OTHER = 3
} cl_fec_mode_t;

/* Compression ladder */
typedef enum { CL_COMP_OFF=0, CL_COMP_LZ4_FAST=1, CL_COMP_LZ4_HC_LOW=2, CL_COMP_LZ4_HC_MAX=3 } cl_comp_mode_t;
typedef enum { CL_COMP_CAP_OK=0, CL_COMP_CAP_THERMAL, CL_COMP_CAP_BUDGET, CL_COMP_CAP_BAD_RATIO, CL_COMP_CAP_SINK_LIMIT, CL_COMP_CAP_INTEGRITY, CL_COMP_CAP_PEER_LIMIT } cl_comp_cap_reason_t;

/* Constraint flags */
typedef uint32_t cl_constraint_flags_t;

#define CL_CF_NONE               0u
#define CL_CF_BUDGET_SHADOW      (1u << 0)
#define CL_CF_BUDGET_RECLAIM     (1u << 1)
#define CL_CF_THERMAL_CAP        (1u << 2)
#define CL_CF_BOARD_VRM_CAP      (1u << 3)
#define CL_CF_POWER_UNSTABLE     (1u << 4)
#define CL_CF_STORAGE_SINK_CAP   (1u << 5)

#define CL_CF_FIREWALL_BLOCK     (1u << 8)
#define CL_CF_BACKEND_FAIL       (1u << 9)
#define CL_CF_PEER_CAPS          (1u << 10)
#define CL_CF_NET_HEALTH         (1u << 11)
#define CL_CF_LINK_DEGRADED      (1u << 12)
#define CL_CF_OVERLAY_DOWN       (1u << 13)
#define CL_CF_ROUTE_ORPHAN       (1u << 14)
#define CL_CF_CREDIT_STALE       (1u << 15)
#define CL_CF_SECURITY_REQUIRED  (1u << 16)
#define CL_CF_SECURITY_DEGRADED  (1u << 17)
#define CL_CF_PEER_UNTRUSTED     (1u << 18)

/* Reason codes */
typedef enum {
    CL_RC_OK=0,
    CL_RC_ADMIN_POLICY,

    CL_RC_PEER_TIMEOUT,
    CL_RC_PEER_NO_CAPS,
    CL_RC_NO_OOB_ACK,

    CL_RC_NO_UDP_ACK,
    CL_RC_BACKEND_ERROR,
    CL_RC_CREDIT_EXPIRED,

    CL_RC_LOSS_SPIKE,
    CL_RC_JITTER_SPIKE,
    CL_RC_THERMAL_EVENT,
    CL_RC_BUDGET_EVENT,
    CL_RC_BOARD_VRM_EVENT,
    CL_RC_POWER_UNSTABLE_EVENT,
    CL_RC_STORAGE_SINK_EVENT,

    CL_RC_MTU_MISMATCH,
    CL_RC_VERSION_MISMATCH,

    CL_RC_IP_COLLISION,
    CL_RC_IP_COLLISION_STORM,
    CL_RC_OVERLAY_SETUP_FAIL,

    CL_RC_SECURITY_PREREQ_MISSING,
    CL_RC_SECURITY_VERSION_TOO_OLD,
    CL_RC_AUTH_FAILED,
    CL_RC_REPLAY_DETECTED,
    CL_RC_UNTRUSTED_PEER
} cl_reason_code_t;

/* Drop reason (hot path) */
typedef enum {
    CL_DROP_NONE=0, CL_DROP_HDR_CRC, CL_DROP_AUTH, CL_DROP_NO_SESSION, CL_DROP_DUPLICATE,
    CL_DROP_OUT_OF_WINDOW, CL_DROP_RESOURCE, CL_DROP_BACKEND_FAIL, CL_DROP_MTU_MISMATCH, CL_DROP_THERMAL
} cl_drop_reason_t;


<<< END FILE: ./include/cl_manifest/cl_enums.h

>>> START FILE: ./include/cl_manifest/cl_features.h
#pragma once
/* ============================================================================
 * CommanderLink – Features/Caps (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_features.h
 * ============================================================================
 */

#include <stdint.h>
#include "cl_enums.h"

typedef uint32_t cl_cpu_isa_mask_t;
#define CL_ISA_SSE42   (1u << 0)
#define CL_ISA_AVX2    (1u << 1)
#define CL_ISA_AVX512  (1u << 2)
#define CL_ISA_AMX     (1u << 3)
#define CL_ISA_AESNI   (1u << 4)
#define CL_ISA_PCLMUL  (1u << 5)

typedef enum { CL_ISA_EFF_SSE42=0, CL_ISA_EFF_AVX2=1, CL_ISA_EFF_AVX512=2, CL_ISA_EFF_AMX=3 } cl_cpu_isa_effective_t;

typedef uint32_t cl_backend_mask_t;
#define CL_BE_M_BYPASS (1u << 0)
#define CL_BE_M_UDP    (1u << 1)
#define CL_BE_M_TCP    (1u << 2)

/* Security caps */
typedef struct {
    uint8_t openssl_present;
    uint8_t openssl_version_ok;
    uint8_t auth_required;
    uint8_t reserved0;
} cl_security_caps_t;

/* Memory caps */
typedef struct {
    uint64_t total_ram_bytes;
    uint64_t staging_cap_max_bytes;
    uint64_t staging_cap_current_bytes;
    uint64_t rx_window_current_bytes;
    uint8_t hugepages_supported;
    uint8_t hugepages_active;
    uint16_t reserved0;
} cl_mem_caps_t;

/* NIC caps */
typedef struct {
    uint16_t ports_count;
    uint16_t queues_count;
    uint32_t link_speed_mbps;
    uint16_t mtu_min;
    uint16_t mtu_max;
    cl_backend_mask_t backend_possible_mask;
} cl_nic_caps_t;

/* Board caps */
typedef struct {
    uint8_t vrm_supported;
    uint8_t ripple_supported;
    uint8_t pwr_limits_supported;
    uint8_t reserved0;
    cl_thermal_state_t board_therm_state;
    uint8_t power_unstable;
    uint16_t reserved1;
} cl_board_caps_t;

/* Host snapshot (possible/effective + reasons) */
typedef struct {
    cl_cpu_isa_mask_t cpu_isa_possible;
    cl_backend_mask_t backend_possible;
    uint32_t profile_possible_mask;

    cl_cpu_isa_effective_t cpu_isa_effective;
    cl_backend_active_t backend_effective;
    cl_transfer_profile_t profile_effective;

    cl_constraint_flags_t constraint_flags;
    cl_reason_code_t reason_code;

    cl_security_caps_t security;
    cl_mem_caps_t mem;
    cl_nic_caps_t nic;
    cl_board_caps_t board;

    uint32_t reserved2;
} cl_host_caps_t;


<<< END FILE: ./include/cl_manifest/cl_features.h

>>> START FILE: ./include/cl_manifest/cl_ids.h
#pragma once
/* ============================================================================
 * CommanderLink – Identity Contract (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_ids.h
 * ============================================================================
 */

#include <stdint.h>

typedef uint64_t cl_mesh_tag64_t;
typedef uint64_t cl_node_tag64_t;
typedef uint64_t cl_session_id64_t;

typedef struct { uint8_t b[16]; } cl_uuid16_t;

/* Darstellung (Monitor/Forensik), deterministisch */
static inline uint32_t cl_id_short8_u32(uint64_t tag64) {
    uint64_t x = tag64 ^ (tag64 >> 32);
    return (uint32_t)x;
}


<<< END FILE: ./include/cl_manifest/cl_ids.h

>>> START FILE: ./include/cl_manifest/cl_join_policy.h
#pragma once
/* ============================================================================
 * CommanderLink – Join/Trust Policy (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_join_policy.h
 * ============================================================================
 */

#include <stdint.h>
#include "cl_enums.h"
#include "cl_trust.h"

typedef enum { CL_JOIN_LAB_PERMISSIVE=0, CL_JOIN_PARANOID_STRICT=1 } cl_join_mode_t;

#define CL_JOIN_MODE_DEFAULT CL_JOIN_PARANOID_STRICT
#define CL_JOIN_REQUIRE_AUTH 1

#define CL_JOIN_HELLO_TIMEOUT_MS  500u
#define CL_JOIN_RETRY_MAX         3u
#define CL_JOIN_REPLAY_WINDOW_DEFAULT 64u


<<< END FILE: ./include/cl_manifest/cl_join_policy.h

>>> START FILE: ./include/cl_manifest/cl_limits.h
#pragma once
/* ============================================================================
 * CommanderLink – Limits (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_limits.h
 * ============================================================================
 */

#include <stdint.h>

#define CL_MAX_CORES                 512u
#define CL_MAX_NET_IFACES            16u
#define CL_MAX_GPUS                  8u
#define CL_MAX_MEM_CHANNELS          32u
#define CL_MAX_PCIE_LANES            256u

#define CL_MESH_HOT_NEIGHBORS        32u
#define CL_SWARM_MAX_TRACKED_PEERS   16384u
#define CL_ZFS_MAX_DATASETS          4096u

#define CL_DMA_SLOT_BYTES            4096u

#define CL_OOB_GRANT_TTL_MS_DEFAULT        200u
#define CL_INJECT_PREPARE_TTL_MS_DEFAULT   50u

#define CL_OVERLAY_PREFIXLEN_DEFAULT       10u

#define CL_ATOM_BYTES_DEFAULT              64u
#define CL_HEADROOM_DEFAULT_BYTES          64u


<<< END FILE: ./include/cl_manifest/cl_limits.h

>>> START FILE: ./include/cl_manifest/cl_link_modes.h
#pragma once
/* ============================================================================
 * CommanderLink – Link Modes (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_link_modes.h
 * ============================================================================
 *
 * Zweck:
 *   Stabiler Include-Punkt für Link-Modi. Die Wahrheit liegt in cl_enums.h.
 * ============================================================================
 */

#include "cl_enums.h"

#define CL_LINK_MODE_RAW          CL_LINK_RAW
#define CL_LINK_MODE_FLOW         CL_LINK_FLOW
#define CL_LINK_MODE_FLOW_LZ4     CL_LINK_FLOW_LZ4
#define CL_LINK_MODE_FLOW_FEC     CL_LINK_FLOW_FEC
#define CL_LINK_MODE_FLOW_LZ4_FEC CL_LINK_FLOW_LZ4_FEC
#define CL_LINK_MODE_OOB          CL_LINK_OOB
#define CL_LINK_MODE_SYNC         CL_LINK_SYNC


<<< END FILE: ./include/cl_manifest/cl_link_modes.h

>>> START FILE: ./include/cl_manifest/cl_manifest.h
#pragma once
/* ============================================================================
 * CommanderLink – Manifest Frontdoor (FINAL, Paket 2/6)
 * Datei: include/cl_manifest/cl_manifest.h
 * ============================================================================
 */

#include "cl_modeling_rule.h"

#include "cl_enums.h"
#include "cl_limits.h"
#include "cl_ids.h"
#include "cl_features.h"

#include "cl_simd_policy.h"
#include "cl_zero_transform.h"

#include "cl_trust.h"
#include "cl_join_policy.h"

#include "cl_link_modes.h"
#include "cl_overlay.h"
#include "cl_wire.h"
#include "cl_oob.h"
#include "cl_wire_crc.h"

<<< END FILE: ./include/cl_manifest/cl_manifest.h

>>> START FILE: ./include/cl_manifest/cl_modeling_rule.h
#pragma once
/* ============================================================================
 * CommanderLink – Modeling Rule / Verfassung (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_modeling_rule.h
 * ============================================================================
 *
 * Globale Projektregel (bindend):
 *   - „Das Maximum ist das Minimum.“
 *   - Abwesenheit ist ein Zustand, keine Lücke.
 *   - Alles, was lieferbar ist, wird erfasst; alles andere wird als Zustand
 *     UNSUPPORTED/UNKNOWN/DISABLED modelliert – inklusive Source/Quality/Reason.
 *
 * Konsequenzen:
 *   - SHM modelliert das Maximum (possible/effective/state/source/quality).
 *   - Policies/Gates werten alle verfügbaren Daten aus.
 *   - Monitor zeigt das Maximalmodell lückenlos, markiert Einschränkungen explizit.
 *
 * Sicherheitsregel:
 *   - Join/Trust paranoid (Default-deny). Ohne Trust: keine Routes/Grants/Data Plane.
 *
 * Performance-Regel:
 *   - Standard ist maximale Performance unter offenen Gates (Budget/Thermal/VRM/Security).
 *   - Reduktion ist sofort und lokal, nie global vorsorglich.
 * ============================================================================
 */

#include <stdint.h>

#define CL_MODEL_MAX_IS_MIN 1
#define CL_MODEL_STATE_EXPLICIT 1
#define CL_MODEL_APPEND_ONLY 1
#define CL_MODEL_SHM_HOST_ORDER 1
#define CL_MODEL_SHM_NO_PACKED 1

#define CL_MODEL_ZERO_TRANSFORM_STANDARD 1
#define CL_MODEL_ATOM_BYTES 64u


<<< END FILE: ./include/cl_manifest/cl_modeling_rule.h

>>> START FILE: ./include/cl_manifest/cl_oob_wire.h
#pragma once
/* ============================================================================
 * CommanderLink – OOB Wire (UDP/4343) – FINAL
 * Datei: include/cl_manifest/cl_oob_wire.h
 * ============================================================================
 *
 * Regeln:
 *   - Wire ist packed
 *   - Zahlenfelder sind *_le (explizit little-endian)
 *   - Beacon64 ist untrusted (kein auth)
 *   - Hello128 und Grant128 sind paranoid-auth (auth_tag16 Pflicht)
 * ============================================================================
 */

#include <stdint.h>

#include "../cl_common/cl_endian.h"
#include "cl_enums.h"

#define CL_OOB_PORT   4343u
#define CL_OOB_VER_1  1u
#define CL_OOB_MAGIC  0xC10Bu

typedef enum {
    CL_OOB_BEACON    = 1,
    CL_OOB_HELLO     = 2,
    CL_OOB_HELLO_ACK = 3,
    CL_OOB_GRANT     = 4,
    CL_OOB_BYE       = 5
} cl_oob_type_t;

#define CL_OOB_F_ACK_REQ      (1u << 0)
#define CL_OOB_F_AUTH_PRESENT (1u << 1)

/* Header 32B (universal) – FINAL, size-locked */
typedef struct __attribute__((packed)) {
    uint16_t magic_le;        /* CL_OOB_MAGIC */
    uint8_t  ver;             /* CL_OOB_VER_1 */
    uint8_t  type;            /* cl_oob_type_t */
    uint32_t msg_len_le;      /* sizeof(message) */

    uint16_t flags_le;        /* CL_OOB_F_* */
    uint8_t  hdr_crc8;        /* optional: 0 if unused */
    uint8_t  reserved0;       /* must be 0 */

    uint32_t epoch_le;        /* monotonic per sender (replay gate), u32 */

    uint64_t mesh_tag64_le;   /* domain */
    uint64_t node_tag64_le;   /* identity */
} cl_oob_hdr32_t;

_Static_assert(sizeof(cl_oob_hdr32_t) == 32, "oob hdr must be 32B");

typedef struct __attribute__((packed)) {
    cl_oob_hdr32_t h;              /* 32 */

    uint32_t caps_summary32_le;    /* 4 */
    uint16_t mtu_max_le;           /* 2 */
    uint8_t  profile_allowed_mask; /* 1 */
    uint8_t  backend_allowed_mask; /* 1 */

    uint32_t health_bits_le;       /* 4 */
    uint32_t build_id_le;          /* 4 */

    uint64_t mono_ts_ns_le;        /* 8 */

    uint64_t reserved0_le;         /* 8 -> padding to 64 */
} cl_oob_beacon64_t;

_Static_assert(sizeof(cl_oob_beacon64_t) == 64, "beacon 64");


/* ---------------- HELLO128 / HELLOACK128 (auth required) ---------------- */
typedef struct __attribute__((packed)) {
    cl_oob_hdr32_t h;              /* 32 */

    uint32_t caps_full32_le;       /* detailed caps summary */
    uint32_t proto_compat_le;      /* compat flags / schema family */

    uint32_t overlay_ip_le;        /* host order encoded as LE u32 */
    uint8_t  overlay_prefixlen;    /* usually 10 */
    uint8_t  rx_gate;              /* cl_rx_gate_t */
    uint8_t  tx_gate;              /* cl_tx_gate_t */
    uint8_t  trust_policy;         /* cl_join_mode_t / policy selector */

    uint16_t payload_quantum_le;   /* 64 (ZT atom) */
    uint16_t payload_headroom_le;  /* 64 default */
    uint16_t mtu_min_le;           /* path MTU min */
    uint16_t mtu_max_le;           /* path MTU max */

    uint32_t link_speed_mbps_le;   /* best-effort; 0=unknown; u32 reicht bis ~4 Tbps */
    uint16_t ports_count_le;       /* Anzahl physischer Ports (1..N) */
    uint16_t reserved_ports0;      /* muss 0 sein (Reserve/Alignment-Konstanz) */

    uint64_t rx_window_bytes_le;   /* receiver window */
    uint64_t drain_bps_le;         /* receiver drain rate */

    uint32_t grant_ttl_ms_le;      /* default 200ms */
    uint32_t prepare_ttl_ms_le;    /* default 50ms */

    uint32_t reason_code_le;       /* cl_reason_code_t */
    uint32_t constraint_flags_le;  /* cl_constraint_flags_t */

    uint32_t crc_mode_possible_le; /* bitmask over cl_crc_mode_t */
    uint32_t fec_mode_possible_le; /* bitmask over cl_fec_mode_t */

    uint32_t crc_mode_effective_le;/* chosen (optional hint) */
    uint32_t fec_nk_le;            /* high16=N low16=K */

    uint8_t  auth_tag16[16];       /* REQUIRED: HMAC/tag truncated */
} cl_oob_hello128_t;

_Static_assert(sizeof(cl_oob_hello128_t) == 128, "hello 128");
typedef cl_oob_hello128_t cl_oob_hello_ack128_t;

/* ---------------- GRANT128 (auth required) ---------------- */
typedef struct __attribute__((packed)) {
    cl_oob_hdr32_t h;              /* 32 */

    uint64_t grant_id_le;          /* 8 */
    uint64_t refill_epoch_le;      /* 8 */

    uint32_t grant_ttl_ms_le;      /* 4 */
    uint32_t session_id32_le;      /* 4 */

    uint32_t credits_pkts_le;      /* 4 */
    uint32_t credits_bytes_le;     /* 4 */

    uint32_t reason_code_le;       /* 4 */
    uint32_t constraint_flags_le;  /* 4 */

    uint16_t payload_quantum_le;   /* 2 */
    uint16_t payload_headroom_le;  /* 2 */
    uint16_t mtu_effective_le;     /* 2 */
    uint16_t reserved0;            /* 2 */

    uint16_t fec_n_le;             /* 2 */
    uint16_t fec_k_le;             /* 2 */
    uint16_t crc_mode_le;          /* 2 */
    uint16_t fec_mode_le;          /* 2 */

    uint32_t accept_mode_le;       /* 4 */
    uint32_t durable_granularity_le; /* 4 */

    uint8_t  auth_tag16[16];       /* 16 */

    uint8_t  pad[16];              /* 24 -> total 128 */
} cl_oob_grant128_t;

_Static_assert(sizeof(cl_oob_grant128_t) == 128, "grant 128");


<<< END FILE: ./include/cl_manifest/cl_oob_wire.h

>>> START FILE: ./include/cl_manifest/cl_oob.h
#pragma once
#ifdef __cplusplus
extern "C" {
#endif

#include "cl_oob_wire.h"

#ifdef __cplusplus
}
#endif


<<< END FILE: ./include/cl_manifest/cl_oob.h

>>> START FILE: ./include/cl_manifest/cl_overlay.h
#pragma once
/* ============================================================================
 * CommanderLink – Overlay Manifest (v0.1) – FINAL
 * Datei: include/cl_manifest/cl_overlay.h
 * ============================================================================
 *
 * Ziel:
 *   Overlaynetz 100.64.0.0/10, deterministisch, Zero-ARP (Host-Routen /32).
 *
 * Maschinenregeln:
 *   - Host-Order im SHM.
 *   - Fail-Open: Interface nicht persistent, stirbt mit Daemon.
 * ============================================================================
 */

#include <stdint.h>

#include "../cl_common/cl_align.h"
#include "cl_enums.h"

#define CL_OVERLAY_PREFIXLEN            10u
#define CL_OVERLAY_NET_BASE_U32         0x64400000u
#define CL_OVERLAY_NET_MASK_U32         0xFFC00000u
#define CL_OVERLAY_HOST_MASK_U32        0x003FFFFFu

#define CL_OVERLAY_MAX_COLLISION_RETRIES 16u

#if defined(__linux__)
  #define CL_OVERLAY_IF_NAME_DEFAULT "cl0"
#elif defined(__sun__)
  #define CL_OVERLAY_IF_NAME_DEFAULT "cltun0"
#else
  #define CL_OVERLAY_IF_NAME_DEFAULT "tun0"
#endif

typedef enum {
    CL_ROUTE_SYNCED    = 0,
    CL_ROUTE_ORPHAN    = 1,
    CL_ROUTE_PENDING   = 2,
    CL_ROUTE_NONE      = 3,
    CL_ROUTE_COLLISION = 4
} cl_overlay_route_state_t;

static inline uint32_t cl_overlay_calc_ip_host_u32(uint64_t node_tag64,
                                                   uint64_t mesh_tag64,
                                                   uint8_t collision_offset)
{
    uint64_t mixed = node_tag64 ^ mesh_tag64 ^ (node_tag64 >> 22) ^ (mesh_tag64 << 5);
    uint32_t h22 = (uint32_t)((mixed ^ (mixed >> 22) ^ (mixed >> 44)) & CL_OVERLAY_HOST_MASK_U32);
    h22 = (h22 + (uint32_t)collision_offset) & CL_OVERLAY_HOST_MASK_U32;
    if (h22 == 0u) h22 = 1u;
    return (CL_OVERLAY_NET_BASE_U32 | h22);
}


<<< END FILE: ./include/cl_manifest/cl_overlay.h

>>> START FILE: ./include/cl_manifest/cl_simd_policy.h
#pragma once
/* ============================================================================
 * CommanderLink – SIMD/ISA Policy (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_simd_policy.h
 * ============================================================================
 */

#include <stdint.h>
#include "cl_enums.h"
#include "cl_features.h"

typedef enum {
    CL_SIMD_EFF_SCALAR = 0,
    CL_SIMD_EFF_SSE42  = 1,
    CL_SIMD_EFF_AVX2   = 2,
    CL_SIMD_EFF_AVX512 = 3,
    CL_SIMD_EFF_AMX    = 4
} cl_simd_effective_t;

typedef enum {
    CL_AVX512_RISK_UNKNOWN = 0,
    CL_AVX512_RISK_SAFE    = 1,
    CL_AVX512_RISK_OFFSET  = 2
} cl_avx512_risk_t;

typedef uint32_t cl_simd_policy_flags_t;

#define CL_SIMD_PF_NONE                   0u
#define CL_SIMD_PF_ALLOW_AVX2             (1u << 0)
#define CL_SIMD_PF_ALLOW_AVX512           (1u << 1)
#define CL_SIMD_PF_ALLOW_AMX              (1u << 2)
#define CL_SIMD_PF_AVX512_REQUIRE_GENESIS (1u << 8)

static inline cl_simd_effective_t cl_simd_choose_effective(uint32_t cpu_isa_possible_mask,
                                                           cl_avx512_risk_t avx512_risk,
                                                           cl_budget_state_t budget_state,
                                                           uint32_t constraint_flags,
                                                           cl_simd_policy_flags_t policy_flags)
{
    if ((cpu_isa_possible_mask & CL_ISA_SSE42) == 0u) return CL_SIMD_EFF_SCALAR;

    if (budget_state == CL_BUDGET_SHADOW || budget_state == CL_BUDGET_RECLAIM) return CL_SIMD_EFF_SSE42;

    if (constraint_flags & (CL_CF_THERMAL_CAP | CL_CF_BOARD_VRM_CAP | CL_CF_POWER_UNSTABLE)) return CL_SIMD_EFF_SSE42;

    if ((policy_flags & CL_SIMD_PF_ALLOW_AVX2) && (cpu_isa_possible_mask & CL_ISA_AVX2)) {
        if ((policy_flags & CL_SIMD_PF_ALLOW_AVX512) &&
            (cpu_isa_possible_mask & CL_ISA_AVX512) &&
            (avx512_risk == CL_AVX512_RISK_SAFE))
        {
            return CL_SIMD_EFF_AVX512;
        }
        return CL_SIMD_EFF_AVX2;
    }

    return CL_SIMD_EFF_SSE42;
}


<<< END FILE: ./include/cl_manifest/cl_simd_policy.h

>>> START FILE: ./include/cl_manifest/cl_trust.h
#pragma once
/* ============================================================================
 * CommanderLink – Trust / Join State Machine (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_trust.h
 * ============================================================================
 */

#include <stdint.h>
#include "cl_enums.h"

static inline int cl_trust_allows_routes(cl_peer_trust_state_t st) { return st == CL_TRUST_TRUSTED_ACTIVE; }
static inline int cl_trust_allows_grants(cl_peer_trust_state_t st) { return st == CL_TRUST_TRUSTED_ACTIVE; }
static inline int cl_trust_allows_dataplane(cl_peer_trust_state_t st) { return st == CL_TRUST_TRUSTED_ACTIVE; }

typedef enum {
    CL_TR_EVT_NONE = 0,
    CL_TR_EVT_SEEN_BEACON = 1,
    CL_TR_EVT_SEEN_HELLO  = 2,
    CL_TR_EVT_AUTH_OK     = 10,
    CL_TR_EVT_AUTH_FAIL   = 11,
    CL_TR_EVT_REPLAY      = 20,
    CL_TR_EVT_TTL_EXPIRED = 21,
    CL_TR_EVT_TRUSTED     = 30,
    CL_TR_EVT_DENIED      = 31,
    CL_TR_EVT_ROUTE_BLOCKED = 40,
    CL_TR_EVT_GRANT_BLOCKED = 41
} cl_trust_event_id_t;

typedef struct {
    uint64_t last_epoch;
    uint64_t window_mask;
    uint64_t window_base;
} cl_replay_window_t;

static inline void cl_replay_reset(cl_replay_window_t *w) {
    w->last_epoch = 0;
    w->window_mask = 0;
    w->window_base = 0;
}


<<< END FILE: ./include/cl_manifest/cl_trust.h

>>> START FILE: ./include/cl_manifest/cl_wire_crc.h
#pragma once
/* ============================================================================
 * CommanderLink – Wire Integrity (CRC8 Header + CRC32C Trailer) – FINAL
 * Datei: include/cl_manifest/cl_wire_crc.h
 * ============================================================================
 *
 * Ziel:
 *   - CPU soll rechnen, nicht verwalten.
 *   - Starke Integrität nutzt hardware-nahe Primitive, wenn verfügbar.
 *
 * Vertrag:
 *   1) Header Early-Reject:
 *      - CRC8 über CLWP Header (16B), hdr_crc8 Feld vorher 0.
 *
 *   2) Payload Strong Integrity:
 *      - CRC32C (Castagnoli) als Trailer (4B, little-endian)
 *      - Trailer ist nur vorhanden, wenn CL_WF_PAYLOAD_CRC32C gesetzt ist.
 *      - payload_len im Header zählt NUR den Payload (ohne Trailer).
 *      - Auf dem Draht folgt nach payload_len Bytes ggf. crc32c_le (4B).
 *
 *   3) Optional: Batch-CRC32C (High-throughput)
 *      - Wenn CL_WF_BATCH_CRC32C gesetzt ist, trägt der Frame eine Batch-CRC32C
 *        als Trailer (siehe cl_wire_batch_crc_tail16_t).
 *      - Nutzung: große Transfers, amortisierte Integrität.
 *
 * SIMD/HW:
 *   - Auf x86_64 kann CRC32C per SSE4.2 Instruktion gerechnet werden.
 *   - Die Nutzung ist capability-/gate-gebunden (possible/effective).
 * ============================================================================
 */

#include <stdint.h>
#include <stddef.h>
#include <string.h>

#include "cl_wire.h"

/* ----------------------------- CRC8 Vertrag --------------------------------
 *
 * CRC8 ist ausschließlich Early-Reject.
 * Polynom wird hier normativ festgelegt.
 *
 * CRC8-ATM (poly 0x07) ist klein, stabil und ausreichend als "quick check".
 * Starke Integrität ist CRC32C (Trailer).
 */
#define CL_CRC8_POLY_U8   0x07u
#define CL_CRC8_INIT_U8   0x00u
#define CL_CRC8_XOROUT_U8 0x00u

/* Berechnungs-API (Implementation in .c, nicht hier als Heuristik):
 *   - cl_crc8_hdr16() berechnet hdr_crc8 für cl_wire_hdr16_t (hdr_crc8=0).
 */
uint8_t cl_crc8_hdr16(const cl_wire_hdr16_t *h);

/* ---------------------------- CRC32C Trailer ------------------------------ */

/* CRC32C (Castagnoli) */
#define CL_CRC32C_INIT_U32   0xFFFFFFFFu
#define CL_CRC32C_XOROUT_U32 0xFFFFFFFFu

/* 4B Trailer – little-endian */
typedef struct __attribute__((packed)) cl_wire_crc32c_tail4 {
    uint32_t crc32c_le;
} cl_wire_crc32c_tail4_t;

_Static_assert(sizeof(cl_wire_crc32c_tail4_t) == 4, "crc32c tail muss 4B sein");

/* Optionaler Batch-CRC Trailer – 16B (konstant, maschinenfreundlich)
 *
 * Anwendung:
 *   - Ein Frame mit CL_WF_BATCH_CRC32C trägt am Ende dieses Trailer-Struct.
 *   - seq_end48 beschreibt den letzten seq im Batch (inkl.).
 *   - batch_id ist der Batch-Kontext.
 *   - crc32c schützt die aggregierte Batch-Payload (vertraglich definiert).
 *
 * Hinweis:
 *   - Diese 16B sind bewusst konstant (keine variablen Strukturen).
 */
typedef struct __attribute__((packed)) cl_wire_batch_crc_tail16 {
    uint16_t magic_le;      /* eigener Trailer-Magic */
    uint16_t batch_id_le;   /* passt zum Header batch_id */
    uint8_t  seq_end48_le[6];
    uint32_t crc32c_le;     /* CRC32C über vereinbarte Batch-Daten */
    uint16_t reserved0;     /* muss 0 sein */
} cl_wire_batch_crc_tail16_t;

#define CL_WIRE_BATCH_CRC_MAGIC_U16 0xC3C3u

_Static_assert(sizeof(cl_wire_batch_crc_tail16_t) == 16, "batch crc tail muss 16B sein");

/* --------------------- CRC32C: Hardware-naher Update-Pfad ------------------
 *
 * Diese Inlines sind rein mechanisch:
 *   - keine Policy, keine Autodetektion
 *   - nur: wenn Compiler+CPU SSE4.2 erlaubt, dann kann man _mm_crc32_* nutzen.
 *
 * Hinweis:
 *   - CPUID/Gate-Entscheidung gehört in HAL/CORE/FLOW (possible/effective),
 *     nicht in diesen Header.
 */
#if defined(__SSE4_2__)
#include <nmmintrin.h> /* _mm_crc32_u8/u64 */

static inline uint32_t cl_crc32c_sse42_u8(uint32_t crc, const uint8_t *p, size_t n) {
    /* crc ist laufender Zustand (init typ. CL_CRC32C_INIT_U32) */
    size_t i = 0;

    /* 8-byte chunks */
    while (i + 8 <= n) {
        uint64_t v;
        memcpy(&v, p + i, sizeof(v));
        crc = (uint32_t)_mm_crc32_u64((uint64_t)crc, v);
        i += 8;
    }

    /* tail */
    while (i < n) {
        crc = _mm_crc32_u8(crc, p[i]);
        i++;
    }

    return crc;
}

#endif /* __SSE4_2__ */

/* CRC32C API (Implementation in .c, policy-/gate-gebunden):
 *   - cl_crc32c_update() rechnet CRC32C über bytes
 *   - Implementation darf SSE4.2 nutzen, wenn possible/effective.
 */
uint32_t cl_crc32c_update(uint32_t crc, const void *data, size_t len);

/* -------------------------- Trailer-Verträge -------------------------------
 *
 * Payload CRC32C Trailer (CL_WF_PAYLOAD_CRC32C):
 *   wire frame layout:
 *     [cl_wire_hdr16_t][payload bytes (payload_len)][cl_wire_crc32c_tail4_t]
 *
 * Batch CRC32C Trailer (CL_WF_BATCH_CRC32C):
 *   wire frame layout:
 *     [cl_wire_hdr16_t][payload bytes (payload_len)][cl_wire_batch_crc_tail16_t]
 *
 * Achtung:
 *   - payload_len zählt NICHT den Trailer mit.
 *   - Receiver muss anhand flags den Trailer erwarten und prüfen.
 */


<<< END FILE: ./include/cl_manifest/cl_wire_crc.h

>>> START FILE: ./include/cl_manifest/cl_wire.h
#pragma once
/* ============================================================================
 * CommanderLink – CLWP Wire Header (16B) – FINAL Endausbau
 * Datei: include/cl_manifest/cl_wire.h
 * ============================================================================
 *
 * Grundsatz:
 *   - Wire ist ein physikalisches Artefakt (nicht "C-API").
 *   - Wire ist explizit little-endian.
 *   - Header ist exakt 16 Byte und packed.
 *
 * Vertrag (CLWP):
 *   - 16-bit Magic (LE)
 *   - 8-bit ver_mode: high nibble = version, low nibble = mode
 *   - 8-bit flags
 *   - 48-bit seq (LE, 6 bytes)
 *   - 16-bit batch_id (LE)
 *   - 16-bit payload_len (LE)  -> Länge des Payloads OHNE Trailer
 *   - 8-bit hdr_crc8           -> Early-Reject (Header-CRC)
 *   - 8-bit reserved           -> muss 0 sein
 *
 * Hinweis:
 *   - Starke Integrität erfolgt NICHT im Header (sonst müsste der Header wachsen),
 *     sondern über Payload-Trailer (CRC32C) gemäß cl_wire_crc.h.
 * ============================================================================
 */

#include <stdint.h>
#include <string.h> /* memcpy */

/* ----------------------------- Konstanten -------------------------------- */

#define CL_WIRE_VER_1 1u

/* 16-bit Wire Magic (auf dem Draht LE kodiert) */
#define CL_WIRE_MAGIC_U16 0xC1C1u

/* Flags (bitweise, 8-bit) */
#define CL_WF_PAYLOAD_CRC32C   (1u << 0) /* Payload hat CRC32C Trailer (4B)          */
#define CL_WF_BATCH_CRC32C     (1u << 1) /* Frame trägt/abschließt Batch-CRC32C     */
#define CL_WF_COMPRESSED       (1u << 2) /* Payload komprimiert (z.B. LZ4)          */
#define CL_WF_FEC              (1u << 3) /* Payload ist FEC-geschützt / shard       */
#define CL_WF_URGENT           (1u << 4) /* Priorität im Budget (trotzdem budgetiert) */
#define CL_WF_SYNC             (1u << 5) /* Synchronisationsframe                   */
#define CL_WF_OOB              (1u << 6) /* OOB im Data-Plane-Kanal (nicht Discovery) */
#define CL_WF_RSVD             (1u << 7) /* reserviert (muss 0 sein)                */

/* ver/mode nibble packing */
#define CL_WIRE_VER_GET(vm)        (((vm) >> 4) & 0x0Fu)
#define CL_WIRE_MODE_GET(vm)       ((vm) & 0x0Fu)
#define CL_WIRE_VER_MODE(ver,mode) ((((ver)&0x0Fu) << 4) | ((mode)&0x0Fu))

/* Modes (low nibble) – Vertrag (semantisch, nicht backend-spezifisch) */
typedef enum {
    CL_WM_RAW           = 0, /* Zero-Transform: Payload ist "as-is"            */
    CL_WM_FLOW          = 1, /* FLOW ohne zusätzliche Transform-Trailer        */
    CL_WM_FLOW_LZ4      = 2, /* FLOW mit LZ4 (Payload-Format in FLOW-Contract) */
    CL_WM_FLOW_FEC      = 3, /* FLOW mit FEC                                    */
    CL_WM_FLOW_LZ4_FEC  = 4, /* FLOW mit LZ4 + FEC                               */
    CL_WM_OOB           = 5, /* OOB-Frame (nicht Beacon/Discovery)              */
    CL_WM_SYNC          = 6  /* SYNC/Control Frames                              */
} cl_wire_mode_t;

/* --------------------------- CLWP Header 16B ------------------------------ */

typedef struct __attribute__((packed)) cl_wire_hdr16 {
    uint16_t magic_le;        /* CL_WIRE_MAGIC_U16, LE */
    uint8_t  ver_mode;        /* ver/mode nibble */
    uint8_t  flags;           /* CL_WF_* */

    uint8_t  seq48_le[6];     /* 48-bit seq, LE (least-significant byte first) */

    uint16_t batch_id_le;     /* batch group, LE */
    uint16_t payload_len_le;  /* payload length (excludes any trailer), LE */

    uint8_t  hdr_crc8;        /* CRC8 over header (siehe unten) */
    uint8_t  reserved0;       /* muss 0 sein */
} cl_wire_hdr16_t;

_Static_assert(sizeof(cl_wire_hdr16_t) == 16, "cl_wire_hdr16_t muss exakt 16B sein");

/* ------------------------- Seq48 load/store --------------------------------
 * Physik:
 *   - seq48 wird als 6 Bytes little-endian gespeichert.
 *   - Zugriff erfolgt über memcpy, um Strict-Aliasing sauber zu halten.
 */
static inline uint64_t cl_wire_seq48_load(const uint8_t seq48_le[6]) {
    uint64_t v = 0;
    /* Little-endian: Byte 0 ist LSB */
    v |= (uint64_t)seq48_le[0] << 0;
    v |= (uint64_t)seq48_le[1] << 8;
    v |= (uint64_t)seq48_le[2] << 16;
    v |= (uint64_t)seq48_le[3] << 24;
    v |= (uint64_t)seq48_le[4] << 32;
    v |= (uint64_t)seq48_le[5] << 40;
    return v;
}

static inline void cl_wire_seq48_store(uint8_t seq48_le[6], uint64_t seq) {
    /* nur low 48 bits gültig */
    seq48_le[0] = (uint8_t)((seq >> 0) & 0xFFu);
    seq48_le[1] = (uint8_t)((seq >> 8) & 0xFFu);
    seq48_le[2] = (uint8_t)((seq >> 16) & 0xFFu);
    seq48_le[3] = (uint8_t)((seq >> 24) & 0xFFu);
    seq48_le[4] = (uint8_t)((seq >> 32) & 0xFFu);
    seq48_le[5] = (uint8_t)((seq >> 40) & 0xFFu);
}

/* ------------------------- Header CRC8 Vertrag -----------------------------
 *
 * Ziel:
 *   - hdr_crc8 ist ausschließlich Early-Reject, nicht "starke Integrität".
 *   - Starke Integrität erfolgt über CRC32C Trailer (cl_wire_crc.h).
 *
 * Definition (normativ):
 *   - hdr_crc8 wird über die 16B Header-Bytes berechnet,
 *     wobei hdr_crc8 selbst als 0 gesetzt wird.
 *   - reserved0 muss 0 sein.
 *
 * CRC8-Polynom:
 *   - Der konkrete CRC8-Algorithmus ist implementation-defined,
 *     ABER MUSS global einheitlich sein (manifestiert in cl_wire_crc.h).
 */


<<< END FILE: ./include/cl_manifest/cl_wire.h

>>> START FILE: ./include/cl_manifest/cl_zero_transform.h
#pragma once
/* ============================================================================
 * CommanderLink – Zero-Transformation Standard (Manifest) – FINAL
 * Datei: include/cl_manifest/cl_zero_transform.h
 * ============================================================================
 */

#include <stdint.h>

#define CL_ATOM_BYTES 64u
#define CL_HEADROOM_DEFAULT_BYTES 64u

#define CL_ZT_FORBID_SHIFT_REPACK 1
#define CL_ZT_FORBID_HOT_MEMCPY   1
#define CL_ZT_FORBID_HOT_ENDIAN   1
#define CL_ZT_FORBID_HOT_ATOMICS  1

/* Wire payload muss NICHT zwingend multiple-of-64 sein (Alltagstauglichkeit) */
#define CL_ZT_WIRE_PAYLOAD_MUST_BE_MULTIPLE_OF_64 0


<<< END FILE: ./include/cl_manifest/cl_zero_transform.h

>>> START FILE: ./include/cl_monitor/cl_monitor.h
#ifndef CL_MONITOR_H
#define CL_MONITOR_H

#include <stdint.h>

typedef enum {
    CL_MON_TAB_DASH = 0,
    CL_MON_TAB_INV  = 1,
    CL_MON_TAB_CPU  = 2,
    CL_MON_TAB_MEM  = 3,
    CL_MON_TAB_NIC  = 4,
    CL_MON_TAB_MESH = 5,
    CL_MON_TAB_DMA  = 6,
    CL_MON_TAB_ZFS  = 7,
    CL_MON_TAB_PCIE = 8,
    CL_MON_TAB_GPU  = 9,
    CL_MON_TAB_ORA  = 10,
    CL_MON_TAB_AUD  = 11
} cl_mon_tab_t;

/* Startet den Monitor (ncurses loop).
 * Rückgabe: exit code.
 */
int cl_monitor_run(void);

#endif


<<< END FILE: ./include/cl_monitor/cl_monitor.h

>>> START FILE: ./include/cl_runtime/cl_gates.h
#pragma once
/* ============================================================================
 * CommanderLink – Globale Gates (Systemzustände & physikalische Schranken)
 *
 * Datei:        include/cl_runtime/cl_gates.h
 *
 * Beschreibung:
 *   Dieses Header definiert die globalen Gates von CommanderLink.
 *
 *   Gates sind KEINE Policy.
 *   Gates sind KEINE Heuristik.
 *   Gates sind KEINE Entscheidung.
 *
 *   Gates sind die materialisierte physikalische Realität des Systems:
 *     - thermische Grenzen
 *     - elektrische Grenzen (VRM/Power)
 *     - Budget- und Interaktivitätszwänge
 *     - Sicherheits- und Trust-Zustände
 *
 *   Alle Runtime-Segmente referenzieren diese Gates.
 *   Kein Segment darf eigene Gate-Semantik erfinden.
 *
 *   Architektur:
 *     - x86_64, little-endian Host
 *     - 64-bit Gate-Masken
 *     - atomar lesbar/schreibbar
 *
 *   WICHTIG:
 *     Dieses Header enthält bewusst KEINE Logik.
 *     Auswertung, Reaktion und Policy liegen außerhalb.
 * ========================================================================== */

#ifndef CL_GATES_H
#define CL_GATES_H

#include <stdint.h>

/* --------------------------------------------------------------------------
 * Architekturannahmen (explizit)
 * -------------------------------------------------------------------------- */
#if !defined(__x86_64__) && !defined(_M_X64)
#error "CommanderLink ist x86_64-first. cl_gates.h setzt x86_64 voraus."
#endif

/* --------------------------------------------------------------------------
 * Gate-Typen: Grundsätzliches Modell
 *
 * - Gates werden als Bitmasken in uint64_t geführt.
 * - Mehrere Gates können gleichzeitig aktiv sein.
 * - Gates sind rein deskriptiv.
 *
 * Begriffe:
 *   possible  : physikalisch / logisch möglich
 *   effective : aktuell wirksam (nach allen Überlagerungen)
 *
 * Beispiel:
 *   AVX-512 possible, aber wegen Thermal-Gate nicht effective.
 * -------------------------------------------------------------------------- */

/* --------------------------------------------------------------------------
 * Gate-Klassen (logische Gruppierung, KEINE Bitwerte)
 * -------------------------------------------------------------------------- */
typedef enum cl_gate_class {
    CL_GATE_CLASS_THERMAL = 0,   /* Temperatur / thermische Limits        */
    CL_GATE_CLASS_POWER,        /* Strom, VRM, Package Power             */
    CL_GATE_CLASS_BUDGET,       /* Zeit-/CPU-/IO-Budget                  */
    CL_GATE_CLASS_INTERACTIVE,  /* Nutzer-Interaktivität                 */
    CL_GATE_CLASS_TRUST,        /* Join / Trust / Security               */
    CL_GATE_CLASS_PLATFORM,     /* Plattform- / Umgebungsrestriktionen   */
    CL_GATE_CLASS_INTERNAL      /* interne Schutzmechanismen             */
} cl_gate_class_t;

/* --------------------------------------------------------------------------
 * Gate-Bits (physikalische Zustände)
 *
 * Bitlayout:
 *   - Niedrige Bits: harte physikalische Schranken
 *   - Mittlere Bits: weiche / adaptive Schranken
 *   - Hohe Bits: logische / sicherheitsrelevante Zustände
 * -------------------------------------------------------------------------- */
typedef uint64_t cl_gate_mask_t;

/* --- Thermische Gates ----------------------------------------------------- */
#define CL_GATE_THERMAL_SOFT        (1ULL << 0)   /* Temperatur hoch, Drossel empfohlen */
#define CL_GATE_THERMAL_HARD        (1ULL << 1)   /* Temperatur kritisch, Drossel Pflicht */

/* --- Power / VRM Gates ---------------------------------------------------- */
#define CL_GATE_POWER_SOFT          (1ULL << 2)   /* Power Budget angespannt             */
#define CL_GATE_POWER_HARD          (1ULL << 3)   /* Power Budget überschritten          */
#define CL_GATE_VRM_LIMIT           (1ULL << 4)   /* VRM meldet Limit / Instabilität     */

/* --- Budget Gates --------------------------------------------------------- */
#define CL_GATE_BUDGET_EXCEEDED     (1ULL << 5)   /* Laufzeit-Budget überschritten       */
#define CL_GATE_BUDGET_RECLAIM      (1ULL << 6)   /* Reclaim aktiv (Bulk freigegeben)    */

/* --- Interaktivität ------------------------------------------------------- */
#define CL_GATE_INTERACTIVE_ACTIVE  (1ULL << 7)   /* Nutzer-/Systeminteraktivität aktiv  */

/* --- Trust / Security ----------------------------------------------------- */
#define CL_GATE_TRUST_NONE          (1ULL << 16)  /* kein Trust (Default-Deny)           */
#define CL_GATE_TRUST_ESTABLISHED   (1ULL << 17)  /* Trust ausgehandelt                  */
#define CL_GATE_TRUST_ACTIVE        (1ULL << 18)  /* Trust aktiv, Data Plane erlaubt     */

#define CL_GATE_SECURITY_DEGRADED   (1ULL << 19)  /* Security nicht voll gewährleistet   */

/* --- Plattform / Umgebung ------------------------------------------------ */
#define CL_GATE_PLATFORM_VM         (1ULL << 24)  /* Ausführung in VM                    */
#define CL_GATE_PLATFORM_LIMITED    (1ULL << 25)  /* reduzierte Telemetrie / Caps        */

/* --- Interne Schutzmechanismen ------------------------------------------- */
#define CL_GATE_WATCHDOG_TRIGGERED  (1ULL << 32)  /* Watchdog hat ausgelöst              */
#define CL_GATE_INTERNAL_ERROR      (1ULL << 33)  /* interner Inkonsistenzschutz         */

/* --------------------------------------------------------------------------
 * Gate-Masken (Zusammenfassungen)
 * -------------------------------------------------------------------------- */

/* Alle Gates, die harte Drosselung erzwingen */
#define CL_GATE_MASK_HARD_LIMITS ( \
    CL_GATE_THERMAL_HARD      |   \
    CL_GATE_POWER_HARD        |   \
    CL_GATE_VRM_LIMIT         |   \
    CL_GATE_WATCHDOG_TRIGGERED )

/* Gates, die Interaktivität schützen */
#define CL_GATE_MASK_INTERACTIVE ( \
    CL_GATE_INTERACTIVE_ACTIVE |  \
    CL_GATE_BUDGET_RECLAIM )

/* Gates, die Data Plane grundsätzlich verbieten */
#define CL_GATE_MASK_NO_DATAPLANE ( \
    CL_GATE_TRUST_NONE        |    \
    CL_GATE_SECURITY_DEGRADED |    \
    CL_GATE_WATCHDOG_TRIGGERED )

/* --------------------------------------------------------------------------
 * Gate-Zustandscontainer
 *
 * Wird in Segmenten verwendet, um possible/effective sauber zu trennen.
 * Größe: 16 Byte (2 × u64), cacheline-neutral.
 * -------------------------------------------------------------------------- */
typedef struct cl_gate_state {
    cl_gate_mask_t possible;   /* was physikalisch / logisch möglich ist */
    cl_gate_mask_t effective;  /* was aktuell wirksam ist                */
} cl_gate_state_t;

_Static_assert(sizeof(cl_gate_state_t) == 16,
               "cl_gate_state_t muss exakt 16 Byte groß sein");

/* --------------------------------------------------------------------------
 * Semantik-Hinweise (KEIN Code!)
 *
 * - possible darf nur erweitert werden, niemals implizit eingeschränkt.
 * - effective ist das Ergebnis aller aktuell aktiven Gates.
 * - Kein Modul darf Gates „wegdiskutieren“.
 * - Monitor zeigt possible vs effective explizit getrennt an.
 * -------------------------------------------------------------------------- */

#endif /* CL_GATES_H */


<<< END FILE: ./include/cl_runtime/cl_gates.h

>>> START FILE: ./include/cl_runtime/cl_quality.h
#pragma once
/* ============================================================================
 * CommanderLink – Source/Quality (Runtime) – FINAL
 * Datei: include/cl_runtime/cl_quality.h
 * ============================================================================
 *
 * Zweck:
 *   - Herkunft und Güte von Telemetrie (Maximalmodell).
 *   - Monitor zeigt Source/Quality lückenlos.
 *   - Oracle/Flow entscheiden anhand Quality, ob Werte kontrollwirksam sind.
 * ============================================================================
 */

#include <stdint.h>

typedef enum {
    CL_SRC_UNSPECIFIED = 0,
    CL_SRC_DIRECT_HW   = 1,
    CL_SRC_OS_IFACE    = 2,
    CL_SRC_TOOL        = 3,
    CL_SRC_INFERRED    = 4,
    CL_SRC_SIMULATED   = 5
} cl_source_t;

typedef enum {
    CL_QUAL_UNSUPPORTED = 0,
    CL_QUAL_ESTIMATED   = 1,
    CL_QUAL_BEST_EFFORT = 2,
    CL_QUAL_DIRECT      = 3
} cl_quality_t;

static inline int cl_quality_control_ok(cl_quality_t q) {
    return (q == CL_QUAL_DIRECT) || (q == CL_QUAL_BEST_EFFORT);
}


<<< END FILE: ./include/cl_runtime/cl_quality.h

>>> START FILE: ./include/cl_runtime/cl_runtime.h
#pragma once
/* ============================================================================
 * CommanderLink – Runtime Frontdoor
 * Datei: include/cl_runtime/cl_runtime.h
 * ============================================================================
 *
 * Zweck:
 *   Diese Datei ist die EINZIGE offizielle Eintrittsstelle in die
 *   CommanderLink Runtime-Wahrheit.
 *
 *   Wer dieses Header includiert, erklärt:
 *     - ich lese Laufzeit-Zustand (SHM)
 *     - ich erwarte keine Policy
 *     - ich erwarte keine Logik
 *
 *   Die Runtime beschreibt:
 *     - WAS zur Laufzeit existiert
 *     - WIE es physikalisch im Speicher liegt
 *     - WIE es beobachtet werden darf
 *
 *   Die Runtime beschreibt NICHT:
 *     - WANN etwas geschieht
 *     - WARUM etwas entschieden wird
 *     - WIE Initialisierung erfolgt
 *
 *   Architektur:
 *     - x86_64 first
 *     - Host-Endianness
 *     - Cacheline-exakt
 *     - ABI-stabil
 *
 *   Plattformen:
 *     - Linux
 *     - FreeBSD / GhostBSD
 *     - OmniOS / illumos
 *
 *   KEINE Policy. KEINE Heuristik. KEINE Logik.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

/* --------------------------------------------------------------------------
 * 1) Fundamentale Runtime-Typen (ohne Abhängigkeiten)
 * -------------------------------------------------------------------------- */

/* Gates = physikalische Schranken */
#include "cl_gates.h"

/* Beobachtungsqualität / Quelle */
#include "cl_quality.h"

/* --------------------------------------------------------------------------
 * 2) Manifest-nahe Definitionen (symbolische Wahrheit)
 * -------------------------------------------------------------------------- */

/* Enums & IDs (reine Zustandskodierung) */
#include "../cl_manifest/cl_enums.h"
#include "../cl_manifest/cl_ids.h"

/* --------------------------------------------------------------------------
 * 3) Runtime-Ordnung & Verkabelung
 * -------------------------------------------------------------------------- */

/* Table of Contents (physikalische SHM-Struktur) */
#include "cl_toc.h"

/* SHM-Layout & Speicherklassen */
#include "cl_shm_layout.h"

/* Runtime-Schema (Pflicht / Optional / Feature-gebunden) */
#include "cl_schema.h"

/* BOOTEN VON CL */
#include "cl_service_seg_256.h"

/* --------------------------------------------------------------------------
 * 4) Runtime-Segmente (SHM-Wahrheit)
 * -------------------------------------------------------------------------- */

/* Kernsegmente - INVENTAR */
#include "cl_seg_cpu_1024.h"
#include "cl_seg_budget_256.h"
#include "cl_seg_mem_256.h"
#include "cl_seg_time_256.h"
#include "cl_seg_board_512.h"

/* Netzwerk / Transfer */
#include "cl_seg_nic_512.h"
#include "cl_seg_link_256.h"
#include "cl_seg_overlay_256.h"
#include "cl_seg_mesh_neighbor_256.h"
#include "cl_seg_mesh_peer_256.h"
#include "cl_seg_dma_4096.h"

/* System / Stabilität */
#include "cl_seg_watchdog_256.h"
#include "cl_seg_pcie_256.h"

/* Storage */
#include "cl_seg_zfs_4096.h"

/* Analyse / Langzeit */
#include "cl_seg_oracle_256.h"
#include "cl_seg_history_4096.h"
#include "cl_seg_forensics_4096.h"

/* Datenpaket */


/* --------------------------------------------------------------------------
 * 5) Runtime-Meta (rein beschreibend)
 * -------------------------------------------------------------------------- */

/*
 * cl_runtime_caps_t beschreibt, welche Teile der Runtime
 * in einer konkreten Instanz existieren KÖNNEN.
 *
 * Dies ist KEINE Initialisierung, KEINE Policy, KEINE Logik.
 * Es ist eine deklarative Zusammenfassung für:
 *   - Monitor
 *   - Tools
 *   - Minimal-Boot
 */
typedef struct cl_runtime_caps {

    /* Grundlegende Verfügbarkeit */
    uint8_t has_cpu;
    uint8_t has_memory;
    uint8_t has_budget;

    /* Netzwerk */
    uint8_t has_nic;
    uint8_t has_mesh;
    uint8_t has_dma;

    /* Storage */
    uint8_t has_zfs;

    /* Analyse */
    uint8_t has_oracle;
    uint8_t has_history;
    uint8_t has_forensics;

} cl_runtime_caps_t;

/*
 * Hinweis:
 *   cl_runtime_caps_t wird NICHT von der Runtime gesetzt.
 *   Es ist eine deklarative Beschreibung dessen,
 *   was prinzipiell Teil der Runtime sein kann.
 */



<<< END FILE: ./include/cl_runtime/cl_runtime.h

>>> START FILE: ./include/cl_runtime/cl_schema.h
#pragma once
/* ============================================================================
 * CommanderLink – Schema/ABI Contract (Runtime) – FINAL
 * Datei: include/cl_runtime/cl_schema.h
 * ============================================================================
 *
 * Zweck:
 *   - Einmalige, zentrale Definition der Runtime-Schema-Version.
 *   - Endianness Magic (Host sanity).
 *   - Page-Größe/Alignment (Root-Page).
 *
 * Maschinenregel:
 *   - SHM ist Host-Order.
 *   - endian_magic muss beim Attach geprüft werden.
 *   - Schema bump nur bei semantisch relevanten Layout-Änderungen.
 * ============================================================================
 */

#include <stdint.h>

#define CL_SCHEMA_VERSION_U32  0x00000111u
#define CL_ENDIAN_MAGIC_U32    0x12345678u
#define CL_SHM_PAGE_BYTES      4096u

#define CL_ABI_CHECKSUM_NONE   0ull



<<< END FILE: ./include/cl_runtime/cl_schema.h

>>> START FILE: ./include/cl_runtime/cl_seg_board_512.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Board/VRM/Power (512B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_board_512.h
 * ============================================================================
 *
 * Maximalmodell:
 * - Board/VRM/Power sind Safety Cutoff Inputs, nicht Hot-Pacing Inputs.
 * - Alle Werte haben state/source/quality.
 * - Hersteller/Name/Serial ist in COLD enthalten (Monitor-Anforderung).
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT A 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) board_therm_state; /* cl_thermal_state_t */
        _Atomic(uint32_t) board_cap_flags;   /* constraint bits (VRM/POWER/THERM) */

        _Atomic(uint32_t) vrm_temp_c_x10;
        _Atomic(uint32_t) pch_temp_c_x10;

        _Atomic(uint32_t) pwr_package_mw;
        _Atomic(uint32_t) pwr_limit_mw;

        _Atomic(uint32_t) vrm_ripple_mv_x10;
        _Atomic(uint32_t) power_unstable;    /* 0/1 */

        _Atomic(uint64_t) last_update_ns;
    };
    uint8_t raw[64];
} cl_board_hot_64a_t;

CL_STATIC_ASSERT(sizeof(cl_board_hot_64a_t) == 64, "board hot a 64");

/* HOT B 64 (smoothed outputs + events) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) vrm_temp_avg_c_x10;
        _Atomic(uint32_t) pwr_pkg_avg_mw;
        _Atomic(uint32_t) ripple_avg_mv_x10;
        _Atomic(uint32_t) vrm_trend_permille;

        _Atomic(uint64_t) cap_events_total;
        _Atomic(uint64_t) power_events_total;
        _Atomic(uint64_t) thermal_events_total;

        uint64_t reserved0;
    };
    uint8_t raw[64];
} cl_board_hot_64b_t;

CL_STATIC_ASSERT(sizeof(cl_board_hot_64b_t) == 64, "board hot b 64");

/* WARM A 64 (fans/rails) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) fan_rpm_0;
        _Atomic(uint32_t) fan_rpm_1;
        _Atomic(uint32_t) fan_rpm_2;
        _Atomic(uint32_t) fan_rpm_3;

        _Atomic(uint32_t) v12_mv;
        _Atomic(uint32_t) v5_mv;

        _Atomic(uint32_t) vrm_supported;
        _Atomic(uint32_t) ripple_supported;

        uint64_t reserved0;
    };
    uint8_t raw[64];
} cl_board_warm_64a_t;

CL_STATIC_ASSERT(sizeof(cl_board_warm_64a_t) == 64, "board warm a 64");

/* WARM B 64 (feature states) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint16_t) vrm_state;     /* cl_feature_state_t */
        _Atomic(uint16_t) ripple_state;  /* cl_feature_state_t */
        _Atomic(uint16_t) pwr_state;     /* cl_feature_state_t */
        _Atomic(uint16_t) therm_state;   /* cl_feature_state_t */

        _Atomic(uint32_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
        _Atomic(uint64_t) reserved4;
    };
    uint8_t raw[64];
} cl_board_warm_64b_t;

CL_STATIC_ASSERT(sizeof(cl_board_warm_64b_t) == 64, "board warm b 64");

/* COLD 64 (Inventory strings: vendor/model/serial) */
typedef union CL_ALIGNAS(8) {
    struct {
        char vendor[16];
        char model[16];
        char serial[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;

        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_board_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_board_cold_64_t) == 64, "board cold 64");

/* RSV lines */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_board_rsv_64_t;

typedef struct CL_ALIGNAS(512) {
    cl_board_hot_64a_t  hot_a;
    cl_board_hot_64b_t  hot_b;
    cl_board_warm_64a_t warm_a;
    cl_board_warm_64b_t warm_b;
    cl_board_cold_64_t  cold;
    cl_board_rsv_64_t   rsv0;
    cl_board_rsv_64_t   rsv1;
    cl_board_rsv_64_t   rsv2;
} cl_board_seg_512_t;

CL_STATIC_ASSERT(sizeof(cl_board_seg_512_t) == 512, "board seg 512");


<<< END FILE: ./include/cl_runtime/cl_seg_board_512.h

>>> START FILE: ./include/cl_runtime/cl_seg_budget_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Budget (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_budget_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - zeigt verfügbares RAM, staging caps, pressure, reclaim events
 * - zeigt, ob CL gerade aggressiv Ressourcen nutzt oder zurückzieht
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) budget_state;          /* cl_budget_state_t */
        _Atomic(uint32_t) interactive_hint;      /* 0/1 */

        _Atomic(uint32_t) cpu_pressure_permille; /* 0..1000 */
        _Atomic(uint32_t) mem_pressure_permille; /* 0..1000 */

        _Atomic(uint64_t) total_ram_bytes;       /* best-effort */
        _Atomic(uint64_t) free_ram_bytes;        /* best-effort */

        _Atomic(uint64_t) bulk_bytes_current;
        _Atomic(uint64_t) bulk_bytes_cap;
    };
    uint8_t raw[64];
} cl_budget_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_budget_hot_64_t) == 64, "budget hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) reclaim_events;
        _Atomic(uint64_t) shadow_events;
        _Atomic(uint64_t) user_activity_events;

        _Atomic(uint64_t) mem_reclaim_ns;

        _Atomic(uint32_t) io_pressure_permille;  /* best-effort */
        _Atomic(uint32_t) storage_pressure_permille; /* disk sink/backlog */

        _Atomic(uint64_t) last_pressure_ts_ns;
        _Atomic(uint64_t) reserved0;
    };
    uint8_t raw[64];
} cl_budget_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_budget_warm_64_t) == 64, "budget warm 64");

/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;

        uint32_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
        uint64_t reserved6;
    };
    uint8_t raw[64];
} cl_budget_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_budget_cold_64_t) == 64, "budget cold 64");

/* RSV 64 (append-only space) */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_budget_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_budget_hot_64_t  hot;
    cl_budget_warm_64_t warm;
    cl_budget_cold_64_t cold;
    cl_budget_rsv_64_t  rsv;
} cl_budget_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_budget_seg_256_t) == 256, "budget seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_budget_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_cpu_1024.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: CPU Core (1024B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_cpu_1024.h
 * ============================================================================
 *
 * Record = 16 Cachelines à 64B.
 * Maximalmodell:
 * - ISA possible/effective/state
 * - Thermik/Throttle/Headroom (state+reason)
 * - Hersteller/Modell/µcode (COLD strings)
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "../cl_manifest/cl_features.h"
#include "cl_quality.h"

/* HOT 0 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) tsc_val;
        _Atomic(uint64_t) last_update_ns;

        _Atomic(uint32_t) local_seq;
        _Atomic(uint32_t) load_permille;

        _Atomic(uint32_t) temp_c_x10;
        _Atomic(uint32_t) throttling;       /* 0/1 */

        _Atomic(uint32_t) headroom_permille;/* best-effort */
        _Atomic(uint32_t) reason_code;      /* cl_reason_code_t */

        _Atomic(uint32_t) constraint_flags; /* thermal/power/budget */
        _Atomic(uint32_t) reserved0;
    };
    uint8_t raw[64];
} cl_cpu_hot_64a_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_hot_64a_t)==64, "cpu hot 64a");

/* HOT 1 (ISA) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) isa_possible_mask;  /* cl_cpu_isa_mask_t */
        _Atomic(uint32_t) isa_effective;      /* cl_cpu_isa_effective_t */

        _Atomic(uint16_t) isa_state;          /* cl_feature_state_t */
        _Atomic(uint16_t) avx512_risk;        /* cl_avx512_risk_t (manifest) */
        _Atomic(uint16_t) simd_effective;     /* cl_simd_effective_t (manifest) */
        _Atomic(uint16_t) reserved0;

        _Atomic(uint64_t) inst_retired;
        _Atomic(uint64_t) cycles;

        _Atomic(uint64_t) uops_issued;
        _Atomic(uint64_t) uops_stalled;
    };
    uint8_t raw[64];
} cl_cpu_hot_64b_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_hot_64b_t)==64, "cpu hot 64b");

/* WARM lines 2..7 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) l1d_misses;
        _Atomic(uint64_t) itlb_misses;
        _Atomic(uint64_t) dtlb_misses;
        _Atomic(uint64_t) llc_misses;

        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
    };
    uint8_t raw[64];
} cl_cpu_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_warm_64_t)==64, "cpu warm 64");

/* COLD 8 (IDs) */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t vendor_id;
        uint32_t device_id;
        uint32_t model_id;
        uint32_t stepping;

        uint32_t numa_node;
        uint32_t reserved0;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
        uint32_t reserved2;

        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_cpu_cold_64a_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_cold_64a_t)==64, "cpu cold 64a");

/* COLD 9 (strings vendor/model) Teil 1*/
typedef union CL_ALIGNAS(8) {
    struct {
        char vendor_str[16];   /* "GenuineIntel" etc */
        char model_str_a[16];  /* Modelname Teil A */
        char model_str_b[16];  /* Modelname Teil B */

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_cpu_cold_64b_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_cold_64b_t)==64, "cpu cold 64b");

/* COLD 10 (strings) TEIL 2 */
typedef union CL_ALIGNAS(8) {
    struct {
        char model_str_c[32];  /* Modelname Teil C (weitere 32 Zeichen) */
        char ucode_str[16];    /* Microcode/Revision kurz */
        
        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_cpu_cold_64c_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_cold_64c_t)==64, "cpu cold 64c");

/* COLD 11..15 reserved/topology */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_cpu_cold_64r_t;
CL_STATIC_ASSERT(sizeof(cl_cpu_cold_64r_t)==64, "cpu cold r 64");

/* Record 1024 */
typedef struct CL_ALIGNAS(1024) {
    cl_cpu_hot_64a_t hot_a;           /* 0 */
    cl_cpu_hot_64b_t hot_b;           /* 1 */
    cl_cpu_warm_64_t warm[6];         /* 2..7 */
    cl_cpu_cold_64a_t cold_a;         /* 8 */
    cl_cpu_cold_64b_t cold_b;         /* 9 */
    cl_cpu_cold_64c_t cold_c;         /* 9 */
    cl_cpu_cold_64r_t cold_r[5];      /* 11..15 */
} cl_cpu_seg_1024_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_seg_1024_t)==1024, "cpu seg 1024");


<<< END FILE: ./include/cl_runtime/cl_seg_cpu_1024.h

>>> START FILE: ./include/cl_runtime/cl_seg_dma_4096.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: DMA Meta (4096B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_dma_4096.h
 * ============================================================================
 *
 * Zweck:
 *   - RX/TX Ring Meta, Slot Meta; Payload liegt backend-spezifisch außerhalb SHM.
 *
 * Maximalmodell:
 *   - alignment/headroom/atom geometry sichtbar
 *   - crc/fec counters sichtbar
 *
 * Layout:
 *   4096B = 64 Cachelines:
 *     RX hdr: 4 lines (256B)
 *     TX hdr: 4 lines (256B)
 *     Slot meta: 56 lines
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* Slot state */
typedef enum { CL_DMA_SLOT_FREE=0, CL_DMA_SLOT_BUSY=1, CL_DMA_SLOT_READY=2 } cl_dma_slot_state_t;

/* Ring header line 64B */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) ring_size;
        _Atomic(uint32_t) ring_mask;
        _Atomic(uint32_t) head;
        _Atomic(uint32_t) tail;

        _Atomic(uint64_t) slots_ready;
        _Atomic(uint64_t) slots_busy;

        _Atomic(uint32_t) alignment_bytes;     /* expected 64 */
        _Atomic(uint32_t) headroom_bytes;      /* expected 64 */

        _Atomic(uint32_t) payload_quantum_bytes; /* 64 */
        _Atomic(uint32_t) reserved0;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
        uint32_t reserved2;
    };
    uint8_t raw[64];
} cl_dma_ring_hdr_64_t;

CL_STATIC_ASSERT(sizeof(cl_dma_ring_hdr_64_t)==64, "dma ring hdr 64");

/* Slot meta line 64B */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) seq;
        _Atomic(uint64_t) ts_ns;
        _Atomic(uint64_t) opaque_ref64;  /* UMEM offset / netmap token / ptr */
        _Atomic(uint64_t) reserved0;

        _Atomic(uint32_t) state;         /* cl_dma_slot_state_t */
        _Atomic(uint32_t) payload_len;

        _Atomic(uint32_t) crc32c;        /* optional: per-slot/atom CRC summary */
        _Atomic(uint32_t) reserved1;

        _Atomic(uint64_t) reserved2;
    };
    uint8_t raw[64];
} cl_dma_slot_meta_64_t;

CL_STATIC_ASSERT(sizeof(cl_dma_slot_meta_64_t)==64, "dma slot meta 64");

/* Segment 4096 */
typedef struct CL_ALIGNAS(4096) {
    cl_dma_ring_hdr_64_t rx_hdr[4];
    cl_dma_ring_hdr_64_t tx_hdr[4];
    cl_dma_slot_meta_64_t slot[56];
} cl_dma_seg_4096_t;

CL_STATIC_ASSERT(sizeof(cl_dma_seg_4096_t)==4096, "dma seg 4096");


<<< END FILE: ./include/cl_runtime/cl_seg_dma_4096.h

>>> START FILE: ./include/cl_runtime/cl_seg_forensics_4096.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Forensics (4096B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_forensics_4096.h
 * ============================================================================
 *
 * Zweck:
 *   - Ringbuffer seltener, hochrelevanter Events.
 *   - Maximalmodell: commit_epoch + grant_id + reason/constraints immer dabei.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* Forensics Event IDs (append-only) */
typedef enum {
    CL_FX_NONE = 0,

    /* Discovery / Join */
    CL_FX_BEACON_SEEN = 100,
    CL_FX_HELLO_SENT = 101,
    CL_FX_HELLO_ACK_RX = 102,
    CL_FX_AUTH_FAIL = 110,
    CL_FX_REPLAY_DETECTED = 111,
    CL_FX_VERSION_MISMATCH = 112,
    CL_FX_MESH_MISMATCH = 113,
    CL_FX_IP_COLLISION = 114,
    CL_FX_TRUSTED_ACTIVE = 120,
    CL_FX_DENIED = 121,

    /* Grants / Credits */
    CL_FX_GRANT_RX = 200,
    CL_FX_GRANT_EXPIRED = 201,
    CL_FX_CREDIT_STARVATION = 202,

    /* Autopath */
    CL_FX_BACKEND_UPGRADE = 300,
    CL_FX_BACKEND_DOWNGRADE = 301,
    CL_FX_TCP_FALLBACK = 302
} cl_forensics_event_id_t;

/* Event 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) ts_ns;
        _Atomic(uint64_t) commit_epoch;
        _Atomic(uint64_t) grant_id;
        _Atomic(uint64_t) param1;

        _Atomic(uint32_t) event_id;
        _Atomic(uint32_t) reason_code;

        _Atomic(uint32_t) constraint_flags;
        _Atomic(uint32_t) aux;

        _Atomic(uint64_t) param2;
        _Atomic(uint64_t) param3;
    };
    uint8_t raw[64];
} cl_forensics_event_64_t;

CL_STATIC_ASSERT(sizeof(cl_forensics_event_64_t)==64, "forensics event 64");

/* Header 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) head;
        _Atomic(uint32_t) tail;
        _Atomic(uint32_t) mask;      /* 63 */
        _Atomic(uint32_t) dropped;

        _Atomic(uint64_t) last_event_ns;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;

        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
    };
    uint8_t raw[64];
} cl_forensics_hdr_64_t;

CL_STATIC_ASSERT(sizeof(cl_forensics_hdr_64_t)==64, "forensics hdr 64");

typedef struct CL_ALIGNAS(4096) {
    cl_forensics_hdr_64_t hdr;
    cl_forensics_event_64_t ev[63];
} cl_forensics_seg_4096_t;

CL_STATIC_ASSERT(sizeof(cl_forensics_seg_4096_t)==4096, "forensics seg 4096");


<<< END FILE: ./include/cl_runtime/cl_seg_forensics_4096.h

>>> START FILE: ./include/cl_runtime/cl_seg_history_4096.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: History (4096B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_history_4096.h
 * ============================================================================
 *
 * Zweck:
 *   - Oracle Trenddaten (eine Metrik pro Segmentinstanz).
 *   - Maximalmodell: Trends werden als Werte+Quelle/Qualität abgebildet.
 *
 * Layout:
 *   Header 64B + 63 Points à 64B.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "cl_quality.h"

/* Metric IDs (extend-only) */
typedef enum {
    CL_HIST_TX_BPS = 1,
    CL_HIST_RX_BPS = 2,
    CL_HIST_LOSS_PPM = 3,
    CL_HIST_JITTER_P99_US = 4,
    CL_HIST_CPU_PRESSURE = 5,
    CL_HIST_MEM_PRESSURE = 6,
    CL_HIST_STORAGE_SINK = 7,
    CL_HIST_THERMAL = 8
} cl_hist_metric_id_t;

/* Header 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) metric_id;
        _Atomic(uint32_t) write_idx;
        _Atomic(uint32_t) count;
        _Atomic(uint32_t) reserved0;

        _Atomic(uint64_t) last_ts_ns;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
        uint32_t reserved2;

        uint64_t reserved3;
        uint64_t reserved4;
    };
    uint8_t raw[64];
} cl_hist_hdr_64_t;

CL_STATIC_ASSERT(sizeof(cl_hist_hdr_64_t)==64, "hist hdr 64");

/* Point 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) ts_ns;
        _Atomic(uint64_t) value;
        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
        _Atomic(uint64_t) reserved4;
        _Atomic(uint64_t) reserved5;
    };
    uint8_t raw[64];
} cl_hist_point_64_t;

CL_STATIC_ASSERT(sizeof(cl_hist_point_64_t)==64, "hist point 64");

typedef struct CL_ALIGNAS(4096) {
    cl_hist_hdr_64_t hdr;
    cl_hist_point_64_t pts[63];
} cl_history_seg_4096_t;

CL_STATIC_ASSERT(sizeof(cl_history_seg_4096_t)==4096, "history seg 4096");


<<< END FILE: ./include/cl_runtime/cl_seg_history_4096.h

>>> START FILE: ./include/cl_runtime/cl_seg_link_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Link Summary (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_link_256.h
 * ============================================================================
 *
 * Record = 4 Cachelines à 64B:
 *   HOT   : effektiver Pfad/Backend/Mode/Profile + pacing/tick/mtu/batch + reasons
 *   WARM A: commit epochs + throughput totals + starvation + partials
 *   WARM B: Zero-Transform Geometrie + Accept + FEC/CRC/PHV + Compression + States
 *   COLD  : desired targets (policy) + src/qual
 *
 * Maximalmodell:
 *   - possible/effective/state für Integrity (CRC/FEC) und Zero-Transform
 *   - keine impliziten Defaults
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) path_state;        /* cl_path_state_t */
        _Atomic(uint32_t) backend_active;    /* cl_backend_active_t */
        _Atomic(uint32_t) backend_detail;    /* cl_backend_detail_t */
        _Atomic(uint32_t) profile_effective; /* cl_transfer_profile_t */

        _Atomic(uint32_t) mode_active;       /* cl_link_mode_t */
        _Atomic(uint32_t) constraint_flags;  /* cl_constraint_flags_t */
        _Atomic(uint32_t) reason_code;       /* cl_reason_code_t */
        _Atomic(uint32_t) global_health;     /* CL_HEALTH_* summary */

        _Atomic(uint32_t) pacing_actual_bps; /* smoothed */
        _Atomic(uint32_t) pacing_target_bps;

        _Atomic(uint32_t) tick_budget_us;

        _Atomic(uint16_t) mtu_effective;
        _Atomic(uint16_t) batch_target;

        /* last 4 bytes */
        _Atomic(uint32_t) batch_eff_permille; /* 0..1000 */
    };
    uint8_t raw[64];
} cl_link_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_link_hot_64_t) == 64, "link hot 64");

/* WARM A 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_commit_epoch;

        _Atomic(uint64_t) bytes_sent_1s;
        _Atomic(uint64_t) pkts_sent_1s;

        _Atomic(uint64_t) bytes_sent_total;
        _Atomic(uint64_t) pkts_sent_total;

        _Atomic(uint64_t) inject_partial_cnt;
        _Atomic(uint64_t) prepare_expired_cnt;
        _Atomic(uint64_t) credit_starvation_ns;
    };
    uint8_t raw[64];
} cl_link_warm_64a_t;

CL_STATIC_ASSERT(sizeof(cl_link_warm_64a_t) == 64, "link warm a 64");

/* WARM B 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        /* Zero-Transform / Atom-Geometry (Truth) */
        _Atomic(uint32_t) payload_quantum_bytes;   /* default 64 */
        _Atomic(uint32_t) payload_headroom_bytes;  /* negotiated/setup */

        /* Transfer Semantik */
        _Atomic(uint32_t) accept_mode;             /* cl_accept_mode_t */
        _Atomic(uint32_t) durable_granularity_bytes;

        /* Integrity: possible/effective/state */
        _Atomic(uint32_t) crc_mode_possible;       /* bitmask over cl_crc_mode_t */
        _Atomic(uint32_t) fec_mode_possible;       /* bitmask over cl_fec_mode_t */

        _Atomic(uint32_t) crc_mode_effective;      /* cl_crc_mode_t */
        _Atomic(uint32_t) fec_mode_effective;      /* cl_fec_mode_t */

        /* FEC parameters */
        _Atomic(uint16_t) fec_n;                   /* atoms per block */
        _Atomic(uint16_t) fec_k;                   /* parity atoms */
        _Atomic(uint16_t) crc_state;               /* cl_feature_state_t (fits u16) */
        _Atomic(uint16_t) fec_state;               /* cl_feature_state_t */

        /* Predict-Verify Gate state (optional) */
        _Atomic(uint16_t) phv_state;               /* cl_feature_state_t */
        uint16_t reserved0;

        /* Compression ladder (effective) */
        _Atomic(uint32_t) comp_mode;               /* cl_comp_mode_t */
    };
    uint8_t raw[64];
} cl_link_warm_64b_t;

CL_STATIC_ASSERT(sizeof(cl_link_warm_64b_t) == 64, "link warm b 64");

/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t profile_desired;
        uint32_t backend_desired;
        uint32_t mode_desired;
        uint32_t reserved0;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;

        uint32_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_link_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_link_cold_64_t) == 64, "link cold 64");

typedef struct CL_ALIGNAS(256) {
    cl_link_hot_64_t   hot;
    cl_link_warm_64a_t warm_a;
    cl_link_warm_64b_t warm_b;
    cl_link_cold_64_t  cold;
} cl_link_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_link_seg_256_t) == 256, "link seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_link_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_mem_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Memory (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_mem_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - total/free/used/ecc
 * - memory bandwidth hints (best-effort)
 * - DIMM mode strings optional via reserved/bulk later
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) total_bytes;
        _Atomic(uint64_t) used_bytes;
        _Atomic(uint64_t) free_bytes;
        _Atomic(uint64_t) ecc_err_cnt;

        _Atomic(uint32_t) pressure_permille;
        _Atomic(uint32_t) reason_code;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
    };
    uint8_t raw[64];
} cl_mem_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_mem_hot_64_t)==64, "mem hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) bw_read_bps;
        _Atomic(uint64_t) bw_write_bps;

        _Atomic(uint32_t) timing_tcl;
        _Atomic(uint32_t) timing_trcd;
        _Atomic(uint32_t) timing_trp;
        _Atomic(uint32_t) timing_tras;

        _Atomic(uint32_t) channel_state; /* cl_feature_state_t */
        _Atomic(uint32_t) reserved0;

        _Atomic(uint64_t) last_update_ns;
    };
    uint8_t raw[64];
} cl_mem_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_mem_warm_64_t)==64, "mem warm 64");

/* COLD 64 (inventory strings) */
typedef union CL_ALIGNAS(8) {
    struct {
        char dimm_mode[16];    /* "DDR4-2133" / "XMP" etc best-effort */
        char channel_mode[16]; /* "DUAL" "SINGLE" etc */
        char reserved_str[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;

        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_mem_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_mem_cold_64_t)==64, "mem cold 64");

/* RSV 64 */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_mem_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_mem_hot_64_t  hot;
    cl_mem_warm_64_t warm;
    cl_mem_cold_64_t cold;
    cl_mem_rsv_64_t  rsv;
} cl_mem_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_mem_seg_256_t)==256, "mem seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_mem_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_mesh_neighbor_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Mesh Neighbor HOT (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_mesh_neighbor_256.h
 * ============================================================================
 *
 * 32 Hot Neighbor Records (CL_MESH_HOT_NEIGHBORS) sind Ziel.
 * Maximalmodell: trust/state/negotiated/why + source/quality.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "../cl_manifest/cl_ids.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_seen_ns;

        _Atomic(uint32_t) trust_state;     /* cl_peer_trust_state_t */
        _Atomic(uint32_t) peer_state;      /* cl_peer_state_t */

        uint32_t peer_overlay_ip;
        uint32_t mtu_negotiated;

        uint32_t backend_active;           /* cl_backend_active_t */
        uint32_t profile_effective;        /* cl_transfer_profile_t */

        uint32_t loss_ppm;
        uint32_t jitter_p99_us;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
    };
    uint8_t raw[64];
} cl_mesh_neighbor_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_neighbor_hot_64_t) == 64, "mesh neighbor hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t ports_count;
        uint32_t link_speed_mbps;
        uint64_t rx_window_bytes;
        uint64_t drain_bps;

        uint32_t constraint_flags;
        uint32_t reason_code;

        uint16_t payload_quantum_bytes;
        uint16_t payload_headroom_bytes;
        uint16_t fec_n;
        uint16_t fec_k;

        uint32_t crc_mode_effective;
        uint32_t fec_mode_effective;
    };
    uint8_t raw[64];
} cl_mesh_neighbor_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_neighbor_warm_64_t) == 64, "mesh neighbor warm 64");

/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        cl_node_tag64_t node_tag64;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;

        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_mesh_neighbor_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_neighbor_cold_64_t) == 64, "mesh neighbor cold 64");

/* RSV 64 */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_mesh_neighbor_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_mesh_neighbor_hot_64_t  hot;
    cl_mesh_neighbor_warm_64_t warm;
    cl_mesh_neighbor_cold_64_t cold;
    cl_mesh_neighbor_rsv_64_t  rsv;
} cl_mesh_neighbor_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_neighbor_seg_256_t) == 256, "mesh neighbor seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_mesh_neighbor_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_mesh_peer_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Mesh Peer (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_mesh_peer_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - Trust (state + last_event + denied_reason)
 * - Negotiation (geometry + integrity)
 * - Credits (pkts/bytes) + durable progress
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "../cl_manifest/cl_ids.h"
#include "../cl_manifest/cl_trust.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_seen_ns;
        _Atomic(uint64_t) last_oob_rx_ns;

        _Atomic(uint32_t) trust_state;       /* cl_peer_trust_state_t */
        _Atomic(uint32_t) peer_state;        /* cl_peer_state_t */

        _Atomic(uint32_t) peer_overlay_ip;
        _Atomic(uint32_t) route_state;       /* cl_overlay_route_state_t (numeric) */

        _Atomic(uint32_t) constraint_flags;
        _Atomic(uint32_t) reason_code;

        _Atomic(uint32_t) trust_last_event;   /* cl_trust_event_id_t */
        _Atomic(uint32_t) trust_denied_reason;/* cl_reason_code_t subset */

        uint64_t reserved0;
    };
    uint8_t raw[64];
} cl_mesh_peer_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_hot_64_t) == 64, "mesh peer hot 64");

/* WARM A 64 (negotiated) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) rx_window_bytes;
        _Atomic(uint64_t) drain_bps;

        _Atomic(uint32_t) mtu_negotiated;
        _Atomic(uint32_t) ports_count;

        _Atomic(uint32_t) profile_allowed_mask;
        _Atomic(uint32_t) backend_allowed_mask;

        _Atomic(uint32_t) payload_quantum_bytes;
        _Atomic(uint32_t) payload_headroom_bytes;
    };
    uint8_t raw[64];
} cl_mesh_peer_warm_64a_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_warm_64a_t) == 64, "mesh peer warm a 64");

/* WARM B 64 (credits + accept/integrity progress) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) grant_id;
        _Atomic(uint64_t) refill_epoch;

        _Atomic(uint32_t) grant_ttl_ms;
        _Atomic(uint32_t) grant_age_ms;

        _Atomic(uint64_t) credits_pkts;
        _Atomic(uint64_t) credits_bytes;

        _Atomic(uint32_t) accept_mode;        /* cl_accept_mode_t */
        _Atomic(uint32_t) durable_lag_bytes;

        _Atomic(uint64_t) durable_commit_epoch;
        _Atomic(uint64_t) reserved0;
    };
    uint8_t raw[64];
} cl_mesh_peer_warm_64b_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_warm_64b_t) == 64, "mesh peer warm b 64");

/* WARM C 64 (Join/Replay/Rate-Limit – gedämpft, monitor-sichtbar) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) last_oob_epoch_seen;  /* lower 32 bits of last accepted epoch */
        _Atomic(uint32_t) replay_hits_total;

        _Atomic(uint32_t) join_attempts_total;
        _Atomic(uint32_t) join_rejects_total;

        _Atomic(uint32_t) rate_limited_total;
        _Atomic(uint32_t) reserved0;

        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
        _Atomic(uint64_t) reserved4;
        _Atomic(uint64_t) reserved5;
    };
    uint8_t raw[64];
} cl_mesh_peer_warm_64c_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_warm_64c_t) == 64, "mesh peer warm c 64");


/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        cl_mesh_tag64_t mesh_tag64;
        cl_node_tag64_t node_tag64;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;

        uint64_t reserved2;
        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_mesh_peer_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_cold_64_t) == 64, "mesh peer cold 64");

typedef struct CL_ALIGNAS(256) {
    cl_mesh_peer_hot_64_t   hot;
    cl_mesh_peer_warm_64a_t warm_a;
    cl_mesh_peer_warm_64b_t warm_b;
    cl_mesh_peer_cold_64_t  cold;
} cl_mesh_peer_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_seg_256_t) == 256, "mesh peer seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_mesh_peer_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_nic_512.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: NIC (512B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_nic_512.h
 * ============================================================================
 *
 * Record = 8 Cachelines.
 * Maximalmodell:
 * - Ports/Queues/Caps possible/effective/state
 * - DOM/SFP inventory strings (vendor/part/serial) + thresholds
 * - Loss/Jitter/Burst + reasons
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) rx_bps;
        _Atomic(uint64_t) tx_bps;

        _Atomic(uint32_t) local_seq;
        _Atomic(uint32_t) link_speed_mbps;

        _Atomic(uint16_t) mtu_effective;
        _Atomic(uint16_t) mtu_max;
        _Atomic(uint16_t) mtu_min;
        _Atomic(uint16_t) ports_count;

        _Atomic(uint32_t) queues_count;
        _Atomic(uint32_t) reason_code;

        _Atomic(uint32_t) constraint_flags;
        _Atomic(uint32_t) reserved0;
    };
    uint8_t raw[64];
} cl_nic_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_nic_hot_64_t)==64, "nic hot 64");

/* WARM A 64 (queues/drops) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) rx_queue_fill_permille;
        _Atomic(uint32_t) tx_queue_fill_permille;
        _Atomic(uint32_t) rx_dropped;
        _Atomic(uint32_t) tx_dropped;
        _Atomic(uint32_t) rx_overruns;
        _Atomic(uint32_t) tx_overruns;
        _Atomic(uint32_t) reorder_events;
        _Atomic(uint32_t) burst_max;          /* max consecutive losses (warm) */

        _Atomic(uint32_t) crc_fail_1s;        /* atoms/packets */
        _Atomic(uint32_t) crc_fail_total;

        _Atomic(uint32_t) fec_recover_1s;
        _Atomic(uint32_t) fec_recover_total;
    };
    uint8_t raw[64];
} cl_nic_warm_64a_t;

CL_STATIC_ASSERT(sizeof(cl_nic_warm_64a_t)==64, "nic warm a 64");

/* WARM B 64 (DOM/thermal) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) dom_temp_c_x10;
        _Atomic(uint32_t) dom_warn_c_x10;
        _Atomic(uint32_t) dom_crit_c_x10;
        _Atomic(uint32_t) dom_alarm_bits;

        _Atomic(uint32_t) thermal_state;        /* cl_thermal_state_t */
        _Atomic(uint32_t) pacing_scale_permille;/* 1000/950/700/0 */

        _Atomic(uint16_t) dom_state;            /* cl_feature_state_t */
        _Atomic(uint16_t) reserved0;
        _Atomic(uint32_t) reserved1;

        _Atomic(uint32_t) loss_ppm;
        _Atomic(uint32_t) jitter_p99_us;
    };
    uint8_t raw[64];
} cl_nic_warm_64b_t;

CL_STATIC_ASSERT(sizeof(cl_nic_warm_64b_t)==64, "nic warm b 64");

/* WARM C 64 (aggregation + backend/profile) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) group_id;
        _Atomic(uint32_t) active_ports_mask;

        _Atomic(uint32_t) backend_state;
        _Atomic(uint32_t) backend_active;

        _Atomic(uint32_t) profile_effective;
        _Atomic(uint32_t) constraint_flags;

        _Atomic(uint32_t) reason_code;
        _Atomic(uint32_t) reserved0;

        _Atomic(uint64_t) link_down_events;
        _Atomic(uint64_t) mtu_reneg_events;
    };
    uint8_t raw[64];
} cl_nic_warm_64c_t;

CL_STATIC_ASSERT(sizeof(cl_nic_warm_64c_t)==64, "nic warm c 64");

/* COLD A 64 (PCI identity + names) */
typedef union CL_ALIGNAS(8) {
    struct {
        uint16_t pci_vendor_id;
        uint16_t pci_device_id;
        uint16_t pci_domain;
        uint16_t reserved0;

        uint8_t pci_bus;
        uint8_t pci_dev;
        uint8_t pci_func;
        uint8_t reserved1;

        char iface_name[16];
        char driver_name[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved2;

        uint32_t reserved3;
        uint64_t reserved4;
    };
    uint8_t raw[64];
} cl_nic_cold_64a_t;

CL_STATIC_ASSERT(sizeof(cl_nic_cold_64a_t)==64, "nic cold a 64");

/* COLD B 64 (caps/state) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) caps_zerocopy;
        _Atomic(uint32_t) caps_rdma;

        _Atomic(uint16_t) bypass_state;   /* cl_feature_state_t */
        _Atomic(uint16_t) rdma_state;     /* cl_feature_state_t */
        _Atomic(uint16_t) rss_state;      /* cl_feature_state_t */
        _Atomic(uint16_t) flow_dir_state; /* cl_feature_state_t */

        _Atomic(uint32_t) backend_possible_mask; /* bitmask cl_backend_active_t */
        _Atomic(uint32_t) reserved0;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;

        uint32_t reserved2;
        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_nic_cold_64b_t;

CL_STATIC_ASSERT(sizeof(cl_nic_cold_64b_t)==64, "nic cold b 64");

/* COLD C 64 (SFP strings) */
typedef union CL_ALIGNAS(8) {
    struct {
        char sfp_vendor[16];
        char sfp_part[16];
        char sfp_serial[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;

        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_nic_cold_64c_t;

CL_STATIC_ASSERT(sizeof(cl_nic_cold_64c_t)==64, "nic cold c 64");

/* Record 512 */
typedef struct CL_ALIGNAS(512) {
    cl_nic_hot_64_t    hot;
    cl_nic_warm_64a_t  warm_a;
    cl_nic_warm_64b_t  warm_b;
    cl_nic_warm_64c_t  warm_c;
    cl_nic_cold_64a_t  cold_a;
    cl_nic_cold_64b_t  cold_b;
    cl_nic_cold_64c_t  cold_c;
    /* reserved line for future */
    uint8_t            rsv[64];
} cl_nic_seg_512_t;

CL_STATIC_ASSERT(sizeof(cl_nic_seg_512_t)==512, "nic seg 512");


<<< END FILE: ./include/cl_runtime/cl_seg_nic_512.h

>>> START FILE: ./include/cl_runtime/cl_seg_oracle_256.h
#pragma once
/* ============================================================================
 * CommanderLink – ORACLE Segment (Runtime) – FINAL v1
 * Datei: include/cl_runtime/cl_seg_oracle_256.h
 * ============================================================================
 *
 * Zweck:
 *   - Single Source of Truth für "Warum skaliert CL gerade so?" (Oracle Output)
 *   - Liefert Monitor/Daemon:
 *       * effektive Entscheidung (Backend/Compression/CRC/FEC/Worker)
 *       * Primärgrund (Reason) + Constraints
 *       * Telemetrie (Rates, Backlog, Kostenindikatoren)
 *
 * Maschinenregeln (No-UB / Physik-Regel):
 *   - Alle Felder, die während Laufzeit beschrieben und parallel gelesen werden,
 *     sind _Atomic (C11), damit es keine Data Races / UB gibt.
 *   - Writer-Publish:
 *       1) warm/hot Felder (relaxed stores)
 *       2) oracle_epoch++ als "Publish Barrier" (store-release)
 *   - Reader-Snapshot:
 *       1) e0 = oracle_epoch (load-acquire)
 *       2) Felder lesen (relaxed loads)
 *       3) e1 = oracle_epoch (load-acquire)
 *       4) nur gültig, wenn e0 == e1
 *
 * Layout:
 *   - 256B pro Record, exakt.
 *   - Hot 64B (sehr häufig), Warm 128B (häufig), Cold 64B (immutable config).
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"

/* ----------------------------------------------------------------------------
 * HOT (64B) – "Effektive Entscheidung + Primärgrund"
 * ---------------------------------------------------------------------------- */
typedef union CL_ALIGNAS(64) {
    struct {
        _Atomic uint64_t oracle_epoch;            /* monotone publish epoch */
        _Atomic uint64_t last_decision_ns;        /* monotone timestamp (ns) */

        _Atomic uint32_t scale_reason_u32;        /* cl_reason_code_t (primary) */
        _Atomic uint32_t constraint_flags_u32;    /* cl_constraint_flags_t (bitmask) */

        _Atomic uint32_t bottleneck_u32;          /* enum (NETWORK/CPU/DISK/OTHER) */
        _Atomic uint32_t worker_roles_mask_u32;   /* bitmask: RX/TX/COMP/CRC/FEC/WRITER */

        _Atomic uint16_t workers_phys_u16;        /* active physical cores */
        _Atomic uint16_t workers_ht_u16;          /* active SMT/HT threads */
        _Atomic uint16_t workers_total_u16;       /* phys + ht */

        _Atomic uint16_t isa_active_mask_u16;     /* bitmask: SSE4/AVX2/AVX512/... */
        _Atomic uint16_t backend_active_u16;      /* cl_backend_active_t */
        _Atomic uint16_t comp_level_u16;          /* compression ladder level */
        _Atomic uint16_t crc_mode_u16;            /* cl_crc_mode_t */
        _Atomic uint16_t fec_mode_u16;            /* cl_fec_mode_t */
        _Atomic uint16_t fec_n_u16;               /* N (data atoms) */
        _Atomic uint16_t fec_k_u16;               /* K (parity atoms) */

        uint8_t reserved_pad[12];                /* pad -> 64B */
    };
    uint8_t raw[64];
} cl_oracle_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_oracle_hot_64_t) == 64, "oracle hot muss 64B sein");

/* ----------------------------------------------------------------------------
 * WARM (128B) – Telemetrie & Kostenindikatoren (No-UB: alles atomic)
 * ---------------------------------------------------------------------------- */
typedef union CL_ALIGNAS(64) {
    struct {
        /* Totals (monotone counters) */
        _Atomic uint64_t rx_bytes_total;          /* payload bytes received */
        _Atomic uint64_t tx_bytes_total;          /* payload bytes sent */

        /* Rates (best-effort estimates) */
        _Atomic uint64_t rx_payload_bps;          /* app/payload throughput */
        _Atomic uint64_t tx_payload_bps;
        _Atomic uint64_t rx_wire_bps;             /* wire rate estimate */
        _Atomic uint64_t tx_wire_bps;

        /* Sink/Drain */
        _Atomic uint64_t disk_drain_bps;          /* storage drain rate estimate */

        /* Compression accounting */
        _Atomic uint64_t comp_in_bytes;           /* uncompressed bytes */
        _Atomic uint64_t comp_out_bytes;          /* compressed bytes */

        /* Cost proxy */
        _Atomic uint64_t cpu_cycles_per_byte;     /* cost indicator (oracle derived) */

        /* Ratios / backlog / modes */
        _Atomic uint32_t comp_ratio_permille;     /* e.g. 2450 => 2.45x */
        _Atomic uint32_t entropy_grade_u32;       /* oracle entropy class */
        _Atomic uint32_t rx_backlog_chunks;       /* backlog indicators */
        _Atomic uint32_t tx_backlog_chunks;

        /* Hardware states (oracle view) */
        _Atomic uint32_t thermal_state_u32;       /* cl_thermal_state_t */
        _Atomic uint32_t vrm_state_u32;           /* vendor/board normalized state */
        _Atomic uint32_t throttle_flags_u32;      /* cpu/nic throttle bits (normalized) */
        _Atomic uint32_t reserved0_u32;

        _Atomic int16_t  cpu_temp_c_x10;          /* 10x Celsius */
        _Atomic int16_t  nic_temp_c_x10;          /* 10x Celsius */
        uint8_t          reserved_pad[4];         /* align to 8 */

        _Atomic uint64_t reserved1_u64;           /* reserved for future */
    };
    uint8_t raw[128];
} cl_oracle_warm_128_t;

CL_STATIC_ASSERT(sizeof(cl_oracle_warm_128_t) == 128, "oracle warm muss 128B sein");

/* ----------------------------------------------------------------------------
 * COLD (64B) – Policy-/Konfig-Parameter (immutable after genesis)
 * ---------------------------------------------------------------------------- */
typedef union CL_ALIGNAS(64) {
    struct {
        uint32_t oracle_tick_ms;                  /* decision interval */
        uint32_t worker_max_phys;                 /* cap: physical workers */
        uint32_t worker_max_ht;                   /* cap: ht workers */

        uint32_t isa_allowed_mask_u32;            /* allowed ISA features */
        uint32_t backend_allowed_mask_u32;        /* allowed backends */
        uint32_t comp_allowed_mask_u32;           /* allowed compression modes */
        uint32_t crc_allowed_mask_u32;            /* allowed CRC modes */
        uint32_t fec_allowed_mask_u32;            /* allowed FEC modes */

        uint64_t reserved0_u64;
        uint64_t reserved1_u64;
        uint64_t reserved2_u64;
        uint64_t reserved3_u64;
    };
    uint8_t raw[64];
} cl_oracle_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_oracle_cold_64_t) == 64, "oracle cold muss 64B sein");

/* ----------------------------------------------------------------------------
 * ORACLE SEGMENT (256B)
 * ---------------------------------------------------------------------------- */
typedef union CL_ALIGNAS(64) {
    struct {
        cl_oracle_hot_64_t  hot;   /*  0.. 63 */
        cl_oracle_warm_128_t warm; /* 64..191 */
        cl_oracle_cold_64_t cold;  /* 192..255 */
    };
    uint8_t raw[256];
} cl_oracle_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_oracle_seg_256_t) == 256, "oracle seg muss 256B sein");


<<< END FILE: ./include/cl_runtime/cl_seg_oracle_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_overlay_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Overlay (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_overlay_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - Overlay ist Truth für Monitor: IP, ifname, prefix, state, routes, collision.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) overlay_state;     /* cl_feature_state_t */
        _Atomic(uint32_t) route_state;       /* cl_feature_state_t (global) */

        _Atomic(uint32_t) overlay_ip_host_u32;
        _Atomic(uint32_t) prefixlen;

        _Atomic(uint32_t) mtu_effective;
        _Atomic(uint32_t) active_routes;

        _Atomic(uint32_t) collision_offset;
        _Atomic(uint32_t) failopen_events;

        _Atomic(uint64_t) last_update_ns;
    };
    uint8_t raw[64];
} cl_overlay_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_overlay_hot_64_t) == 64, "overlay hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) routes_added_total;
        _Atomic(uint32_t) routes_removed_total;
        _Atomic(uint32_t) orphan_routes_total;
        _Atomic(uint32_t) collision_events_total;

        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
    };
    uint8_t raw[64];
} cl_overlay_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_overlay_warm_64_t) == 64, "overlay warm 64");

/* COLD 64 (if name) */
typedef union CL_ALIGNAS(8) {
    struct {
        char if_name[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;

        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_overlay_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_overlay_cold_64_t) == 64, "overlay cold 64");

typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_overlay_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_overlay_hot_64_t  hot;
    cl_overlay_warm_64_t warm;
    cl_overlay_cold_64_t cold;
    cl_overlay_rsv_64_t  rsv;
} cl_overlay_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_overlay_seg_256_t) == 256, "overlay seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_overlay_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_pcie_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: PCIe Summary (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_pcie_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - throughput + error counters
 * - vendor/device + human label (best-effort)
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) tx_bps;
        _Atomic(uint64_t) rx_bps;

        _Atomic(uint32_t) lcrc_err;
        _Atomic(uint32_t) tlp_retry;

        _Atomic(uint32_t) reason_code;
        _Atomic(uint32_t) constraint_flags;

        _Atomic(uint64_t) last_update_ns;
    };
    uint8_t raw[64];
} cl_pcie_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_pcie_hot_64_t)==64, "pcie hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) eye_margin_db_x100;
        _Atomic(uint32_t) lane_state; /* cl_feature_state_t */
        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
        _Atomic(uint64_t) reserved4;
        _Atomic(uint64_t) reserved5;
    };
    uint8_t raw[64];
} cl_pcie_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_pcie_warm_64_t)==64, "pcie warm 64");

/* COLD 64 (IDs + name) */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t vendor_id;
        uint32_t device_id;

        uint16_t domain;
        uint8_t bus;
        uint8_t dev;
        uint8_t func;
        uint8_t reserved0[3];

        char name[32]; /* best-effort short label */

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
    };
    uint8_t raw[64];
} cl_pcie_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_pcie_cold_64_t)==64, "pcie cold 64");

/* RSV 64 */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_pcie_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_pcie_hot_64_t  hot;
    cl_pcie_warm_64_t warm;
    cl_pcie_cold_64_t cold;
    cl_pcie_rsv_64_t  rsv;
} cl_pcie_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_pcie_seg_256_t)==256, "pcie seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_pcie_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_time_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Timebase (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_time_256.h
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) mono_now_ns;
        _Atomic(uint64_t) wall_now_ns;
        _Atomic(uint64_t) boot_id_ns;
        uint64_t reserved0;
        uint64_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
    };
    uint8_t raw[64];
} cl_time_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_time_hot_64_t) == 64, "time hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(int64_t)  clock_offset_ns;
        _Atomic(uint32_t) time_quality_ppb;
        uint32_t reserved0;
        uint64_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_time_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_time_warm_64_t) == 64, "time warm 64");

/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_time_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_time_cold_64_t) == 64, "time cold 64");

typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_time_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_time_hot_64_t  hot;
    cl_time_warm_64_t warm;
    cl_time_cold_64_t cold;
    cl_time_rsv_64_t  rsv;
} cl_time_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_time_seg_256_t) == 256, "time seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_time_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_watchdog_256.h
#pragma once
/*
 * ============================================================================
 * CommanderLink – WATCHDOG Segment (256B)
 * Datei: include/cl_runtime/cl_seg_watchdog_256.h
 * ============================================================================
 *
 * ZWECK
 *   - Selbstheilung: erkennt Stall/Panic und löst CL-Restart aus.
 *   - OS bleibt stabil (Fail-open): non-persistent Overlay, keine Default-Route.
 *
 * PHYSIK / ABI
 *   - Segment ist exakt 256B.
 *   - 4 Cacheline-Normflächen (64B) -> HOT_A, HOT_B, WARM, COLD.
 *   - Keine packed-Strukturen im SHM.
 *
 * OWNERSHIP
 *   - Writer: CORE aggregiert Zustände; Module schreiben nur ihre Tickmarker.
 *   - Reader: Monitor2 / Oracle.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "cl_quality.h"

/* -------------------------------------------------------------------------- */
/* Module IDs (für Stall/Restart Reason) – append-only                         */
/* -------------------------------------------------------------------------- */
typedef enum {
    CL_WD_MOD_NONE   = 0,
    CL_WD_MOD_HAL    = 1,
    CL_WD_MOD_CORE   = 2,
    CL_WD_MOD_FLOW   = 3,
    CL_WD_MOD_LINK   = 4,
    CL_WD_MOD_ORACLE = 5
} cl_wd_module_t;

/* -------------------------------------------------------------------------- */
/* Watchdog State                                                             */
/* -------------------------------------------------------------------------- */
typedef enum {
    CL_WD_OK    = 0,
    CL_WD_WARN  = 1,
    CL_WD_STALL = 2,
    CL_WD_PANIC = 3
} cl_wd_state_t;

/* -------------------------------------------------------------------------- */
/* Watchdog Reason Codes (append-only)                                        */
/* -------------------------------------------------------------------------- */
typedef enum {
    CL_WD_R_NONE = 0,

    /* Zeitbasierter Stall */
    CL_WD_R_STALL_HAL,
    CL_WD_R_STALL_CORE,
    CL_WD_R_STALL_FLOW,
    CL_WD_R_STALL_LINK,
    CL_WD_R_STALL_ORACLE,

    /* Integritäts-/Konsistenzverletzung (harte Gründe) */
    CL_WD_R_EPOCH_REGRESSION,
    CL_WD_R_GRANT_REPLAY,
    CL_WD_R_CREDITS_NEGATIVE,
    CL_WD_R_BACKEND_PANIC,
    CL_WD_R_INVARIANT_BREACH
} cl_wd_reason_t;

/* ============================================================================
 * HOT_A 64B: Liveness Marker (letztes Lebenszeichen je Modul)
 * ============================================================================
 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) hal_tick_ns;
        _Atomic(uint64_t) core_tick_ns;
        _Atomic(uint64_t) flow_tick_ns;
        _Atomic(uint64_t) link_tick_ns;
        _Atomic(uint64_t) oracle_tick_ns;

        uint8_t  src;
        uint8_t  qual;
        uint16_t reserved0;
        uint32_t reserved1;
    };
    uint8_t raw[64];
} cl_wd_hot_64a_t;

CL_STATIC_ASSERT(sizeof(cl_wd_hot_64a_t) == 64, "watchdog hot_a 64");

/* ============================================================================
 * HOT_B 64B: Progress Marker (Fortschritt, nicht nur Liveness)
 * ============================================================================
 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_progress_ns;      /* monotonic ns */
        _Atomic(uint64_t) last_commit_epoch;     /* Link commit epoch */
        _Atomic(uint64_t) last_root_seq_cnt;     /* Root seq snapshot */

        _Atomic(uint32_t) wd_state;              /* cl_wd_state_t */
        _Atomic(uint32_t) wd_reason;             /* cl_wd_reason_t */

        _Atomic(uint32_t) restart_count_total;   /* seit Boot */
        _Atomic(uint32_t) last_stall_module;     /* cl_wd_module_t */

        uint8_t  src;
        uint8_t  qual;
        uint16_t reserved0;
        uint32_t reserved1;
    };
    uint8_t raw[64];
} cl_wd_hot_64b_t;

CL_STATIC_ASSERT(sizeof(cl_wd_hot_64b_t) == 64, "watchdog hot_b 64");

/* ============================================================================
 * WARM 64B: Restart Summary (persistente Liste kommt über Log + Forensics)
 * ============================================================================
 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_restart_ns;
        _Atomic(uint32_t) last_restart_reason;     /* cl_wd_reason_t */
        _Atomic(uint32_t) last_restart_module;     /* cl_wd_module_t */

        _Atomic(uint64_t) last_restart_commit_epoch;

        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;

        uint8_t  src;
        uint8_t  qual;
        uint16_t reserved2;
        uint32_t reserved3;
    };
    uint8_t raw[64];
} cl_wd_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_wd_warm_64_t) == 64, "watchdog warm 64");

/* ============================================================================
 * COLD 64B: Policy/Thresholds (sichtbar, konservativ)
 * ============================================================================
 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t stall_ns_threshold;   /* z.B. 2_000_000_000 (2s) */
        uint32_t warn_ns_threshold;    /* z.B. 250_000_000 (250ms) */

        uint32_t max_restart_per_min;  /* Rate limit */
        uint32_t cooldown_s;           /* Sperrzeit nach Restart */

        uint32_t log_enabled;          /* 1=watchdog log schreiben */
        uint32_t reserved0;

        uint8_t  src;
        uint8_t  qual;
        uint16_t reserved1;
        uint32_t reserved2;

        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_wd_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_wd_cold_64_t) == 64, "watchdog cold 64");

/* ============================================================================
 * Segment 256B
 * ============================================================================
 */
typedef struct CL_ALIGNAS(256) {
    cl_wd_hot_64a_t hot_a;
    cl_wd_hot_64b_t hot_b;
    cl_wd_warm_64_t warm;
    cl_wd_cold_64_t cold;
} cl_watchdog_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_watchdog_seg_256_t) == 256, "watchdog seg 256");


<<< END FILE: ./include/cl_runtime/cl_seg_watchdog_256.h

>>> START FILE: ./include/cl_runtime/cl_seg_zfs_4096.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: ZFS Meta (4096B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_zfs_4096.h
 * ============================================================================
 *
 * Zweck:
 *   - ZFS Presence/Health + ARC Summary + Bulk-Offsets zu Pools/VDEVs/Datasets.
 *
 * Maximalmodell:
 *   - Wenn ZFS nicht verfügbar: zfs_present=0, state=UNSUPPORTED/UNKNOWN.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

#define CL_ZFS_H_OK        (1u << 0)
#define CL_ZFS_H_DEGRADED  (1u << 1)
#define CL_ZFS_H_FAULTED   (1u << 2)
#define CL_ZFS_H_SCRUBBING (1u << 3)

/* Header 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) zfs_present;
        _Atomic(uint32_t) zfs_health_bits;

        _Atomic(uint16_t) zfs_state;           /* cl_feature_state_t */
        _Atomic(uint16_t) snapshots_enabled;   /* 0/1 */
        _Atomic(uint32_t) reserved0;

        _Atomic(uint32_t) pools_count;
        _Atomic(uint32_t) vdevs_count;

        _Atomic(uint32_t) datasets_count;
        _Atomic(uint32_t) zvols_count;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
        uint32_t reserved2;

        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_zfs_hdr_64_t;

CL_STATIC_ASSERT(sizeof(cl_zfs_hdr_64_t)==64, "zfs hdr 64");

/* ARC 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) arc_size;
        _Atomic(uint64_t) arc_max;
        _Atomic(uint64_t) arc_hits;
        _Atomic(uint64_t) arc_misses;
        _Atomic(uint64_t) l2_size;
        _Atomic(uint64_t) l2_hits;
        _Atomic(uint64_t) l2_misses;
        _Atomic(uint64_t) reserved0;
    };
    uint8_t raw[64];
} cl_zfs_arc_64_t;

CL_STATIC_ASSERT(sizeof(cl_zfs_arc_64_t)==64, "zfs arc 64");

/* Bulk offsets 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) off_pools;
        _Atomic(uint64_t) off_vdevs;
        _Atomic(uint64_t) off_datasets;
        _Atomic(uint64_t) off_zvols;

        _Atomic(uint64_t) size_pools_bytes;
        _Atomic(uint64_t) size_vdevs_bytes;
        _Atomic(uint64_t) size_datasets_bytes;
        _Atomic(uint64_t) size_zvols_bytes;
    };
    uint8_t raw[64];
} cl_zfs_bulk_64_t;

CL_STATIC_ASSERT(sizeof(cl_zfs_bulk_64_t)==64, "zfs bulk 64");

typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_zfs_rsv_64_t;

typedef struct CL_ALIGNAS(4096) {
    cl_zfs_hdr_64_t  hdr;
    cl_zfs_arc_64_t  arc;
    cl_zfs_bulk_64_t bulk;
    cl_zfs_rsv_64_t  rsv[61];
} cl_zfs_seg_4096_t;

CL_STATIC_ASSERT(sizeof(cl_zfs_seg_4096_t)==4096, "zfs seg 4096");


<<< END FILE: ./include/cl_runtime/cl_seg_zfs_4096.h

>>> START FILE: ./include/cl_runtime/cl_service_seg_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Service-State (256B) – FINAL
 * Datei: include/cl_runtime/cl_service_seg_256.h
 * ============================================================================
 *
 * Zweck:
 *   SSOT für Boot-/Supervisor-Zustand.
 *   ZERO-konform: keine Telemetrie, keine Policy – nur Prozessstatus.
 *
 * Writer:
 *   - clboot / später cld: expected/running/pid/crash/exit/signal
 *   - jeder Prozess (core0/hal0/link0/flow0/oracle0): heartbeat_ns
 *
 * Layout:
 *   256B = 4 Cachelines à 64B
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"

/* Service IDs (Slot-Index; SSOT) */
typedef enum cl_service_id {
    CL_SVC_CORE0   = 0,
    CL_SVC_HAL0    = 1,
    CL_SVC_LINK0   = 2,
    CL_SVC_FLOW0   = 3,
    CL_SVC_ORACLE0 = 4,
    CL_SVC_MONITOR = 5, /* optional */
    CL_SVC_MAX     = 6
} cl_service_id_t;

/* 32B Slot: bewusst klein, deterministisch */
typedef struct CL_ALIGNAS(8) cl_service_slot_32 {
    _Atomic(uint32_t) expected;          /* 0/1 */
    _Atomic(uint32_t) running;           /* 0/1 */
    _Atomic(uint32_t) pid;               /* Prozess-ID */
    _Atomic(uint32_t) crash_count;       /* Restart-Zähler */

    _Atomic(uint64_t) last_heartbeat_ns; /* Prozess schreibt (MONOTONIC ns) */

    _Atomic(int32_t)  last_exit_code;    /* Supervisor schreibt */
    _Atomic(int32_t)  last_signal;       /* Supervisor schreibt */
} cl_service_slot_32_t;

CL_STATIC_ASSERT(sizeof(cl_service_slot_32_t) == 32, "service slot muss 32B sein");

/* CL0: Globaler Boot/Redirect-Status */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) boot_epoch;         /* bump je clboot/cld start */
        _Atomic(uint64_t) boot_id_ns;         /* monotone boot id */

        _Atomic(uint32_t) desired_redirect;   /* clboot/clctl Wunsch */
        _Atomic(uint32_t) effective_redirect; /* LINK setzt effektiv */

        _Atomic(uint32_t) last_error_code;    /* supervisor error */
        _Atomic(uint32_t) service_count;      /* = CL_SVC_MAX */

        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
    };
    uint8_t raw[64];
} cl_service_global_64_t;

CL_STATIC_ASSERT(sizeof(cl_service_global_64_t) == 64, "service global muss 64B sein");

/* CL1: Slots 0–1 */
typedef union CL_ALIGNAS(8) {
    struct { cl_service_slot_32_t s0; cl_service_slot_32_t s1; };
    uint8_t raw[64];
} cl_service_slots01_64_t;

CL_STATIC_ASSERT(sizeof(cl_service_slots01_64_t) == 64, "service slots01 muss 64B sein");

/* CL2: Slots 2–3 */
typedef union CL_ALIGNAS(8) {
    struct { cl_service_slot_32_t s2; cl_service_slot_32_t s3; };
    uint8_t raw[64];
} cl_service_slots23_64_t;

CL_STATIC_ASSERT(sizeof(cl_service_slots23_64_t) == 64, "service slots23 muss 64B sein");

/* CL3: Slots 4–5 */
typedef union CL_ALIGNAS(8) {
    struct { cl_service_slot_32_t s4; cl_service_slot_32_t s5; };
    uint8_t raw[64];
} cl_service_slots45_64_t;

CL_STATIC_ASSERT(sizeof(cl_service_slots45_64_t) == 64, "service slots45 muss 64B sein");

/* Segment 256B */
typedef struct CL_ALIGNAS(256) cl_service_seg_256 {
    cl_service_global_64_t  g0;
    cl_service_slots01_64_t g1;
    cl_service_slots23_64_t g2;
    cl_service_slots45_64_t g3;
} cl_service_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_service_seg_256_t) == 256, "service seg muss 256B sein");


<<< END FILE: ./include/cl_runtime/cl_service_seg_256.h

>>> START FILE: ./include/cl_runtime/cl_shm_layout.h
#pragma once
/* ============================================================================
 * CommanderLink – Core SHM Root Layout (Runtime) – FINAL
 * Datei: include/cl_runtime/cl_shm_layout.h
 * ============================================================================
 *
 * Ziel:
 *   Root ist die Notfall-Wahrheit: minimal, deterministisch, 4096B.
 *
 * Maschinenregel:
 *   - raw[4096] Normfläche.
 *   - Host-Order.
 *   - 64-bit-first Feldreihenfolge.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_ids.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_schema.h"

#define CL_CORE_SHM_NAME   "/cl_core_root"
#define CL_BULK_SHM_NAME   "/cl_bulk"

#define CL_ROOT_MAGIC_U32          0x54524C43u /* "CLRT" in Host-Order */
#define CL_ROOT_FLAG_FAILFAST_ABI  (1u << 0)


typedef union CL_ALIGNAS(CL_SHM_PAGE_BYTES) {
    struct {
        /* 64-bit first */
        uint64_t abi_layout_checksum;

        _Atomic(uint64_t) seq_cnt;
        _Atomic(uint64_t) uptime_ns;
        _Atomic(uint64_t) bulk_epoch;

        uint64_t boot_id_ns;
        cl_mesh_tag64_t mesh_tag64;
        cl_node_tag64_t node_tag64;

        uint64_t toc_offset;
        uint64_t toc_size;

		/* 32-bit */
        uint32_t root_magic;      /* CL_ROOT_MAGIC_U32 */
        uint32_t root_flags;      /* CL_ROOT_FLAG_*    */

        uint32_t schema_version;
        uint32_t endian_magic;

        _Atomic(uint32_t) global_health;
        _Atomic(uint32_t) budget_state;

        _Atomic(uint32_t) path_state;
        _Atomic(uint32_t) backend_active;
        _Atomic(uint32_t) mode_active;
        _Atomic(uint32_t) profile_active;

        _Atomic(uint32_t) rx_gate;
        _Atomic(uint32_t) tx_gate;

        _Atomic(uint32_t) constraint_flags;
        _Atomic(uint32_t) reason_code;

        _Atomic(uint32_t) bulk_present;

        uint32_t overlay_ip_host_u32;
        uint32_t overlay_failopen_events;
        uint16_t overlay_routes;
        uint16_t mtu_effective;

        /* 8-bit */
        _Atomic(uint8_t) active_index;
        uint8_t overlay_prefixlen;
        uint8_t overlay_enabled;
        uint8_t reserved_u8;

        /* Trust quick view */
        _Atomic(uint32_t) trust_policy_required;
        _Atomic(uint32_t) trusted_peer_count;
    };
    uint8_t raw[CL_SHM_PAGE_BYTES];
} cl_root_4096_t;

CL_STATIC_ASSERT(sizeof(cl_root_4096_t) == CL_SHM_PAGE_BYTES, "root must be 4096B");

/* Back-compat */
typedef cl_root_4096_t cl_root_t;


<<< END FILE: ./include/cl_runtime/cl_shm_layout.h

>>> START FILE: ./include/cl_runtime/cl_toc.h
#pragma once
/* ============================================================================
 * CommanderLink – Runtime TOC (Table of Contents) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_toc.h
 * ============================================================================
 *
 * Vertrag:
 *   - TOC ist die physikalische Verkabelung der Runtime-SHM.
 *   - TOC ist rein beschreibend (keine Policy, keine Logik).
 *
 * Layout:
 *   - cl_toc_header_t: exakt 64B (1 Cacheline)
 *   - cl_toc_entry_t : exakt 64B (1 Cacheline)
 *   - cl_toc_t       : Header + entries[CL_TOC_MAX_ENTRIES]
 *
 * Semantik:
 *   - Segment-ID: CL_<NAME>_SEG_<stride>
 *   - Segmentgröße steht im TOC (stride_bytes), nicht im Segment-ID-Namen.
 *     (Der Name trägt den stride nur als symbolische Eindeutigkeit.)
 * ============================================================================
 */

#include <stdint.h>

#include "cl_gates.h"

/* --------------------------------------------------------------------------
 * Architekturannahme
 * -------------------------------------------------------------------------- */
#if !defined(__x86_64__) && !defined(_M_X64)
#error "CommanderLink TOC ist x86_64-first"
#endif

/* --------------------------------------------------------------------------
 * TOC Version / Limits
 * -------------------------------------------------------------------------- */
#define CL_TOC_VERSION      1u
#define CL_TOC_MAX_ENTRIES  128u

/* --------------------------------------------------------------------------
 * Segment-IDs (SSOT für TOC type)
 *
 * Hinweis:
 *   Diese IDs sind für TOC/Tools/Monitor.
 *   Die semantische Rolle bleibt wichtiger als die Zahl selbst.
 * -------------------------------------------------------------------------- */
typedef enum cl_seg_type {

    /* 256 */
    CL_LINK_SEG_256            = 0x0100,
    CL_BUDGET_SEG_256          = 0x0101,
    CL_MEM_SEG_256             = 0x0102,
    CL_OVERLAY_SEG_256         = 0x0103,
    CL_WATCHDOG_SEG_256        = 0x0104,
    CL_PCIE_SEG_256            = 0x0105,
    CL_TIME_SEG_256            = 0x0106,
    CL_MESH_NEIGHBOR_SEG_256   = 0x0107,
    CL_MESH_PEER_SEG_256       = 0x0108,
    CL_ORACLE_SEG_256          = 0x0109,
    CL_SERVICE_SEG_256         = 0x010A,

    /* 512 */
    CL_NIC_SEG_512             = 0x0200,
    CL_BOARD_SEG_512           = 0x0201,

    /* 1024 */
    CL_CPU_SEG_1024            = 0x0300,

    /* 4096 */
    CL_DMA_SEG_4096            = 0x0400,
    CL_HISTORY_SEG_4096        = 0x0401,
    CL_FORENSICS_SEG_4096      = 0x0402,
    CL_ZFS_SEG_4096            = 0x0403
} cl_seg_type_t;

/* --------------------------------------------------------------------------
 * TOC Flags (physikalische Eigenschaften, keine Policy)
 * -------------------------------------------------------------------------- */
typedef uint32_t cl_toc_flags_t;

/* Speicherklasse */
#define CL_TOC_FLAG_RESIDENT        (1u << 0)  /* Core-SHM                         */
#define CL_TOC_FLAG_RECLAIMABLE     (1u << 1)  /* Bulk-SHM                         */

/* Bedeutung */
#define CL_TOC_FLAG_CRITICAL        (1u << 2)
#define CL_TOC_FLAG_OBSERVABLE      (1u << 3)

/* Änderungsfrequenz */
#define CL_TOC_FLAG_HOT             (1u << 4)
#define CL_TOC_FLAG_WARM            (1u << 5)
#define CL_TOC_FLAG_COLD            (1u << 6)

/* Instanzierung */
#define CL_TOC_FLAG_FIXED_COUNT     (1u << 7)
#define CL_TOC_FLAG_VARIABLE_COUNT  (1u << 8)

/* Rolle */
#define CL_TOC_FLAG_DATA            (1u << 9)
#define CL_TOC_FLAG_CONTROL         (1u << 10)
#define CL_TOC_FLAG_FORENSICS       (1u << 11)

/* --------------------------------------------------------------------------
 * Source/Access/Presence/Layout
 * -------------------------------------------------------------------------- */
typedef uint16_t cl_toc_source_t;
#define CL_TOC_SOURCE_DIRECT        (1u << 0)
#define CL_TOC_SOURCE_BEST_EFFORT   (1u << 1)
#define CL_TOC_SOURCE_ESTIMATED     (1u << 2)
#define CL_TOC_SOURCE_UNSUPPORTED   (1u << 3)

typedef uint16_t cl_toc_access_t;
#define CL_TOC_ACCESS_READ          (1u << 0)
#define CL_TOC_ACCESS_WRITE         (1u << 1)
#define CL_TOC_ACCESS_ATOMIC        (1u << 2)

typedef uint16_t cl_toc_presence_t;
#define CL_TOC_PRESENT              (1u << 0)
#define CL_TOC_RECLAIMED            (1u << 1)
#define CL_TOC_PARTIAL              (1u << 2)

typedef uint16_t cl_toc_layout_t;
#define CL_TOC_LAYOUT_CACHELINE     (1u << 0)
#define CL_TOC_LAYOUT_ARRAY         (1u << 1)

/* --------------------------------------------------------------------------
 * TOC Entry – exakt 64B
 * -------------------------------------------------------------------------- */
typedef struct cl_toc_entry {

    uint16_t       type;           /* cl_seg_type_t */
    uint16_t       version;        /* Segment-spezifische Version */
    uint32_t       flags;          /* cl_toc_flags_t */

    uint32_t       stride_bytes;   /* 256/512/1024/4096 */
    uint32_t       count;          /* Instanzen */

    uint64_t       offset_bytes;   /* Offset relativ zum jeweiligen SHM-Beginn */

    uint16_t       source_flags;   /* cl_toc_source_t  */
    uint16_t       access_flags;   /* cl_toc_access_t  */
    uint16_t       presence_flags; /* cl_toc_presence_t */
    uint16_t       layout_flags;   /* cl_toc_layout_t */

    cl_gate_mask_t gates_possible;
    cl_gate_mask_t gates_effective;

    uint64_t       epoch;

    uint64_t       reserved0;      /* macht 64B exakt */

} cl_toc_entry_t;

_Static_assert(sizeof(cl_toc_entry_t) == 64, "cl_toc_entry_t muss exakt 64B sein");

/* --------------------------------------------------------------------------
 * TOC Header – exakt 64B
 * -------------------------------------------------------------------------- */
typedef struct cl_toc_header {

    uint32_t version;        /* CL_TOC_VERSION */
    uint32_t entry_count;    /* Anzahl gültiger Entries */

    uint64_t total_bytes;    /* Core oder Core+Bulk (konkret, nicht geraten) */
    uint64_t build_id;       /* ABI-/Build-Fingerprint */
    uint64_t epoch;          /* TOC epoch */

    uint64_t reserved[4];    /* macht 64B exakt */

} cl_toc_header_t;

_Static_assert(sizeof(cl_toc_header_t) == 64, "cl_toc_header_t muss exakt 64B sein");

/* --------------------------------------------------------------------------
 * Gesamter TOC
 * -------------------------------------------------------------------------- */
typedef struct cl_toc {

    cl_toc_header_t header;
    cl_toc_entry_t  entries[CL_TOC_MAX_ENTRIES];

} cl_toc_t;


<<< END FILE: ./include/cl_runtime/cl_toc.h

>>> START FILE: ./Makefile
# ============================================================================
# CommanderLink – Makefile (SSOT path, Endausbau-Bootkette)
# ============================================================================
# Baut:
#   - tools/cl_abi_report      (Truth Meter)
#   - src/clinit/clinit        (Genesis, ZERO)
#   - src/clboot/clboot        (Orchestrator/Supervisor)
#   - src/cld/cld              (Service wrapper: destroy->init->boot)
#   - src/core/core0           (Stub: heartbeat)
#   - src/hal/hal0             (Stub: heartbeat)
#   - src/link/link0           (Stub: heartbeat)
#   - src/flow/flow0           (Stub: heartbeat)
#   - src/oracle/oracle0       (Stub: heartbeat)
#   - src/monitor/monitor      (SSOT UI, read-only; run with sudo in dev)
#
# Dummy/Dump: entfernt (nicht Bestandteil SSOT-Endausbaupfads)
# ============================================================================

UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
  OS := linux
  LIBCURSES := -lncursesw
else ifeq ($(UNAME_S),FreeBSD)
  OS := bsd
  LIBCURSES := -lncursesw
else ifeq ($(UNAME_S),SunOS)
  OS := omnios
  LIBCURSES := -lcurses
else
  OS := unknown
endif

CC ?= cc

OPT  ?= -O2
CSTD ?= -std=c11
WARN ?= -Wall -Wextra -Wpedantic
DEFS ?= -D_POSIX_C_SOURCE=200809L
INCS ?= -Iinclude

CFLAGS  ?= $(CSTD) $(OPT) $(WARN) $(DEFS) $(INCS)
LDFLAGS ?=
LDLIBS  ?=

ifeq ($(OS),bsd)
  CC ?= clang
endif
ifeq ($(OS),omnios)
  CC ?= gcc
endif

BUILD_DIR := build/$(OS)
BIN_DIR   := bin/$(OS)

# ---------------------------------------------------------------------------
# Sources
# ---------------------------------------------------------------------------
ABI_REPORT_SRC := tools/cl_abi_report/cl_abi_report.c

CLINIT_SRC := src/clinit/clinit.c
CLBOOT_SRC := src/clboot/clboot.c
CLD_SRC    := src/cld/cld.c

CORE0_SRC   := src/core/core0.c
HAL0_SRC    := src/hal/hal0.c
LINK0_SRC   := src/link/link0.c
FLOW0_SRC   := src/flow/flow0.c
ORACLE0_SRC := src/oracle/oracle0.c

MONITOR_SRC := src/monitor/monitor.c \
               src/monitor/monitor_ui.c \
               src/monitor/monitor_state.c \
               src/monitor/monitor_input.c \
               src/monitor/monitor_shm.c \
               src/monitor/tabs/tab_dashboard.c
               
# ---------------------------------------------------------------------------
# Objects
# ---------------------------------------------------------------------------
ABI_REPORT_OBJ := $(BUILD_DIR)/tools/cl_abi_report/cl_abi_report.o

CLINIT_OBJ := $(BUILD_DIR)/src/clinit/clinit.o
CLBOOT_OBJ := $(BUILD_DIR)/src/clboot/clboot.o
CLD_OBJ    := $(BUILD_DIR)/src/cld/cld.o

CORE0_OBJ   := $(BUILD_DIR)/src/core/core0.o
HAL0_OBJ    := $(BUILD_DIR)/src/hal/hal0.o
LINK0_OBJ   := $(BUILD_DIR)/src/link/link0.o
FLOW0_OBJ   := $(BUILD_DIR)/src/flow/flow0.o
ORACLE0_OBJ := $(BUILD_DIR)/src/oracle/oracle0.o

MONITOR_OBJ := $(patsubst src/%.c,$(BUILD_DIR)/src/%.o,$(MONITOR_SRC))

# ---------------------------------------------------------------------------
# Binaries
# ---------------------------------------------------------------------------
ABI_REPORT_BIN := $(BIN_DIR)/cl_abi_report

CLINIT_BIN := $(BIN_DIR)/clinit
CLBOOT_BIN := $(BIN_DIR)/clboot
CLD_BIN    := $(BIN_DIR)/cld

CORE0_BIN   := $(BIN_DIR)/core0
HAL0_BIN    := $(BIN_DIR)/hal0
LINK0_BIN   := $(BIN_DIR)/link0
FLOW0_BIN   := $(BIN_DIR)/flow0
ORACLE0_BIN := $(BIN_DIR)/oracle0

MONITOR_BIN := $(BIN_DIR)/clmonitor

# ---------------------------------------------------------------------------
# Monitor link libs (OS-spezifisch, override möglich)
# ---------------------------------------------------------------------------
MONITOR_LDLIBS ?=
ifeq ($(OS),linux)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),bsd)
  MONITOR_LDLIBS ?= -lncurses
endif
ifeq ($(OS),omnios)
  MONITOR_LDLIBS ?= -lcurses
endif

# ---------------------------------------------------------------------------
# Phony
# ---------------------------------------------------------------------------
.PHONY: all clean dirs help print-vars
.PHONY: abi abi-ct clinit clboot cld
.PHONY: core0 hal0 link0 flow0 oracle0 stubs
.PHONY: monitor
.PHONY: run-init run-boot run-abi run-destroy run-cld run-monitor

# ---------------------------------------------------------------------------
# Default build
# ---------------------------------------------------------------------------
all: abi clinit clboot cld stubs monitor

# ---------------------------------------------------------------------------
# Directories
# ---------------------------------------------------------------------------
dirs:
	@mkdir -p $(BUILD_DIR) $(BIN_DIR)
	@mkdir -p $(BUILD_DIR)/tools/cl_abi_report
	@mkdir -p $(BUILD_DIR)/src/clinit
	@mkdir -p $(BUILD_DIR)/src/clboot
	@mkdir -p $(BUILD_DIR)/src/cld
	@mkdir -p $(BUILD_DIR)/src/core
	@mkdir -p $(BUILD_DIR)/src/hal
	@mkdir -p $(BUILD_DIR)/src/link
	@mkdir -p $(BUILD_DIR)/src/flow
	@mkdir -p $(BUILD_DIR)/src/oracle
	@mkdir -p $(BUILD_DIR)/src/monitor
	@mkdir -p $(BUILD_DIR)/src/monitor/tabs
	
# ---------------------------------------------------------------------------
# ABI Report
# ---------------------------------------------------------------------------
$(ABI_REPORT_OBJ): $(ABI_REPORT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ABI_REPORT_BIN): $(ABI_REPORT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

abi: $(ABI_REPORT_BIN)

abi-ct: $(ABI_REPORT_OBJ)
	@echo "ABI compile-only OK: $(ABI_REPORT_OBJ)"

# ---------------------------------------------------------------------------
# clinit
# ---------------------------------------------------------------------------
$(CLINIT_OBJ): $(CLINIT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLINIT_BIN): $(CLINIT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clinit: $(CLINIT_BIN)

# ---------------------------------------------------------------------------
# clboot
# ---------------------------------------------------------------------------
$(CLBOOT_OBJ): $(CLBOOT_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLBOOT_BIN): $(CLBOOT_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

clboot: $(CLBOOT_BIN)

# ---------------------------------------------------------------------------
# cld
# ---------------------------------------------------------------------------
$(CLD_OBJ): $(CLD_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CLD_BIN): $(CLD_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

cld: $(CLD_BIN)

# ---------------------------------------------------------------------------
# Stub services (heartbeats only)
# ---------------------------------------------------------------------------
$(CORE0_OBJ): $(CORE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(CORE0_BIN): $(CORE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

core0: $(CORE0_BIN)

$(HAL0_OBJ): $(HAL0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(HAL0_BIN): $(HAL0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hal0: $(HAL0_BIN)

$(LINK0_OBJ): $(LINK0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(LINK0_BIN): $(LINK0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

link0: $(LINK0_BIN)

$(FLOW0_OBJ): $(FLOW0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(FLOW0_BIN): $(FLOW0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

flow0: $(FLOW0_BIN)

$(ORACLE0_OBJ): $(ORACLE0_SRC) | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(ORACLE0_BIN): $(ORACLE0_OBJ) | dirs
	$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)

oracle0: $(ORACLE0_BIN)

stubs: core0 hal0 link0 flow0 oracle0

# ---------------------------------------------------------------------------
# Monitor (SSOT UI)
# ---------------------------------------------------------------------------
$(BUILD_DIR)/src/%.o: src/%.c | dirs
	$(CC) $(CFLAGS) -c $< -o $@

$(MONITOR_BIN): $(MONITOR_OBJ) | dirs
	$(CC) $(CFLAGS) -o $@ $(MONITOR_OBJ) $(LIBCURSES) $(MONITOR_LDLIBS) $(LDFLAGS)
	
monitor: $(MONITOR_BIN)

# ---------------------------------------------------------------------------
# Run helpers
# ---------------------------------------------------------------------------
run-init: clinit
	@echo "Running clinit (core-only): $(CLINIT_BIN)"
	@$(CLINIT_BIN) || true

run-destroy: clinit
	@echo "Destroying SHM objects via clinit --destroy"
	@$(CLINIT_BIN) --destroy || true

run-abi: abi
	@echo "Running ABI report: $(ABI_REPORT_BIN)"
	@$(ABI_REPORT_BIN) || true

run-boot: clboot
	@echo "Running clboot: $(CLBOOT_BIN)"
	@$(CLBOOT_BIN) || true

run-cld: cld
	@echo "Running cld (service boot path): $(CLD_BIN)"
	@$(CLD_BIN) || true

run-monitor: monitor
	@echo "Running monitor with sudo: $(MONITOR_BIN)"
	@sudo $(MONITOR_BIN) || true

# ---------------------------------------------------------------------------
# Clean
# ---------------------------------------------------------------------------
clean:
	rm -rf build bin

# ---------------------------------------------------------------------------
# Diagnostics / help
# ---------------------------------------------------------------------------
print-vars:
	@echo "CommanderLink Makefile (SSOT path)"
	@echo "  UNAME_S    = $(UNAME_S)"
	@echo "  OS         = $(OS)"
	@echo "  CC         = $(CC)"
	@echo "  CFLAGS     = $(CFLAGS)"
	@echo "  BIN_DIR    = $(BIN_DIR)"
	@echo "  BUILD_DIR  = $(BUILD_DIR)"
	@echo "  MONITOR_LDLIBS = $(MONITOR_LDLIBS)" -lncursesw

help:
	@echo "CommanderLink (CL) – SSOT Build"
	@echo ""
	@echo "Detected OS: $(UNAME_S) -> bin/$(OS)/"
	@echo ""
	@echo "Targets:"
	@echo "  make all        Build abi + clinit + clboot + cld + stubs + monitor"
	@echo "  make abi        Build cl_abi_report"
	@echo "  make clinit     Build clinit"
	@echo "  make clboot     Build clboot"
	@echo "  make cld        Build cld"
	@echo "  make stubs      Build core0/hal0/link0/flow0/oracle0"
	@echo "  make monitor    Build cl_monitor"
	@echo "  make clean      Remove build/ and bin/"
	@echo ""
	@echo "Run helpers:"
	@echo "  make run-init     Create/refresh SHM (core-only)"
	@echo "  make run-destroy  Remove SHM objects"
	@echo "  make run-abi      Run ABI report"
	@echo "  make run-cld      Boot via cld (destroy->init->clboot)"
	@echo "  make run-monitor  Run monitor via sudo"
	@echo ""
	@echo "Monitor libs:"
	@echo "  Override with: gmake MONITOR_LDLIBS=-lncursesw monitor"


<<< END FILE: ./Makefile

>>> START FILE: ./README.md
commanderlink/
├── include/
│   ├── cl_manifest/
│   │   ├── cl_limits.h
│   │   ├── cl_ids.h
│   │   ├── cl_features.h
│   │   ├── cl_link_modes.h
│   │   ├── cl_wire.h
│   │   ├── cl_oob.h
│   │   └── cl_manifest.h
│   ├── cl_common/
│   │   ├── cl_atomic.h
│   │   ├── cl_endian.h
│   │   ├── cl_crc8.h
│   │   ├── cl_time.h
│   │   └── cl_tags.h
│   ├── cl_runtime/
│   │   ├── cl_toc.h
│   │   ├── cl_global.h
│   │   ├── cl_quality.h
│   │   ├── cl_segments_cpu.h
│   │   ├── cl_segments_nic.h
│   │   ├── cl_segments_mem.h
│   │   ├── cl_segments_pcie.h
│   │   ├── cl_segments_board.h
│   │   ├── cl_segments_time.h
│   │   ├── cl_segments_link.h
│   │   ├── cl_segments_budget.h
│   │   ├── cl_segments_mesh.h
│   │   ├── cl_segments_dma.h
│   │   └── cl_segments_zfs.h
│   ├── cl_hal/
│   │   └── cl_hal.h
│   ├── cl_core/
│   │   └── cl_core.h
│   ├── cl_flow/
│   │   └── cl_flow.h
│   ├── cl_link/
│   │   └── cl_link.h
│   ├── cl_oracle/
│   │   └── cl_oracle.h
│   └── cl_monitor/
│       └── cl_monitor.h
├── src/ (leer oder später)
└── tools/ (leer oder später)

src/monitor/
├── monitor_main.c          # main loop, init ncurses, dispatch tabs
├── monitor_state.c         # UI state (active tab, focus, selection, filter)
├── monitor_state.h
├── monitor_shm.c           # attach core/bulk shm, map pointers, bulk present
├── monitor_shm.h
├── monitor_toc.c           # helpers: find segment by type, compute record ptrs
├── monitor_toc.h
├── monitor_draw.c          # box/lines/colors/helpers, autoscaling layout grid
├── monitor_draw.h
├── monitor_keymap.c        # key handling (F1..F12, arrows, /, s, tab, h)
├── monitor_keymap.h
├── monitor_fmt.c           # formatting helpers (bps, ppm, us, ids short, Q|S)
├── monitor_fmt.h
├── tabs/
│   ├── tab_dashboard.c     # F1
│   ├── tab_inventory.c     # F2
│   ├── tab_cpu.c           # F3
│   ├── tab_memory.c        # F4
│   ├── tab_nic.c           # F5
│   ├── tab_mesh.c          # F6
│   ├── tab_dma.c           # F7
│   ├── tab_zfs.c           # F8
│   ├── tab_pcie.c          # F9
│   ├── tab_gpu.c           # F10
│   ├── tab_oracle.c        # F11
│   └── tab_audit.c         # F12
└── tabs/tab_common.h       # shared tab helpers

Erweiterung: 

commanderlink/
├─ src/
│  ├─ core/                     ← ZENTRALE SYSTEMWAHRHEIT
│  │  ├─ cl_gates.h              ← HIER!
│  │  ├─ cl_segment_types.h
│  │  ├─ cl_toc.h
│  │  ├─ cl_budget.h
│  │  └─ cl_timebase.h
│  │
│  ├─ seg/                      ← RUNTIME-SEGMENTE (SHM)
│  │  ├─ seg_cpu_1024.h
│  │  ├─ seg_memory_256.h
│  │  ├─ seg_nic_512.h
│  │  ├─ seg_pcie_256.h
│  │  ├─ seg_budget_256.h
│  │  ├─ seg_overlay_256.h
│  │  ├─ seg_watchdog_256.h
│  │  ├─ seg_mesh_neighbor_256.h
│  │  └─ seg_dma_4096.h
│  │
│  ├─ wire/                     ← DRAHTREALITÄT
│  │  ├─ cl_wire_common.h
│  │  ├─ cl_wire_clwp.h
│  │  ├─ cl_wire_oob.h
│  │  ├─ cl_wire_modes.h
│  │  └─ cl_wire_limits.h
│  │
│  ├─ runtime/                  ← AKTIVE LOGIK (später)
│  │  ├─ flow/
│  │  ├─ link/
│  │  └─ hal/
│  │
│  ├─ monitor/                  ← PASSIVER LESER
│  ├─ tools/
│  └─ tests/
│
├─ docs/
│  ├─ laws/
│  └─ contracts/
│
└─ Makefile


<<< END FILE: ./README.md

>>> START FILE: ./src/clboot/clboot.c
/*
 * ============================================================================
 * CommanderLink – clboot (Orchestrator/Supervisor) – FINAL Endausbau
 * Datei: src/clboot/clclboot.c
 * ============================================================================
 *
 * Zweck:
 *   - Bootet das CommanderLink-System wie ein Systemdienst:
 *       1) sicherstellen: SHM existiert (clinit)
 *       2) Services starten: core0 -> hal0 -> link0 -> flow0 -> oracle0
 *       3) Supervisor: Heartbeats prüfen, Self-Healing (Restart + Backoff)
 *
 * ZERO-LAW:
 *   - clboot setzt keine Telemetrie und keine Transport-Policy.
 *   - clboot schreibt nur Service-State (SSOT für Boot/Supervision).
 *
 * CPU/Caps:
 *   - clboot liest CPU-count + ISA (SSE4.2/AVX2/AVX-512 best-effort)
 *   - erstellt einen initialen Runplan (Pinning-Sets), deterministisch.
 *   - dynamische Aggressivität bleibt CORE/FLOW/LINK.
 *
 * Hinweis:
 *   - Redirect wird NICHT von clboot "hart" aktiviert.
 *   - clboot setzt nur desired_redirect (optional).
 *   - effective_redirect setzt LINK, gated durch Trust+Dataplane Ready.
 * ============================================================================
 */

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <stddef.h>
#include <stdalign.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <time.h>
#include <signal.h>

#if defined(__FreeBSD__)
#include <sys/param.h>
#include <sys/cpuset.h>
#include <sys/types.h>
#include <sys/sysctl.h>
#endif

#if defined(__linux__)
#include <sched.h>
#endif

#include "cl_runtime/cl_runtime.h"
#include "cl_runtime/cl_service_seg_256.h"

/* ---------------- Zeit ---------------- */
static uint64_t now_ns(void) {
    struct timespec ts;
#if defined(CLOCK_MONOTONIC)
    clock_gettime(CLOCK_MONOTONIC, &ts);
#else
    clock_gettime(CLOCK_REALTIME, &ts);
#endif
    return (uint64_t)ts.tv_sec * 1000000000ull + (uint64_t)ts.tv_nsec;
}

/* ---------------- OS tag (bin/<os>/) ---------------- */
static const char* detect_os_tag(void) {
#if defined(__FreeBSD__)
    return "bsd";
#elif defined(__linux__)
    return "linux";
#elif defined(__sun)
    return "omnios";
#else
    return "unknown";
#endif
}

/* ---------------- CPUID (x86_64) ---------------- */
#if defined(__x86_64__) || defined(_M_X64)
static void cpuid(uint32_t leaf, uint32_t subleaf,
                  uint32_t *eax, uint32_t *ebx, uint32_t *ecx, uint32_t *edx)
{
#if defined(__clang__) || defined(__GNUC__)
    uint32_t a, b, c, d;
    __asm__ volatile("cpuid"
                     : "=a"(a), "=b"(b), "=c"(c), "=d"(d)
                     : "a"(leaf), "c"(subleaf));
    *eax = a; *ebx = b; *ecx = c; *edx = d;
#else
    *eax = *ebx = *ecx = *edx = 0;
#endif
}

static uint64_t xgetbv0(void) {
#if defined(__clang__) || defined(__GNUC__)
    uint32_t eax, edx;
    __asm__ volatile(".byte 0x0f, 0x01, 0xd0" : "=a"(eax), "=d"(edx) : "c"(0));
    return ((uint64_t)edx << 32) | eax;
#else
    return 0;
#endif
}
#endif

typedef struct cl_boot_caps {
    uint32_t cpu_online;
    uint8_t  has_sse42;
    uint8_t  has_avx2;
    uint8_t  has_avx512;
} cl_boot_caps_t;

static cl_boot_caps_t read_host_caps(void) {
    cl_boot_caps_t c;
    memset(&c, 0, sizeof(c));

#if defined(__FreeBSD__)
    int ncpu = 1;
    size_t len = sizeof(ncpu);
    if (sysctlbyname("hw.ncpu", &ncpu, &len, NULL, 0) == 0 && ncpu > 0) {
        c.cpu_online = (uint32_t)ncpu;
    } else {
        c.cpu_online = 1u;
    }
#else
    long n = sysconf(_SC_NPROCESSORS_ONLN);
    c.cpu_online = (n > 0) ? (uint32_t)n : 1u;
#endif

#if defined(__x86_64__) || defined(_M_X64)
    uint32_t a,b,cc,d;

    /* SSE4.2: CPUID.01H:ECX.SSE4_2[20] */
    cpuid(1, 0, &a, &b, &cc, &d);
    c.has_sse42 = (uint8_t)((cc >> 20) & 1u);

    /* AVX2: CPUID.07H:EBX.AVX2[5] + OSXSAVE/XCR0 */
    uint8_t osxsave = (uint8_t)((cc >> 27) & 1u);
    uint8_t avx = (uint8_t)((cc >> 28) & 1u);

    cpuid(7, 0, &a, &b, &cc, &d);
    uint8_t avx2 = (uint8_t)((b >> 5) & 1u);

    uint64_t xcr0 = osxsave ? xgetbv0() : 0;
    uint8_t xmm_ymm_enabled = (uint8_t)(((xcr0 & 0x6u) == 0x6u) ? 1u : 0u);

    c.has_avx2 = (uint8_t)(avx && avx2 && xmm_ymm_enabled);

    /* AVX-512: CPUID.07H:EBX.AVX512F[16] + XCR0 (ZMM state) */
    uint8_t avx512f = (uint8_t)((b >> 16) & 1u);
    uint8_t zmm_enabled = (uint8_t)(((xcr0 & 0xE6u) == 0xE6u) ? 1u : 0u);

    c.has_avx512 = (uint8_t)(avx512f && zmm_enabled);
#endif

    return c;
}

/* ---------------- SHM attach (core RW) ---------------- */
static int map_shm_rw(const char *name, void **out_base, size_t *out_sz) {
    int fd = shm_open(name, O_RDWR, 0);
    if (fd < 0) return -1;

    struct stat st;
    if (fstat(fd, &st) != 0) { close(fd); return -2; }
    if (st.st_size <= 0) { close(fd); return -3; }

    void *p = mmap(NULL, (size_t)st.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    close(fd);
    if (p == MAP_FAILED) return -4;

    *out_base = p;
    *out_sz = (size_t)st.st_size;
    return 0;
}

static void unmap_shm(void *base, size_t sz) {
    if (base && sz) (void)munmap(base, sz);
}

/* ---------------- TOC lookup: service seg ---------------- */
static int find_service_seg(const cl_root_t *root, const cl_toc_t *toc, uint64_t *out_off) {
    (void)root;

    for (uint32_t i = 0; i < toc->header.entry_count && i < CL_TOC_MAX_ENTRIES; i++) {
        const cl_toc_entry_t *e = &toc->entries[i];
        if ((uint16_t)e->type == (uint16_t)CL_SERVICE_SEG_256) {
            if (e->stride_bytes != 256u || e->count != 1u) return -2;
            *out_off = (uint64_t)e->offset_bytes;
            return 0;
        }
    }
    return -1;
}

/* ---------------- Pinning (initial, deterministisch) ---------------- */
static void pin_self_to_cpu0(void) {
#if defined(__linux__)
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    (void)sched_setaffinity(0, sizeof(set), &set);
#elif defined(__FreeBSD__)
    cpuset_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    (void)cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(set), &set);
#endif
}

/* ---------------- Spawn helper ---------------- */
typedef struct cl_proc {
    const char *name;
    cl_service_id_t sid;
    pid_t pid;
    uint64_t next_restart_ns;
    uint32_t backoff_pow; /* 0.. */
} cl_proc_t;

static pid_t spawn_process(const char *path, const char *name) {
    pid_t pid = fork();
    if (pid < 0) return -1;
    if (pid == 0) {
        /* Child: exec */
        execl(path, name, (char*)NULL);
        _exit(127);
    }
    return pid;
}

/* ---------------- Service slot access ---------------- */
static cl_service_slot_32_t* svc_slot(cl_service_seg_256_t *s, cl_service_id_t id) {
    switch (id) {
        case CL_SVC_CORE0:   return &s->g1.s0;
        case CL_SVC_HAL0:    return &s->g1.s1;
        case CL_SVC_LINK0:   return &s->g2.s2;
        case CL_SVC_FLOW0:   return &s->g2.s3;
        case CL_SVC_ORACLE0: return &s->g3.s4;
        case CL_SVC_MONITOR: return &s->g3.s5;
        default: return NULL;
    }
}

/* ---------------- Self-healing policy (deterministisch) ---------------- */
static uint64_t backoff_ns(uint32_t pow) {
    /* 0->0s, 1->1s, 2->2s, 3->4s, ... cap 10s */
    uint64_t s = 0;
    if (pow == 0) s = 0;
    else if (pow == 1) s = 1000000000ull;
    else if (pow == 2) s = 2000000000ull;
    else if (pow == 3) s = 4000000000ull;
    else if (pow == 4) s = 8000000000ull;
    else s = 10000000000ull;
    return s;
}

/* ---------------- Main ---------------- */
int main(int argc, char **argv) {
    (void)argc; (void)argv;

    /* Deterministisches Pinning für den Supervisor selbst */
    pin_self_to_cpu0();

    /* Host-Caps erfassen (rein informativ/bootplan) */
    cl_boot_caps_t caps = read_host_caps();
    printf("clboot: cpu_online=%u sse4.2=%u avx2=%u avx512=%u\n",
           caps.cpu_online, caps.has_sse42, caps.has_avx2, caps.has_avx512);

    /* 1) SHM sicherstellen: clinit muss vorher gelaufen sein.
     *    (Endausbau: clboot kann clinit bei Bedarf automatisch starten.)
     */
    void *core_base = NULL;
    size_t core_sz = 0;
    int rc = map_shm_rw(CL_CORE_SHM_NAME, &core_base, &core_sz);
    if (rc != 0) {
        printf("FAIL: cannot map core shm (%s): rc=%d errno=%d (%s)\n",
               CL_CORE_SHM_NAME, rc, errno, strerror(errno));
        return 2;
    }

    cl_root_t *root = (cl_root_t*)core_base;
    cl_toc_t  *toc  = (cl_toc_t*)((uint8_t*)core_base + (size_t)root->toc_offset);

    /* Service segment finden */
    uint64_t svc_off = 0;
    rc = find_service_seg(root, toc, &svc_off);
    if (rc != 0) {
        printf("FAIL: service segment not found in TOC (rc=%d)\n", rc);
        unmap_shm(core_base, core_sz);
        return 3;
    }

    cl_service_seg_256_t *svc = (cl_service_seg_256_t*)((uint8_t*)core_base + (size_t)svc_off);

    /* Service-Segment initialisieren (ZERO-konform: nur Orchestrationsdaten) */
    atomic_fetch_add(&svc->g0.boot_epoch, 1);
    atomic_store(&svc->g0.boot_id_ns, now_ns());
    atomic_store(&svc->g0.service_count, (uint32_t)CL_SVC_MAX);

    /* expected=1, running=0 initial */
    for (int i = 0; i < (int)CL_SVC_MAX; i++) {
        cl_service_slot_32_t *sl = svc_slot(svc, (cl_service_id_t)i);
        if (!sl) continue;
        atomic_store(&sl->expected, 1u);
        atomic_store(&sl->running, 0u);
        atomic_store(&sl->pid, 0u);
        atomic_store(&sl->crash_count, 0u);
        atomic_store(&sl->last_heartbeat_ns, 0u);
        atomic_store(&sl->last_exit_code, 0);
        atomic_store(&sl->last_signal, 0);
    }

    /* Binaries / Reihenfolge */
    const char *os = detect_os_tag();

    char path_core[256], path_hal[256], path_link[256], path_flow[256], path_oracle[256];
    snprintf(path_core,   sizeof(path_core),   "bin/%s/core0",   os);
    snprintf(path_hal,    sizeof(path_hal),    "bin/%s/hal0",    os);
    snprintf(path_link,   sizeof(path_link),   "bin/%s/link0",   os);
    snprintf(path_flow,   sizeof(path_flow),   "bin/%s/flow0",   os);
    snprintf(path_oracle, sizeof(path_oracle), "bin/%s/oracle0", os);

    cl_proc_t procs[] = {
        { "core0",   CL_SVC_CORE0,   -1, 0, 0 },
        { "hal0",    CL_SVC_HAL0,    -1, 0, 0 },
        { "link0",   CL_SVC_LINK0,   -1, 0, 0 },
        { "flow0",   CL_SVC_FLOW0,   -1, 0, 0 },
        { "oracle0", CL_SVC_ORACLE0, -1, 0, 0 }
    };

    const char *paths[] = { path_core, path_hal, path_link, path_flow, path_oracle };

    /* Startphase: strikt in Reihenfolge starten (1 Versuch, dann Supervisor übernimmt) */
    for (size_t i = 0; i < sizeof(procs)/sizeof(procs[0]); i++) {
        pid_t pid = spawn_process(paths[i], procs[i].name);
        cl_service_slot_32_t *sl = svc_slot(svc, procs[i].sid);

        if (pid < 0) {
            printf("WARN: spawn %s failed: errno=%d (%s)\n", procs[i].name, errno, strerror(errno));
            atomic_store(&sl->running, 0u);
            atomic_store(&sl->pid, 0u);
            atomic_store(&sl->last_exit_code, -1);
            atomic_store(&sl->last_signal, 0);
            procs[i].pid = -1;
            procs[i].backoff_pow = 1;
            procs[i].next_restart_ns = now_ns() + backoff_ns(procs[i].backoff_pow);
            continue;
        }

        procs[i].pid = pid;
        atomic_store(&sl->running, 1u);
        atomic_store(&sl->pid, (uint32_t)pid);

        /* Startup grace: heartbeat darf zunächst 0 sein; Supervisor prüft später */
        procs[i].backoff_pow = 0;
        procs[i].next_restart_ns = 0;
    }

    /* Supervisor loop (Endausbau: deterministisch, kein busy loop) */
    const uint64_t heartbeat_timeout_ns = 5ull * 1000000000ull; /* 5s */
    const uint64_t poll_ns = 250ull * 1000000ull;              /* 250ms */

    for (;;) {
        /* reap children non-blocking */
        int status = 0;
        pid_t dead = waitpid(-1, &status, WNOHANG);
        if (dead > 0) {
            for (size_t i = 0; i < sizeof(procs)/sizeof(procs[0]); i++) {
                if (procs[i].pid == dead) {
                    cl_service_slot_32_t *sl = svc_slot(svc, procs[i].sid);

                    atomic_store(&sl->running, 0u);
                    atomic_store(&sl->pid, 0u);

                    if (WIFEXITED(status)) {
                        atomic_store(&sl->last_exit_code, (int32_t)WEXITSTATUS(status));
                        atomic_store(&sl->last_signal, 0);
                    } else if (WIFSIGNALED(status)) {
                        atomic_store(&sl->last_exit_code, -1);
                        atomic_store(&sl->last_signal, (int32_t)WTERMSIG(status));
                    }

                    atomic_fetch_add(&sl->crash_count, 1u);

                    /* schedule restart */
                    procs[i].pid = -1;
                    if (procs[i].backoff_pow < 10) procs[i].backoff_pow++;
                    procs[i].next_restart_ns = now_ns() + backoff_ns(procs[i].backoff_pow);
                    break;
                }
            }
        }

        uint64_t tnow = now_ns();

        /* heartbeat check + restarts */
        for (size_t i = 0; i < sizeof(procs)/sizeof(procs[0]); i++) {
            cl_service_slot_32_t *sl = svc_slot(svc, procs[i].sid);

            uint32_t expected = atomic_load(&sl->expected);
            if (!expected) continue;

            if (procs[i].pid > 0) {
                uint64_t hb = atomic_load(&sl->last_heartbeat_ns);

                /* Wenn heartbeat noch 0 ist, geben wir eine deterministische Grace-Phase (Timeout gilt erst ab hb>0) */
                if (hb > 0 && (tnow - hb) > heartbeat_timeout_ns) {
                    /* Timeout: hart kill + restart */
                    printf("WARN: %s heartbeat timeout; killing pid=%d\n", procs[i].name, (int)procs[i].pid);
                    (void)kill(procs[i].pid, SIGKILL);
                    /* waitpid wird im nächsten Loop reapen */
                }
            } else {
                /* not running: restart wenn fällig */
                if (procs[i].next_restart_ns != 0 && tnow >= procs[i].next_restart_ns) {
                    pid_t pid = spawn_process(paths[i], procs[i].name);
                    if (pid > 0) {
                        procs[i].pid = pid;
                        atomic_store(&sl->running, 1u);
                        atomic_store(&sl->pid, (uint32_t)pid);
                        procs[i].next_restart_ns = 0;
                    } else {
                        /* retry with same backoff schedule bump */
                        if (procs[i].backoff_pow < 10) procs[i].backoff_pow++;
                        procs[i].next_restart_ns = tnow + backoff_ns(procs[i].backoff_pow);
                    }
                }
            }
        }

        /* sleep */
        struct timespec ts;
        ts.tv_sec = (time_t)(poll_ns / 1000000000ull);
        ts.tv_nsec = (long)(poll_ns % 1000000000ull);
        nanosleep(&ts, NULL);
    }

    /* unreachable */
    /* unmap_shm(core_base, core_sz); */
    /* return 0; */
}


<<< END FILE: ./src/clboot/clboot.c

>>> START FILE: ./src/cld/cld.c
#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

static const char* detect_os_tag(void) {
#if defined(__FreeBSD__)
    return "bsd";
#elif defined(__linux__)
    return "linux";
#elif defined(__sun)
    return "omnios";
#else
    return "unknown";
#endif
}

static int run_wait(const char *path, char *const argv[]) {
    pid_t pid = fork();
    if (pid < 0) {
        printf("cld: fork failed: errno=%d (%s)\n", errno, strerror(errno));
        return -1;
    }
    if (pid == 0) {
        execv(path, argv);
        _exit(127);
    }

    int st = 0;
    if (waitpid(pid, &st, 0) < 0) {
        printf("cld: waitpid failed: errno=%d (%s)\n", errno, strerror(errno));
        return -2;
    }
    if (WIFEXITED(st)) return (int)WEXITSTATUS(st);
    if (WIFSIGNALED(st)) return 128 + (int)WTERMSIG(st);
    return -3;
}

int main(int argc, char **argv) {
    (void)argc; (void)argv;

    const char *os = detect_os_tag();

    char clinit_path[256];
    char clboot_path[256];
    snprintf(clinit_path, sizeof(clinit_path), "bin/%s/clinit", os);
    snprintf(clboot_path, sizeof(clboot_path), "bin/%s/clboot", os);

    /* ---------------------------------------------------------------------
     * BOOT MODE (SSOT):
     *   Immer Genesis: destroy -> init -> boot
     * --------------------------------------------------------------------- */

    /* 1) Destroy (idempotent) */
    {
        char *args[] = { (char*)clinit_path, (char*)"--destroy", NULL };
        int rc = run_wait(clinit_path, args);
        /* destroy darf ENOENT intern warnen, aber wir lassen rc!=0 nicht fatal werden */
        (void)rc;
    }

    /* 2) Init (Core-only; ZERO-konform) */
    {
        char *args[] = { (char*)clinit_path, NULL };
        int rc = run_wait(clinit_path, args);
        if (rc != 0) {
            printf("cld: clinit failed rc=%d\n", rc);
            return 2;
        }
    }

    /* 3) Boot (Supervisor) – ersetzt cld Prozess */
    {
        char *args[] = { (char*)clboot_path, NULL };
        execv(clboot_path, args);
        printf("cld: exec clboot failed: errno=%d (%s)\n", errno, strerror(errno));
        return 3;
    }
}


<<< END FILE: ./src/cld/cld.c

>>> START FILE: ./src/clinit/clinit.c
/*
 * ============================================================================
 * CommanderLink – clinit (SHM Bootstrap) – ZERO-konform – FINAL
 * Datei: src/clinit/clinit.c
 * ============================================================================
 *
 * ZIEL (ZERO-LAW):
 *   clinit darf keinerlei semantische Werte "setzen".
 *   clinit ist kein Sensor (HAL) und keine Logik (FLOW/LINK).
 *   clinit gießt ausschließlich das Fundament:
 *     - Core-SHM + optional Bulk-SHM anlegen
 *     - Root schreiben (Magic/Schema/Endian/ABI/TOC-Offsets)
 *     - TOC schreiben (Typ/Flags/Stride/Count/Offset)
 *     - ABI/TOC Gate prüfen (Fail-fast, keine stille Drift)
 *
 * KEINE Telemetrie.
 * KEINE Schätzwerte.
 * KEINE Default-Interpretation.
 * Alle Segmentdaten bleiben 0/UNKNOWN bis HAL läuft.
 *
 * ---------------------------------------------------------------------------
 * BOOT-ROADMAP (SSOT):
 *
 *   1) clinit  (dieses Tool)
 *      - SHM anlegen: /cl_core_root (+ optional /cl_bulk)
 *      - Root + TOC schreiben
 *      - ABI/TOC Gate -> "gültiger SHM-Vertrag"
 *
 *   2) Monitor2 (UI, read-only, ohne root)
 *      - shm_open(O_RDONLY) Core
 *      - Root prüfen: magic/schema/endian/abi_checksum
 *      - TOC anzeigen (Segmentliste)
 *      - zeigt "alles 0/UNKNOWN" korrekt, solange HAL aus ist
 *
 *   3) HAL (Wahrnehmung)
 *      - liest Hardware/OS
 *      - schreibt Shadow/Segments (Source/Quality/Epoch)
 *      - KEINE Policy
 *
 *   4) CORE (Herzschlag)
 *      - validiert Shadow
 *      - atomarer Shadow->Active Flip (active_index)
 *      - Gates/Budget/Trust als Wahrheitspfad
 *
 *   5) FLOW (Logik)
 *      - liest Active
 *      - berechnet deterministisch Pacing/Credits/Negotiation
 *      - schreibt Intents
 *
 *   6) LINK (Motorik)
 *      - setzt Intents um (Backend/DMA/Wire)
 *      - liefert Link-Physik zurück
 *
 *   7) ORACLE (Gedächtnis)
 *      - Trends/Hysterese/Evergreens
 *      - greift nicht direkt in Hot-Pfad ein
 *
 * ---------------------------------------------------------------------------
 * CLI:
 *   clinit            -> Core-only (bulk_present=0)
 *   clinit --bulk     -> Core + Bulk (bulk_present=1)
 *   clinit --destroy  -> shm_unlink(core/bulk) und exit
 *
 * ============================================================================
 */

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <stddef.h>
#include <stdalign.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>

#include "cl_runtime/cl_runtime.h" /* -Iinclude */

/* Service-State Segment (Boot/Supervisor SSOT) */
#include "cl_runtime/cl_service_seg_256.h"
/* --------------------------------------------------------------------------
 * Zeitbasis (nur für boot_id_ns; keine Telemetrie)
 * -------------------------------------------------------------------------- */
static uint64_t now_ns(void) {
    struct timespec ts;
#if defined(CLOCK_MONOTONIC)
    clock_gettime(CLOCK_MONOTONIC, &ts);
#else
    clock_gettime(CLOCK_REALTIME, &ts);
#endif
    return (uint64_t)ts.tv_sec * 1000000000ull + (uint64_t)ts.tv_nsec;
}

/* --------------------------------------------------------------------------
 * Alignment helper
 * -------------------------------------------------------------------------- */
static size_t align_up(size_t v, size_t a) {
    if (a == 0) return v;
    size_t r = v % a;
    return r ? (v + (a - r)) : v;
}

/* --------------------------------------------------------------------------
 * ABI-Fingerprint (FNV-1a 64)
 * MUSS exakt identisch zur Fingerprint-Definition im ABI-Report sein.
 * -------------------------------------------------------------------------- */
static uint64_t fnv1a64_init(void) { return 1469598103934665603ull; }
static uint64_t fnv1a64_u64(uint64_t h, uint64_t v) {
    for (int i = 0; i < 8; i++) {
        uint8_t b = (uint8_t)((v >> (i * 8)) & 0xffu);
        h ^= (uint64_t)b;
        h *= 1099511628211ull;
    }
    return h;
}
static uint64_t fnv1a64_u32(uint64_t h, uint32_t v) { return fnv1a64_u64(h, (uint64_t)v); }
static uint64_t fnv1a64_sz(uint64_t h, size_t v) { return fnv1a64_u64(h, (uint64_t)v); }

static uint64_t cl_compute_abi_fingerprint(void) {
    uint64_t h = fnv1a64_init();

    h = fnv1a64_u32(h, (uint32_t)CL_SCHEMA_VERSION_U32);
    h = fnv1a64_u32(h, (uint32_t)CL_ENDIAN_MAGIC_U32);
    h = fnv1a64_u32(h, (uint32_t)CL_SHM_PAGE_BYTES);

    h = fnv1a64_sz(h, sizeof(cl_root_t));
    h = fnv1a64_sz(h, sizeof(cl_toc_header_t));
    h = fnv1a64_sz(h, sizeof(cl_toc_entry_t));
    h = fnv1a64_u32(h, (uint32_t)CL_TOC_MAX_ENTRIES);
    h = fnv1a64_u32(h, (uint32_t)CL_TOC_VERSION);

    /* Segmentgrößen (nur Layout-Wahrheit, keine Inhalte) */
    h = fnv1a64_sz(h, sizeof(cl_cpu_seg_1024_t));
    h = fnv1a64_sz(h, sizeof(cl_budget_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_mem_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_link_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_time_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_overlay_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_watchdog_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_pcie_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_mesh_neighbor_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_mesh_peer_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_oracle_seg_256_t));

    h = fnv1a64_sz(h, sizeof(cl_nic_seg_512_t));
    h = fnv1a64_sz(h, sizeof(cl_board_seg_512_t));

    h = fnv1a64_sz(h, sizeof(cl_dma_seg_4096_t));
    h = fnv1a64_sz(h, sizeof(cl_history_seg_4096_t));
    h = fnv1a64_sz(h, sizeof(cl_forensics_seg_4096_t));
    h = fnv1a64_sz(h, sizeof(cl_zfs_seg_4096_t));

    /* Alignments */
    h = fnv1a64_sz(h, (size_t)alignof(cl_root_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_cpu_seg_1024_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_dma_seg_4096_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_zfs_seg_4096_t));

    /* Root offsets (kritisch) */
    h = fnv1a64_sz(h, offsetof(cl_root_t, abi_layout_checksum));
    h = fnv1a64_sz(h, offsetof(cl_root_t, toc_offset));
    h = fnv1a64_sz(h, offsetof(cl_root_t, toc_size));
    h = fnv1a64_sz(h, offsetof(cl_root_t, schema_version));
    h = fnv1a64_sz(h, offsetof(cl_root_t, endian_magic));
    h = fnv1a64_sz(h, offsetof(cl_root_t, root_magic));
    h = fnv1a64_sz(h, offsetof(cl_root_t, root_flags));
    h = fnv1a64_sz(h, offsetof(cl_root_t, bulk_present));
    h = fnv1a64_sz(h, offsetof(cl_root_t, bulk_epoch));

    /* TOC entry offsets (kritisch) */
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, type));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, stride_bytes));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, count));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, offset_bytes));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, source_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, access_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, presence_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, layout_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, gates_possible));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, gates_effective));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, epoch));

    return h;
}

/* --------------------------------------------------------------------------
 * POSIX SHM helpers
 *
 * Hinweis (Endausbau):
 *   Monitor soll ohne root lesen können.
 *   Dafür braucht es 0660 + Gruppe (z.B. "cl") und User in dieser Gruppe.
 *   Hier setzen wir 0660 deterministisch. Gruppen-/Owner-Politik wird später
 *   im Dienststart (root) gesetzt (TODO unten).
 * -------------------------------------------------------------------------- */
static void warn_unlink(const char *name) {
    if (shm_unlink(name) != 0) {
        if (errno != ENOENT) {
            printf("WARN: shm_unlink(%s) failed: errno=%d (%s)\n", name, errno, strerror(errno));
        }
    }
}

static int shm_create_map_rw(const char *name, size_t sz, void **out_base, int *out_fd) {
    warn_unlink(name);

    int fd = shm_open(name, O_CREAT | O_RDWR, 0660);
    if (fd < 0) return -1;

    /* umask neutralisieren */
    (void)fchmod(fd, 0660);

    /* TODO (Endausbau): wenn als root gestartet, Gruppe auf "cl" setzen:
     *   - gid via getgrnam("cl") (oder manifestierter gid)
     *   - fchown(fd, 0, gid_cl)
     * Damit kann Monitor ohne root lesen (0660).
     */

    if (ftruncate(fd, (off_t)sz) != 0) {
        close(fd);
        return -2;
    }

    void *p = mmap(NULL, sz, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) {
        close(fd);
        return -3;
    }

    *out_base = p;
    *out_fd = fd;
    return 0;
}

static void shm_unmap_close(void *base, size_t sz, int fd) {
    if (base && sz) (void)munmap(base, sz);
    if (fd >= 0) close(fd);
}

/* --------------------------------------------------------------------------
 * TOC helpers (ZERO: nur Geometrie)
 * -------------------------------------------------------------------------- */
static void toc_init(cl_toc_t *toc, uint64_t total_bytes, uint64_t build_id) {
    memset(toc, 0, sizeof(*toc));
    toc->header.version = CL_TOC_VERSION;
    toc->header.entry_count = 0;
    toc->header.total_bytes = total_bytes;
    toc->header.build_id = build_id;
    toc->header.epoch = 1;
}

static void toc_add(cl_toc_t *toc,
                    uint16_t type,
                    uint16_t version,
                    uint32_t flags,
                    uint32_t stride_bytes,
                    uint32_t count,
                    uint64_t offset_bytes,
                    uint16_t source_flags,
                    uint16_t access_flags,
                    uint16_t presence_flags,
                    uint16_t layout_flags)
{
    if (toc->header.entry_count >= CL_TOC_MAX_ENTRIES) return;

    cl_toc_entry_t *e = &toc->entries[toc->header.entry_count++];
    memset(e, 0, sizeof(*e));

    e->type = type;
    e->version = version;
    e->flags = flags;

    e->stride_bytes = stride_bytes;
    e->count = count;
    e->offset_bytes = offset_bytes;

    e->source_flags = source_flags;
    e->access_flags = access_flags;
    e->presence_flags = presence_flags;
    e->layout_flags = layout_flags;

    /* ZERO: keine inhaltlichen Gates hier; bleiben 0 bis HAL/CORE */
    e->gates_possible = 0;
    e->gates_effective = 0;

    /* ZERO: epoch = 0 (UNINITIALIZED) – Validität kommt später aus CORE */
    e->epoch = 0;
}

/* --------------------------------------------------------------------------
 * ABI/TOC Gate (hard; keine stillen SHMs)
 * -------------------------------------------------------------------------- */
static int is_allowed_stride(uint32_t s) {
    return (s == 256u) || (s == 512u) || (s == 1024u) || (s == 4096u);
}
static int check_bounds_u64(uint64_t off, uint64_t len, uint64_t total) {
    if (off > total) return 0;
    if (len > total) return 0;
    if (off + len > total) return 0;
    return 1;
}
static int gate_root_toc(const cl_root_t *r, const cl_toc_t *toc, uint64_t core_total,
                         uint64_t bulk_total, int bulk_present)
{
    if (r->root_magic != CL_ROOT_MAGIC_U32) return 100;
    if (r->schema_version != CL_SCHEMA_VERSION_U32) return 101;
    if (r->endian_magic != CL_ENDIAN_MAGIC_U32) return 102;

    uint64_t want = cl_compute_abi_fingerprint();
    if (r->abi_layout_checksum != want) return 103;

    if (!check_bounds_u64(r->toc_offset, r->toc_size, core_total)) return 104;
    if (r->toc_size < sizeof(cl_toc_header_t)) return 105;

    if (toc->header.version != CL_TOC_VERSION) return 106;
    if (toc->header.entry_count > CL_TOC_MAX_ENTRIES) return 107;

    uint64_t need = (uint64_t)sizeof(cl_toc_header_t) +
                    (uint64_t)toc->header.entry_count * (uint64_t)sizeof(cl_toc_entry_t);
    if (need > r->toc_size) return 108;

    for (uint32_t i = 0; i < toc->header.entry_count; i++) {
        const cl_toc_entry_t *e = &toc->entries[i];
        uint32_t stride = (uint32_t)e->stride_bytes;
        uint32_t count  = (uint32_t)e->count;
        uint64_t off    = (uint64_t)e->offset_bytes;

        if (!is_allowed_stride(stride)) return 120;
        if ((off % (uint64_t)stride) != 0u) return 121;

        uint64_t seg_bytes = (uint64_t)stride * (uint64_t)count;

        const int in_bulk = ((e->flags & CL_TOC_FLAG_RECLAIMABLE) != 0u);
        if (!in_bulk) {
            if (!check_bounds_u64(off, seg_bytes, core_total)) return 122;
        } else {
            if (bulk_present) {
                if (!check_bounds_u64(off, seg_bytes, bulk_total)) return 123;
            }
        }
    }
    return 0;
}

/* --------------------------------------------------------------------------
 * CLI
 * -------------------------------------------------------------------------- */
static void usage(const char *argv0) {
    printf("Usage:\n");
    printf("  %s            Create CORE SHM only\n", argv0);
    printf("  %s --bulk     Create CORE + BULK SHM\n", argv0);
    printf("  %s --destroy  shm_unlink CORE/BULK and exit\n", argv0);
}

int main(int argc, char **argv) {
    int want_bulk = 0;
    int destroy = 0;

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--bulk") == 0) want_bulk = 1;
        else if (strcmp(argv[i], "--destroy") == 0) destroy = 1;
        else if (strcmp(argv[i], "--help") == 0) { usage(argv[0]); return 0; }
        else { usage(argv[0]); return 1; }
    }

    if (destroy) {
        warn_unlink(CL_CORE_SHM_NAME);
        warn_unlink(CL_BULK_SHM_NAME);
        printf("OK: destroyed %s and %s\n", CL_CORE_SHM_NAME, CL_BULK_SHM_NAME);
        return 0;
    }

    const uint64_t abi_fp  = cl_compute_abi_fingerprint();
    const uint64_t boot_ns = now_ns();

    /* Core layout: Root(4096) + TOC(4096) + Segmente */
    const size_t root_off = 0;
    const size_t toc_off  = CL_SHM_PAGE_BYTES;
    const size_t toc_sz   = CL_SHM_PAGE_BYTES;

    size_t off = toc_off + toc_sz;
    off = align_up(off, 256);

    /* Minimal Counts (ZERO: nur Geometrie; spätere Erweiterung über clctl) */
    const uint32_t cpu_count = 1;
    const uint32_t nic_count = 1;
    const uint32_t neighbor_count = 32;

    /* Offsets: stride-aligned; sizes = stride*count */
    size_t off_link     = align_up(off, 256);  off = off_link     + 256;
    size_t off_budget   = align_up(off, 256);  off = off_budget   + 256;
    size_t off_mem      = align_up(off, 256);  off = off_mem      + 256;
    size_t off_overlay  = align_up(off, 256);  off = off_overlay  + 256;
    size_t off_watchdog = align_up(off, 256);  off = off_watchdog + 256;
    size_t off_time     = align_up(off, 256);  off = off_time     + 256;
    size_t off_pcie     = align_up(off, 256);  off = off_pcie     + 256;
    size_t off_oracle   = align_up(off, 256);  off = off_oracle   + 256;
    size_t off_service  = align_up(off, 256);  off = off_service  + 256;

    size_t off_cpu      = align_up(off, 1024); off = off_cpu      + (size_t)cpu_count * 1024;
    size_t off_nic      = align_up(off, 512);  off = off_nic      + (size_t)nic_count * 512;
    size_t off_board    = align_up(off, 512);  off = off_board    + 512;

    size_t off_neighbor = align_up(off, 256);  off = off_neighbor + (size_t)neighbor_count * 256;
    size_t off_zfs      = align_up(off, 4096); off = off_zfs      + 4096;

    const size_t core_total = align_up(off, 4096);

    /* Bulk layout (optional): ZERO: nur Geometrie, Inhalte bleiben 0 */
    size_t bulk_total = 0;
    size_t bulk_off_dma = 0, bulk_off_hist = 0, bulk_off_for = 0;

    if (want_bulk) {
        size_t boff = 0;
        boff = align_up(boff, 4096);
        bulk_off_dma  = align_up(boff, 4096); boff = bulk_off_dma  + 4096;
        bulk_off_hist = align_up(boff, 4096); boff = bulk_off_hist + 4096;
        bulk_off_for  = align_up(boff, 4096); boff = bulk_off_for  + 4096;
        bulk_total = align_up(boff, 4096);
    }

    void *core_base = NULL;
    int core_fd = -1;
    int rc = shm_create_map_rw(CL_CORE_SHM_NAME, core_total, &core_base, &core_fd);
    if (rc != 0) {
        printf("FAIL: create/map core shm (%s): rc=%d errno=%d (%s)\n",
               CL_CORE_SHM_NAME, rc, errno, strerror(errno));
        return 2;
    }

    void *bulk_base = NULL;
    int bulk_fd = -1;
    if (want_bulk) {
        rc = shm_create_map_rw(CL_BULK_SHM_NAME, bulk_total, &bulk_base, &bulk_fd);
        if (rc != 0) {
            printf("FAIL: create/map bulk shm (%s): rc=%d errno=%d (%s)\n",
                   CL_BULK_SHM_NAME, rc, errno, strerror(errno));
            shm_unmap_close(core_base, core_total, core_fd);
            return 3;
        }
    } else {
        warn_unlink(CL_BULK_SHM_NAME);
    }

    /* ZERO: Datenbereiche sind nur Null; keine Telemetrie */
    memset(core_base, 0, core_total);
    if (want_bulk) memset(bulk_base, 0, bulk_total);

    cl_root_t *root = (cl_root_t*)((uint8_t*)core_base + root_off);
    cl_toc_t  *toc  = (cl_toc_t*)((uint8_t*)core_base + toc_off);

    /* Root: Notfall-Wahrheit (minimal, deterministisch) */
    root->abi_layout_checksum = abi_fp;

    atomic_store(&root->seq_cnt, 1u);
    atomic_store(&root->uptime_ns, 0u);
    atomic_store(&root->bulk_epoch, 0u);

    root->boot_id_ns = boot_ns;

    /* ZERO: Identitäten werden später durch Provisioning/HAL gesetzt */
    root->mesh_tag64 = 0;
    root->node_tag64 = 0;

    root->toc_offset = (uint64_t)toc_off;
    root->toc_size   = (uint64_t)toc_sz;

    root->root_magic = CL_ROOT_MAGIC_U32;
    root->root_flags = CL_ROOT_FLAG_FAILFAST_ABI;

    root->schema_version = CL_SCHEMA_VERSION_U32;
    root->endian_magic   = CL_ENDIAN_MAGIC_U32;

    atomic_store(&root->bulk_present, want_bulk ? 1u : 0u);

    /* TOC: reine Geometrie */
    toc_init(toc, (uint64_t)(core_total + bulk_total), abi_fp);

    toc_add(toc, (uint16_t)CL_LINK_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL,
            256, 1, (uint64_t)off_link,
            CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_BUDGET_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL,
            256, 1, (uint64_t)off_budget,
            CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_MEM_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_DATA,
            256, 1, (uint64_t)off_mem,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_OVERLAY_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_CONTROL,
            256, 1, (uint64_t)off_overlay,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_WATCHDOG_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL | CL_TOC_FLAG_FORENSICS,
            256, 1, (uint64_t)off_watchdog,
            CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_TIME_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_CONTROL,
            256, 1, (uint64_t)off_time,
            CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_PCIE_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_DATA,
            256, 1, (uint64_t)off_pcie,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_ORACLE_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_COLD | CL_TOC_FLAG_DATA,
            256, 1, (uint64_t)off_oracle,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_SERVICE_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL | CL_TOC_FLAG_CRITICAL,
            256, 1, (uint64_t)off_service,
            CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);


    toc_add(toc, (uint16_t)CL_CPU_SEG_1024, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA | CL_TOC_FLAG_FIXED_COUNT,
            1024, cpu_count, (uint64_t)off_cpu,
            CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_NIC_SEG_512, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA | CL_TOC_FLAG_FIXED_COUNT,
            512, nic_count, (uint64_t)off_nic,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_BOARD_SEG_512, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_DATA,
            512, 1, (uint64_t)off_board,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    toc_add(toc, (uint16_t)CL_MESH_NEIGHBOR_SEG_256, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA | CL_TOC_FLAG_FIXED_COUNT,
            256, neighbor_count, (uint64_t)off_neighbor,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE | CL_TOC_LAYOUT_ARRAY);

    toc_add(toc, (uint16_t)CL_ZFS_SEG_4096, 1,
            CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_COLD | CL_TOC_FLAG_DATA,
            4096, 1, (uint64_t)off_zfs,
            CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
            CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

    if (want_bulk) {
        toc_add(toc, (uint16_t)CL_DMA_SEG_4096, 1,
                CL_TOC_FLAG_RECLAIMABLE | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA,
                4096, 1, (uint64_t)bulk_off_dma,
                CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

        toc_add(toc, (uint16_t)CL_HISTORY_SEG_4096, 1,
                CL_TOC_FLAG_RECLAIMABLE | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_COLD | CL_TOC_FLAG_FORENSICS,
                4096, 1, (uint64_t)bulk_off_hist,
                CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
                CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);

        toc_add(toc, (uint16_t)CL_FORENSICS_SEG_4096, 1,
                CL_TOC_FLAG_RECLAIMABLE | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_COLD | CL_TOC_FLAG_FORENSICS,
                4096, 1, (uint64_t)bulk_off_for,
                CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE,
                CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE);
    }

    msync(core_base, core_total, MS_SYNC);
    if (want_bulk) msync(bulk_base, bulk_total, MS_SYNC);

    /* ABI/TOC Gate */
    int gate = gate_root_toc(root, toc, (uint64_t)core_total, (uint64_t)bulk_total, want_bulk);
    if (gate != 0) {
        printf("FAIL: clinit gate failed: code=%d\n", gate);
        shm_unmap_close(core_base, core_total, core_fd);
        if (want_bulk) shm_unmap_close(bulk_base, bulk_total, bulk_fd);
        return 10;
    }

    /* Prints: nur lokale Kopien, ZERO-konform */
    const uint32_t toc_entries = toc->header.entry_count;
    const uint64_t core_sz_out = (uint64_t)core_total;
    const uint64_t bulk_sz_out = (uint64_t)bulk_total;
    const uint64_t abi_out     = abi_fp;

    shm_unmap_close(core_base, core_total, core_fd);
    if (want_bulk) shm_unmap_close(bulk_base, bulk_total, bulk_fd);

    printf("OK: clinit created core=%s size=%" PRIu64 "\n", CL_CORE_SHM_NAME, core_sz_out);
    if (want_bulk) printf("OK: clinit created bulk=%s size=%" PRIu64 "\n", CL_BULK_SHM_NAME, bulk_sz_out);
    printf("ABI checksum: 0x%016" PRIx64 "\n", abi_out);
    printf("TOC entries: %u\n", (unsigned)toc_entries);

    return 0;
}


<<< END FILE: ./src/clinit/clinit.c

>>> START FILE: ./src/core/core0.c
/* ============================================================================
 * CommanderLink – CORE0 (Endausbau, SSOT-konform, Authority-Richter)
 * Datei: src/core/core0.c
 * ============================================================================
 *
 * KERNVERTRAG (SSOT):
 * - SHM ist Wahrheit; TOC verkabelt Segmente.
 * - Validität pro Segment = TOC entry.epoch (epoch==0 => UNINITIALIZED).
 * - CORE publisht deterministisch über Release-Store auf entry.epoch (Cut-Point).
 * - CORE ist Authority für:
 *     * gates_possible / gates_effective (TOC + global)
 *     * Watchdog state/reason (Latching, Priorität, Recovery)
 *     * Root Quick-Views als Spiegel/Abkürzung (keine zweite Wahrheit)
 * - CORE setzt KEIN Redirect (LINK-only), setzt KEINE OS-Routen, keine Sideeffects.
 *
 * ENDAUSBAU-PRINZIP:
 * - Keine "memset(0)" auf fremde Telemetriesegmente.
 * - Auswertung: CPU/NIC/BOARD/BUDGET/TIME/MESH_PEER/LINK.
 * - Worst-Case: Bei fehlender Telemetrie => konservativ (Gates schließen, Trust none).
 *
 * Hinweis:
 * - Diese Datei nutzt exakt die Typen aus deinem Dump:
 *   cl_root_4096_t, cl_toc_header_t, cl_toc_entry_t, Segmenttypen aus cl_runtime.h.
 */

#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <signal.h>
#include <stdatomic.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>

#include "cl_runtime/cl_runtime.h"   /* Frontdoor */
#include "cl_runtime/cl_toc.h"       /* cl_toc_header_t / cl_toc_entry_t / IDs */
#include "cl_runtime/cl_shm_layout.h"
#include "cl_runtime/cl_gates.h"
#include "cl_runtime/cl_service_seg_256.h"
#include "cl_runtime/cl_seg_watchdog_256.h"
#include "cl_runtime/cl_seg_time_256.h"
#include "cl_runtime/cl_seg_cpu_1024.h"
#include "cl_runtime/cl_seg_nic_512.h"
#include "cl_runtime/cl_seg_board_512.h"
#include "cl_runtime/cl_seg_budget_256.h"
#include "cl_runtime/cl_seg_link_256.h"
#include "cl_runtime/cl_seg_mesh_peer_256.h"

/* -------------------------------------------------------------------------- */

#ifndef CL_NS_PER_S
#define CL_NS_PER_S 1000000000ull
#endif

#ifndef CL_CORE_DEFAULT_TICK_MS
#define CL_CORE_DEFAULT_TICK_MS 50u
#endif

/* Root Page ist 4096B (Schema) */
#ifndef CL_ROOT_BYTES
#define CL_ROOT_BYTES 4096u
#endif

/* -------------------------------------------------------------------------- */
/* Signal Handling                                                            */
/* -------------------------------------------------------------------------- */

static volatile sig_atomic_t g_stop = 0;

static void core0_on_signal(int signo) {
    (void)signo;
    g_stop = 1;
}

/* -------------------------------------------------------------------------- */
/* Zeitbasis                                                                  */
/* -------------------------------------------------------------------------- */

static uint64_t core0_now_ns_monotonic(void) {
    struct timespec ts;
    if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0) {
        return 0;
    }
    return (uint64_t)ts.tv_sec * CL_NS_PER_S + (uint64_t)ts.tv_nsec;
}

/* -------------------------------------------------------------------------- */
/* SHM Mapping                                                                */
/* -------------------------------------------------------------------------- */

typedef struct core0_map_s {
    int      fd;
    uint8_t *base;
    size_t   size;
} core0_map_t;

/* In deinem Root-Header stehen die Namen:
 *   CL_CORE_SHM_NAME = "/cl_core_root"
 */
#ifndef CL_CORE_SHM_NAME
#define CL_CORE_SHM_NAME "/cl_core_root"
#endif

static int core0_map_open(core0_map_t *m, const char *shm_name, size_t min_size) {
    memset(m, 0, sizeof(*m));
    m->fd = shm_open(shm_name, O_RDWR, 0600);
    if (m->fd < 0) return -1;

    struct stat st;
    if (fstat(m->fd, &st) != 0) {
        close(m->fd);
        m->fd = -1;
        return -1;
    }
    if ((size_t)st.st_size < min_size) {
        close(m->fd);
        m->fd = -1;
        errno = EINVAL;
        return -1;
    }

    m->size = (size_t)st.st_size;
    m->base = (uint8_t *)mmap(NULL, m->size, PROT_READ | PROT_WRITE, MAP_SHARED, m->fd, 0);
    if (m->base == MAP_FAILED) {
        m->base = NULL;
        close(m->fd);
        m->fd = -1;
        return -1;
    }
    return 0;
}

static void core0_map_close(core0_map_t *m) {
    if (m->base) {
        (void)munmap(m->base, m->size);
        m->base = NULL;
    }
    if (m->fd >= 0) {
        (void)close(m->fd);
        m->fd = -1;
    }
    m->size = 0;
}

/* -------------------------------------------------------------------------- */
/* Root / TOC Zugriff (SSOT)                                                  */
/* -------------------------------------------------------------------------- */

static inline cl_root_4096_t *core0_root_ptr(uint8_t *base) {
    return (cl_root_4096_t *)(void *)base;
}

static inline cl_toc_header_t *core0_toc_hdr_ptr(uint8_t *base, const cl_root_4096_t *root) {
    return (cl_toc_header_t *)(void *)(base + (size_t)root->toc_offset);
}

static inline cl_toc_entry_t *core0_toc_entries_ptr(cl_toc_header_t *hdr) {
    /* Header ist 64B, Entries folgen direkt */
    return (cl_toc_entry_t *)(void *)((uint8_t *)(void *)hdr + sizeof(*hdr));
}

static cl_toc_entry_t *core0_toc_find_entry_mut(cl_toc_header_t *hdr, cl_toc_entry_t *ent, uint16_t type) {
    const uint32_t n = hdr->entry_count;
    for (uint32_t i = 0; i < n; i++) {
        if (ent[i].type == type) return &ent[i];
    }
    return NULL;
}

static const cl_toc_entry_t *core0_toc_find_entry(const cl_toc_header_t *hdr, const cl_toc_entry_t *ent, uint16_t type) {
    const uint32_t n = hdr->entry_count;
    for (uint32_t i = 0; i < n; i++) {
        if (ent[i].type == type) return &ent[i];
    }
    return NULL;
}

static void *core0_seg_ptr(uint8_t *base, size_t map_size, const cl_toc_entry_t *e) {
    const uint64_t off   = e->offset_bytes;
    const uint64_t bytes = (uint64_t)e->stride_bytes * (uint64_t)e->count;

    if (off == 0 || bytes == 0) return NULL;
    if (off + bytes > (uint64_t)map_size) return NULL;

    return (void *)(base + (size_t)off);
}

/* -------------------------------------------------------------------------- */
/* Epoch Publish (Cut-Point)                                                  */
/* -------------------------------------------------------------------------- */

static uint64_t core0_next_epoch_u64(uint64_t cur) {
    /* epoch==0 ist UNINITIALIZED. CORE bump’t immer auf >=1. */
    uint64_t n = (cur == 0) ? 1ull : (cur + 1ull);
    if (n == 0) n = 1ull;
    return n;
}

static void core0_publish_epoch(cl_toc_entry_t *e, uint64_t next_epoch) {
    atomic_store_explicit((_Atomic(uint64_t) *)&e->epoch, next_epoch, memory_order_release);
}

/* Reader-Gating: Segment ist nur "brauchbar", wenn epoch>0 und presence PRESENT (und nicht RECLAIMED). */
static bool core0_entry_readable(const cl_root_4096_t *root, const cl_toc_entry_t *e) {
    (void)root;
    const uint64_t ep = atomic_load_explicit((_Atomic(uint64_t) *)&e->epoch, memory_order_acquire);
    if (ep == 0) return false;

    /* presence_flags ist SSOT: RECLAIMED dominiert */
    if ((e->presence_flags & CL_TOC_RECLAIMED) != 0) return false;

    /* Bulk-Segmente sind RECLAIMED, wenn root.bulk_present == 0 und RECLAIMABLE gesetzt ist.
     * (Monitor-Regel; CORE behandelt das gleich konservativ fürs Lesen.)
     */
    if ((e->flags & CL_TOC_FLAG_RECLAIMABLE) != 0) {
        const uint32_t bp = atomic_load_explicit(&root->bulk_present, memory_order_relaxed);
        if (bp == 0) return false;
    }

    /* UNSUPPORTED -> nicht kontrollwirksam */
    if ((e->source_flags & CL_TOC_SOURCE_UNSUPPORTED) != 0) return false;

    return true;
}

/* -------------------------------------------------------------------------- */
/* Reason / Priority (minimal, deterministisch)                               */
/* -------------------------------------------------------------------------- */

/* In den Segmenten existieren reason_code / constraint_flags (u32), aber das konkrete Enum
 * liegt in cl_manifest/cl_enums.h. Wir dürfen hier keine Policy erfinden.
 *
 * Deshalb: CORE arbeitet primär mit GATES (u64) als physikalische Wahrheit.
 * root.reason_code wird als "best-effort Spiegel" gesetzt:
 *   - 0 = none/ok (konservativ)
 *   - sonst bleibt es bei den Input-Reasons, sofern vorhanden.
 *
 * Watchdog hat eigene Reasons (cl_wd_reason_t) – dort ist Latching Pflicht.
 */

static uint32_t core0_u32_min(uint32_t a, uint32_t b) { return (a < b) ? a : b; }
static uint32_t core0_u32_max(uint32_t a, uint32_t b) { return (a > b) ? a : b; }

/* -------------------------------------------------------------------------- */
/* Watchdog Latching (CORE Authority)                                         */
/* -------------------------------------------------------------------------- */

typedef struct core0_wd_eval_s {
    cl_wd_state_t  state;
    cl_wd_reason_t reason;
    cl_wd_module_t module;
    uint64_t       last_progress_ns;
} core0_wd_eval_t;

static core0_wd_eval_t core0_watchdog_eval(const cl_root_4096_t *root,
                                          cl_watchdog_seg_256_t *wd,
                                          const cl_toc_header_t *toc_hdr,
                                          const cl_toc_entry_t *toc_ent,
                                          uint64_t now_ns)
{
    (void)toc_hdr;
    (void)toc_ent;

    core0_wd_eval_t out;
    out.state = CL_WD_OK;
    out.reason = CL_WD_R_NONE;
    out.module = CL_WD_MOD_NONE;

    /* Policy/Thresholds (COLD) – konservativ, aber sichtbar */
    const uint32_t warn_th = wd->cold.warn_ns_threshold ? wd->cold.warn_ns_threshold : 250000000u;   /* 250ms */
    const uint32_t stall_th = wd->cold.stall_ns_threshold ? wd->cold.stall_ns_threshold : 2000000000u;/* 2s */

    /* Liveness: Module ticks */
    const uint64_t hal_tick    = atomic_load_explicit(&wd->hot_a.hal_tick_ns,    memory_order_relaxed);
    const uint64_t core_tick   = atomic_load_explicit(&wd->hot_a.core_tick_ns,   memory_order_relaxed);
    const uint64_t flow_tick   = atomic_load_explicit(&wd->hot_a.flow_tick_ns,   memory_order_relaxed);
    const uint64_t link_tick   = atomic_load_explicit(&wd->hot_a.link_tick_ns,   memory_order_relaxed);
    const uint64_t oracle_tick = atomic_load_explicit(&wd->hot_a.oracle_tick_ns, memory_order_relaxed);

    /* "progress": wenn root.seq_cnt/uptime_ns sich bewegt oder LINK commit epoch steigt.
     * Hier minimal: nutze root.seq_cnt (monotone) als Fortschrittssignal, wenn vorhanden.
     */
    const uint64_t root_seq = atomic_load_explicit(&root->seq_cnt, memory_order_relaxed);

    const uint64_t last_root_seq = atomic_load_explicit(&wd->hot_b.last_root_seq_cnt, memory_order_relaxed);
    uint64_t last_progress = atomic_load_explicit(&wd->hot_b.last_progress_ns, memory_order_relaxed);

    if (root_seq != last_root_seq) {
        last_progress = now_ns;
        /* Update progress marker (relaxed; publish über CORE-epoch an WD-Entry) */
        atomic_store_explicit(&wd->hot_b.last_progress_ns, last_progress, memory_order_relaxed);
        atomic_store_explicit(&wd->hot_b.last_root_seq_cnt, root_seq, memory_order_relaxed);
    }
    out.last_progress_ns = last_progress;

    /* Stall-Check Helper */
    auto uint64_t age(uint64_t t) -> uint64_t { return (t == 0 || now_ns < t) ? UINT64_MAX : (now_ns - t); };

    /* Bestimme schlimmste Liveness-Abweichung (Warn/Stall) */
    struct {
        cl_wd_module_t mod;
        cl_wd_reason_t r_warn;
        cl_wd_reason_t r_stall;
        uint64_t       tick_ns;
    } mods[] = {
        { CL_WD_MOD_HAL,    CL_WD_R_NONE, CL_WD_R_STALL_HAL,    hal_tick    },
        { CL_WD_MOD_CORE,   CL_WD_R_NONE, CL_WD_R_STALL_CORE,   core_tick   },
        { CL_WD_MOD_FLOW,   CL_WD_R_NONE, CL_WD_R_STALL_FLOW,   flow_tick   },
        { CL_WD_MOD_LINK,   CL_WD_R_NONE, CL_WD_R_STALL_LINK,   link_tick   },
        { CL_WD_MOD_ORACLE, CL_WD_R_NONE, CL_WD_R_STALL_ORACLE, oracle_tick }
    };

    cl_wd_state_t worst_state = CL_WD_OK;
    cl_wd_reason_t worst_reason = CL_WD_R_NONE;
    cl_wd_module_t worst_mod = CL_WD_MOD_NONE;

    for (size_t i = 0; i < sizeof(mods)/sizeof(mods[0]); i++) {
        const uint64_t a = age(mods[i].tick_ns);
        if (a == UINT64_MAX) {
            /* Wenn ein Modul noch nie getickt hat, ist das im Endausbau ein Warnsignal,
             * aber nicht sofort Stall, solange progress existiert.
             */
            if (worst_state < CL_WD_WARN) {
                worst_state = CL_WD_WARN;
                worst_reason = mods[i].r_stall; /* reuse: "stall <mod>" als Diagnose */
                worst_mod = mods[i].mod;
            }
            continue;
        }

        if (a >= (uint64_t)stall_th) {
            worst_state = CL_WD_STALL;
            worst_reason = mods[i].r_stall;
            worst_mod = mods[i].mod;
            break; /* Stall dominiert */
        }
        if (a >= (uint64_t)warn_th) {
            if (worst_state < CL_WD_WARN) {
                worst_state = CL_WD_WARN;
                worst_reason = mods[i].r_stall; /* Diagnose */
                worst_mod = mods[i].mod;
            }
        }
    }

    /* Progress-Stall: wenn über stall_th kein Fortschritt, escalate zu STALL/PANIC */
    if (last_progress != 0 && now_ns >= last_progress) {
        const uint64_t prog_age = now_ns - last_progress;
        if (prog_age >= (uint64_t)stall_th) {
            /* Fortschrittsstillstand ist härter als einzelne Tick-Warnungen */
            worst_state = CL_WD_STALL;
            if (worst_reason == CL_WD_R_NONE) worst_reason = CL_WD_R_INVARIANT_BREACH;
            if (worst_mod == CL_WD_MOD_NONE) worst_mod = CL_WD_MOD_CORE;
        }
    }

    /* Latching: schreibe NICHT jedes Tick Reason zurück auf NONE.
     * Regel:
     * - Wenn neuer Zustand schlimmer -> übernehmen.
     * - Wenn neuer Zustand besser -> erst übernehmen, wenn tatsächlich alle Bedingungen ok sind.
     */
    const uint32_t cur_state_u32  = atomic_load_explicit(&wd->hot_b.wd_state, memory_order_relaxed);
    const uint32_t cur_reason_u32 = atomic_load_explicit(&wd->hot_b.wd_reason, memory_order_relaxed);
    const uint32_t cur_mod_u32    = atomic_load_explicit(&wd->hot_b.last_stall_module, memory_order_relaxed);

    const cl_wd_state_t cur_state = (cl_wd_state_t)cur_state_u32;
    const cl_wd_reason_t cur_reason = (cl_wd_reason_t)cur_reason_u32;
    const cl_wd_module_t cur_mod = (cl_wd_module_t)cur_mod_u32;

    out.state  = cur_state;
    out.reason = cur_reason;
    out.module = cur_mod;

    if (worst_state > cur_state) {
        /* Verschlechterung: sofort latched */
        out.state  = worst_state;
        out.reason = worst_reason;
        out.module = worst_mod;
    } else if (worst_state < cur_state) {
        /* Verbesserung: nur wenn wirklich OK und progress ok */
        if (worst_state == CL_WD_OK) {
            out.state  = CL_WD_OK;
            out.reason = CL_WD_R_NONE;
            out.module = CL_WD_MOD_NONE;
        } else {
            /* z.B. STALL -> WARN, latche WARN */
            out.state  = worst_state;
            out.reason = worst_reason;
            out.module = worst_mod;
        }
    } else {
        /* Gleich: wenn cur_reason NONE aber worst_reason != NONE, setze Diagnose */
        if (out.reason == CL_WD_R_NONE && worst_reason != CL_WD_R_NONE) {
            out.reason = worst_reason;
            out.module = worst_mod;
        }
    }

    return out;
}

/* -------------------------------------------------------------------------- */
/* Physik-Auswertung -> Gates (global)                                        */
/* -------------------------------------------------------------------------- */

typedef struct core0_inputs_s {
    bool have_cpu;
    bool have_nic;
    bool have_board;
    bool have_budget;
    bool have_time;
    bool have_link;
    bool have_mesh_peer;
    bool have_watchdog;

    /* Snapshots (best-effort) */
    uint32_t cpu_temp_c_x10;
    uint32_t cpu_throttling;      /* 0/1 */
    uint32_t cpu_load_permille;

    uint32_t nic_thermal_state;   /* enum numeric */
    uint32_t nic_loss_ppm;
    uint32_t nic_jitter_p99_us;
    uint32_t nic_rxq_fill;
    uint32_t nic_txq_fill;

    uint32_t board_therm_state;
    uint32_t board_power_unstable; /* 0/1 */
    uint32_t vrm_temp_c_x10;
    uint32_t vrm_ripple_mv_x10;

    uint32_t budget_interactive_hint; /* 0/1 */
    uint32_t budget_cpu_pressure;
    uint32_t budget_mem_pressure;

    uint32_t link_path_state;
    uint32_t link_backend_active;
    uint32_t link_mode_active;
    uint32_t link_profile_effective;
    uint32_t link_constraint_flags;
    uint32_t link_reason_code;
    uint32_t link_global_health;

    uint16_t trusted_peer_count; /* root quick view */
} core0_inputs_t;

static cl_gate_state_t core0_eval_gates(const core0_inputs_t *in,
                                       const core0_wd_eval_t *wd,
                                       bool trust_active)
{
    cl_gate_state_t gs;
    gs.possible = 0;
    gs.effective = 0;

    /* possible: was physikalisch/logisch möglich ist.
     * In Endausbau: possible ist i.d.R. "alles" minus harte Plattform-Verbote.
     * Da wir hier keine Plattform-Heuristik/CPUID implementieren (HAL macht das),
     * setzen wir possible = 0 und lassen effective als Wahrheit wirken.
     * Monitor sieht: unknown -> conservative.
     */

    /* Watchdog */
    if (wd->state >= CL_WD_STALL) {
        gs.effective |= CL_GATE_WATCHDOG_TRIGGERED;
    }

    /* Interaktivität/Budget: Schutz des OS/Users */
    if (in->have_budget && in->budget_interactive_hint) {
        gs.effective |= CL_GATE_INTERACTIVE_ACTIVE;
    }
    if (in->have_budget) {
        /* Wenn Druck hoch ist: budget exceeded */
        if (in->budget_cpu_pressure >= 900 || in->budget_mem_pressure >= 900) {
            gs.effective |= CL_GATE_BUDGET_EXCEEDED;
        }
    }

    /* Thermik: konservativ – wenn throttling aktiv, mindestens SOFT */
    if (in->have_cpu) {
        if (in->cpu_throttling) {
            gs.effective |= CL_GATE_THERMAL_SOFT;
        }
        /* Optional: Temperatur heuristisch (x10 °C).
         * Ohne spezifizierte Schwellen darf CORE keine policy erfinden.
         * Wir benutzen daher nur eine sehr grobe, deterministische Schwelle,
         * die als "soft indicator" gilt:
         *   >= 900 (90.0°C) -> HARD
         *   >= 800 (80.0°C) -> SOFT
         * Diese Schwelle ist bewusst konservativ.
         */
        if (in->cpu_temp_c_x10 >= 900) gs.effective |= CL_GATE_THERMAL_HARD;
        else if (in->cpu_temp_c_x10 >= 800) gs.effective |= CL_GATE_THERMAL_SOFT;
    }

    /* NIC thermals / DOM: wenn NIC thermal_state nicht ok, setze SOFT */
    if (in->have_nic) {
        /* numeric state: keine Enum hier; wir interpretieren 0 als unknown/ok.
         * Jede non-zero state wird als "soft thermal" betrachtet.
         */
        if (in->nic_thermal_state != 0) {
            gs.effective |= CL_GATE_THERMAL_SOFT;
        }
        /* Queue pressure als Budget/Interactive proxy */
        if (in->nic_rxq_fill >= 950 || in->nic_txq_fill >= 950) {
            gs.effective |= CL_GATE_BUDGET_EXCEEDED;
        }
    }

    /* Board/VRM: Power instabil => HARD/VRM_LIMIT */
    if (in->have_board) {
        if (in->board_power_unstable) {
            gs.effective |= CL_GATE_POWER_HARD;
            gs.effective |= CL_GATE_VRM_LIMIT;
        }
        /* VRM ripple hoch -> soft power */
        if (in->vrm_ripple_mv_x10 >= 200) { /* 20.0mV ripple als konservativer Hinweis */
            gs.effective |= CL_GATE_POWER_SOFT;
        }
        /* VRM temp hoch -> thermal */
        if (in->vrm_temp_c_x10 >= 950) gs.effective |= CL_GATE_THERMAL_HARD;
        else if (in->vrm_temp_c_x10 >= 850) gs.effective |= CL_GATE_THERMAL_SOFT;
    }

    /* Trust gates: Default-deny ist physikalische Wahrheit (Security/Join).
     * - Wenn trust_active -> ACTIVE/ESTABLISHED.
     * - Sonst -> TRUST_NONE.
     */
    if (trust_active) {
        gs.effective |= CL_GATE_TRUST_ESTABLISHED;
        gs.effective |= CL_GATE_TRUST_ACTIVE;
    } else {
        gs.effective |= CL_GATE_TRUST_NONE;
    }

    /* Security Degraded: wenn Watchdog oder Trust fehlt => degraded */
    if (!trust_active || (gs.effective & CL_GATE_WATCHDOG_TRIGGERED)) {
        gs.effective |= CL_GATE_SECURITY_DEGRADED;
    }

    return gs;
}

/* -------------------------------------------------------------------------- */
/* Trust Ableitung (konservativ)                                              */
/* -------------------------------------------------------------------------- */

static bool core0_eval_trust_active(const cl_root_4096_t *root,
                                   const cl_toc_header_t *toc_hdr,
                                   const cl_toc_entry_t *toc_ent,
                                   uint8_t *base, size_t map_size)
{
    /* Quick-View: trusted_peer_count */
    const uint32_t tpc = atomic_load_explicit(&root->trusted_peer_count, memory_order_relaxed);
    if (tpc == 0) return false;

    /* Zusätzlich: Mesh Peer Segmente lesen (falls vorhanden) und prüfen, ob irgendein Peer
     * plausibel "trusted" ist (trust_state != 0).
     * Wir kennen die Enum-Werte nicht, daher minimal:
     *   trust_state != 0 gilt als "irgendein Trust-Level vorhanden".
     */
    const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_MESH_PEER_SEG_256);
    if (!e) return true; /* Quick-View reicht, wenn Segment fehlt */

    if (!core0_entry_readable(root, e)) return false;

    const cl_mesh_peer_seg_256_t *p = (const cl_mesh_peer_seg_256_t *)core0_seg_ptr(base, map_size, e);
    if (!p) return false;

    const uint32_t n = e->count;
    for (uint32_t i = 0; i < n; i++) {
        const uint32_t ts = atomic_load_explicit(&p[i].hot.trust_state, memory_order_relaxed);
        if (ts != 0) return true;
    }
    return false;
}

/* -------------------------------------------------------------------------- */
/* Service Heartbeat (CORE Slot 0)                                            */
/* -------------------------------------------------------------------------- */

static void core0_service_heartbeat(const cl_root_4096_t *root,
                                   const cl_toc_header_t *toc_hdr,
                                   cl_toc_entry_t *toc_ent,
                                   uint8_t *base, size_t map_size,
                                   uint64_t now_ns)
{
    (void)root;

    cl_toc_entry_t *e = core0_toc_find_entry_mut((cl_toc_header_t *)toc_hdr, toc_ent, (uint16_t)CL_SERVICE_SEG_256);
    if (!e) return;

    /* SERVICE ist resident/control, wird vom Supervisor initialisiert.
     * CORE schreibt nur last_heartbeat_ns.
     */
    if (!core0_entry_readable((const cl_root_4096_t *)root, e)) {
        /* Wenn epoch==0, darf CORE trotzdem schreiben? SSOT sagt: clinit setzt epoch=0,
         * CORE ist Publisher: wir publishten dieses Segment über epoch.
         * => Wir erlauben Schreiben, publishen danach.
         */
    }

    cl_service_seg_256_t *svc = (cl_service_seg_256_t *)core0_seg_ptr(base, map_size, e);
    if (!svc) return;

    /* Slot CORE0 = s0 in g1 */
    atomic_store_explicit(&svc->g1.s0.last_heartbeat_ns, now_ns, memory_order_relaxed);
    atomic_store_explicit(&svc->g1.s0.pid, (uint32_t)getpid(), memory_order_relaxed);
    atomic_store_explicit(&svc->g1.s0.running, 1u, memory_order_relaxed);

    const uint64_t cur = atomic_load_explicit((_Atomic(uint64_t) *)&e->epoch, memory_order_acquire);
    core0_publish_epoch(e, core0_next_epoch_u64(cur));
}

/* -------------------------------------------------------------------------- */
/* CORE Hauptauswertung + Publish                                              */
/* -------------------------------------------------------------------------- */

static void core0_tick(core0_map_t *m)
{
    uint8_t *base = m->base;
    const size_t map_size = m->size;

    cl_root_4096_t *root = core0_root_ptr(base);
    cl_toc_header_t *toc_hdr = core0_toc_hdr_ptr(base, root);
    cl_toc_entry_t  *toc_ent = core0_toc_entries_ptr(toc_hdr);

    const uint64_t now_ns = core0_now_ns_monotonic();
    if (now_ns == 0) return;

    /* ---- Inputs einsammeln (nur lesen; strikt epoch-gated) ---- */
    core0_inputs_t in;
    memset(&in, 0, sizeof(in));

    /* CPU */
    {
        const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_CPU_SEG_1024);
        if (e && core0_entry_readable(root, e)) {
            const cl_cpu_seg_1024_t *cpu = (const cl_cpu_seg_1024_t *)core0_seg_ptr(base, map_size, e);
            if (cpu) {
                in.have_cpu = true;
                in.cpu_temp_c_x10 = atomic_load_explicit(&cpu[0].hot_a.temp_c_x10, memory_order_relaxed);
                in.cpu_throttling = atomic_load_explicit(&cpu[0].hot_a.throttling, memory_order_relaxed);
                in.cpu_load_permille = atomic_load_explicit(&cpu[0].hot_a.load_permille, memory_order_relaxed);
            }
        }
    }

    /* NIC */
    {
        const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_NIC_SEG_512);
        if (e && core0_entry_readable(root, e)) {
            const cl_nic_seg_512_t *nic = (const cl_nic_seg_512_t *)core0_seg_ptr(base, map_size, e);
            if (nic) {
                in.have_nic = true;
                in.nic_rxq_fill = atomic_load_explicit(&nic[0].warm_a.rx_queue_fill_permille, memory_order_relaxed);
                in.nic_txq_fill = atomic_load_explicit(&nic[0].warm_a.tx_queue_fill_permille, memory_order_relaxed);
                in.nic_loss_ppm = atomic_load_explicit(&nic[0].warm_b.loss_ppm, memory_order_relaxed);
                in.nic_jitter_p99_us = atomic_load_explicit(&nic[0].warm_b.jitter_p99_us, memory_order_relaxed);
                in.nic_thermal_state = atomic_load_explicit(&nic[0].warm_b.thermal_state, memory_order_relaxed);
            }
        }
    }

    /* BOARD */
    {
        const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_BOARD_SEG_512);
        if (e && core0_entry_readable(root, e)) {
            const cl_board_seg_512_t *b = (const cl_board_seg_512_t *)core0_seg_ptr(base, map_size, e);
            if (b) {
                in.have_board = true;
                in.board_therm_state = atomic_load_explicit(&b[0].hot_a.board_therm_state, memory_order_relaxed);
                in.board_power_unstable = atomic_load_explicit(&b[0].hot_a.power_unstable, memory_order_relaxed);
                in.vrm_temp_c_x10 = atomic_load_explicit(&b[0].hot_a.vrm_temp_c_x10, memory_order_relaxed);
                in.vrm_ripple_mv_x10 = atomic_load_explicit(&b[0].hot_a.vrm_ripple_mv_x10, memory_order_relaxed);
            }
        }
    }

    /* BUDGET */
    {
        const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_BUDGET_SEG_256);
        if (e && core0_entry_readable(root, e)) {
            const cl_budget_seg_256_t *b = (const cl_budget_seg_256_t *)core0_seg_ptr(base, map_size, e);
            if (b) {
                in.have_budget = true;
                in.budget_interactive_hint = atomic_load_explicit(&b[0].hot.interactive_hint, memory_order_relaxed);
                in.budget_cpu_pressure = atomic_load_explicit(&b[0].hot.cpu_pressure_permille, memory_order_relaxed);
                in.budget_mem_pressure = atomic_load_explicit(&b[0].hot.mem_pressure_permille, memory_order_relaxed);
            }
        }
    }

    /* TIMEBASE */
    {
        const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_TIME_SEG_256);
        if (e && core0_entry_readable(root, e)) {
            const cl_time_seg_256_t *t = (const cl_time_seg_256_t *)core0_seg_ptr(base, map_size, e);
            if (t) {
                in.have_time = true;
                /* mono_now_ns steht im Segment; wir nutzen es hier nicht direkt (now_ns ist unsere Zeitbasis). */
            }
        }
    }

    /* LINK summary */
    {
        const cl_toc_entry_t *e = core0_toc_find_entry(toc_hdr, toc_ent, (uint16_t)CL_LINK_SEG_256);
        if (e && core0_entry_readable(root, e)) {
            const cl_link_seg_256_t *l = (const cl_link_seg_256_t *)core0_seg_ptr(base, map_size, e);
            if (l) {
                in.have_link = true;
                in.link_path_state       = atomic_load_explicit(&l[0].hot.path_state, memory_order_relaxed);
                in.link_backend_active   = atomic_load_explicit(&l[0].hot.backend_active, memory_order_relaxed);
                in.link_mode_active      = atomic_load_explicit(&l[0].hot.mode_active, memory_order_relaxed);
                in.link_profile_effective= atomic_load_explicit(&l[0].hot.profile_effective, memory_order_relaxed);
                in.link_constraint_flags = atomic_load_explicit(&l[0].hot.constraint_flags, memory_order_relaxed);
                in.link_reason_code      = atomic_load_explicit(&l[0].hot.reason_code, memory_order_relaxed);
                in.link_global_health    = atomic_load_explicit(&l[0].hot.global_health, memory_order_relaxed);
            }
        }
    }

    /* Trusted peer count (root quick view) */
    in.trusted_peer_count = (uint16_t)atomic_load_explicit(&root->trusted_peer_count, memory_order_relaxed);

    /* WATCHDOG (CORE schreibt, aber liest auch zum Latching) */
    cl_watchdog_seg_256_t *wd = NULL;
    cl_toc_entry_t *wd_e = core0_toc_find_entry_mut(toc_hdr, toc_ent, (uint16_t)CL_WATCHDOG_SEG_256);
    if (wd_e) {
        wd = (cl_watchdog_seg_256_t *)core0_seg_ptr(base, map_size, wd_e);
        if (wd) in.have_watchdog = true;
    }

    /* ---- Trust evaluation ---- */
    const bool trust_active = core0_eval_trust_active(root, toc_hdr, toc_ent, base, map_size);

    /* ---- Watchdog evaluation (latching) ---- */
    core0_wd_eval_t wd_eval;
    memset(&wd_eval, 0, sizeof(wd_eval));
    if (wd) {
        /* CORE markiert eigenes Tick zuerst */
        atomic_store_explicit(&wd->hot_a.core_tick_ns, now_ns, memory_order_relaxed);

        wd_eval = core0_watchdog_eval(root, wd, toc_hdr, toc_ent, now_ns);

        /* schreibe latched state/reason/module */
        atomic_store_explicit(&wd->hot_b.wd_state, (uint32_t)wd_eval.state, memory_order_relaxed);
        atomic_store_explicit(&wd->hot_b.wd_reason, (uint32_t)wd_eval.reason, memory_order_relaxed);
        atomic_store_explicit(&wd->hot_b.last_stall_module, (uint32_t)wd_eval.module, memory_order_relaxed);

        /* restart_count_total / warm last_restart* werden NICHT von CORE inkrementiert hier
         * (das macht Supervisor/Restart-Mechanik). CORE setzt nur Diagnose/State.
         */

        /* Publish WD epoch (Cut-Point) */
        const uint64_t cur = atomic_load_explicit((_Atomic(uint64_t) *)&wd_e->epoch, memory_order_acquire);
        core0_publish_epoch(wd_e, core0_next_epoch_u64(cur));
    }

    /* ---- Gates evaluation ---- */
    const cl_gate_state_t gs = core0_eval_gates(&in, &wd_eval, trust_active);

    /* ---- Dataplane Viability (minimal, aus LINK summary) ----
     * CORE entscheidet NICHT Redirect, aber setzt GATES so, dass LINK safe cutover machen kann.
     * Hier: wenn LINK fehlt/UNINIT => dataplane verboten über TRUST_NONE/SECURITY_DEGRADED ohnehin.
     */
    const bool dataplane_ready = in.have_link && (in.link_global_health != 0);

    /* ---- Root Quick Views spiegeln (SSOT: Root ist Abkürzung, nicht zweite Wahrheit) ---- */
    atomic_store_explicit(&root->uptime_ns, now_ns, memory_order_relaxed);

    if (in.have_link) {
        atomic_store_explicit(&root->path_state,      in.link_path_state,       memory_order_relaxed);
        atomic_store_explicit(&root->backend_active,  in.link_backend_active,   memory_order_relaxed);
        atomic_store_explicit(&root->mode_active,     in.link_mode_active,      memory_order_relaxed);
        atomic_store_explicit(&root->profile_active,  in.link_profile_effective,memory_order_relaxed);

        atomic_store_explicit(&root->constraint_flags,in.link_constraint_flags, memory_order_relaxed);
        atomic_store_explicit(&root->reason_code,     in.link_reason_code,      memory_order_relaxed);
        atomic_store_explicit(&root->global_health,   in.link_global_health,    memory_order_relaxed);
    } else {
        /* Wenn kein Link-Input: lasse Root-Werte unverändert (keine willkürlichen Resets). */
    }

    /* rx_gate/tx_gate sind u32; wir spiegeln die unteren 32 Bits des effective Gate-Maskenworts. */
    atomic_store_explicit(&root->rx_gate, (uint32_t)(gs.effective & 0xFFFFFFFFu), memory_order_relaxed);
    atomic_store_explicit(&root->tx_gate, (uint32_t)(gs.effective & 0xFFFFFFFFu), memory_order_relaxed);

    /* ---- TOC per-entry gates setzen (Authority) ----
     * Policy:
     * - Für alle Entries: gates_effective = global effective
     * - gates_possible bleibt unverändert, außer wenn bisher 0 -> setze auf effective als "mindestens".
     * (possible ist physikalisch; wenn HAL keine possible liefert, bleibt es 0; wir fälschen nicht.)
     */
    for (uint32_t i = 0; i < toc_hdr->entry_count; i++) {
        /* gates_effective: immer spiegeln */
        toc_ent[i].gates_effective = gs.effective;

        /* gates_possible: wenn bereits gesetzt, respektieren; sonst konservativ = 0.
         * Optional: wenn du willst, kannst du hier "possible |= effective" machen.
         * Ich mache das nur, wenn möglich==0 und effective!=0, damit Monitor nicht komplett leer ist,
         * ohne "physik möglich" zu erfinden: effective ist ja bereits eine reale Schranke.
         */
        if (toc_ent[i].gates_possible == 0 && gs.effective != 0) {
            toc_ent[i].gates_possible = gs.effective;
        }
    }

    /* ---- Publish CORE-relevante Entries epoch bump ----
     * Endausbau-Cutpoint: CORE bump’t mindestens WATCHDOG + SERVICE (und optional TOC epoch).
     * Für Root gibt es kein epoch-Feld; Root ist atomisch via einzelne Felder.
     *
     * Zusätzlich: wir bumpen den TOC-Header epoch als "configuration/authority epoch".
     */
    {
        const uint64_t cur = toc_hdr->epoch;
        toc_hdr->epoch = core0_next_epoch_u64(cur);
    }

    /* ---- Service heartbeat publish ---- */
    core0_service_heartbeat(root, toc_hdr, toc_ent, base, map_size, now_ns);

    (void)dataplane_ready;
}

/* -------------------------------------------------------------------------- */
/* CLI / Main                                                                 */
/* -------------------------------------------------------------------------- */

static void core0_usage(FILE *f) {
    fprintf(f,
        "core0 (CommanderLink CORE0)\n"
        "Usage: core0 [--shm <name>] [--tick-ms <n>]\n"
        "Default shm=%s, tick-ms=%u\n",
        CL_CORE_SHM_NAME, (unsigned)CL_CORE_DEFAULT_TICK_MS);
}

int main(int argc, char **argv)
{
    const char *shm_name = CL_CORE_SHM_NAME;
    uint32_t tick_ms = CL_CORE_DEFAULT_TICK_MS;

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--shm") == 0 && i + 1 < argc) {
            shm_name = argv[++i];
        } else if (strcmp(argv[i], "--tick-ms") == 0 && i + 1 < argc) {
            tick_ms = (uint32_t)strtoul(argv[++i], NULL, 10);
            if (tick_ms == 0) tick_ms = CL_CORE_DEFAULT_TICK_MS;
        } else if (strcmp(argv[i], "--help") == 0 || strcmp(argv[i], "-h") == 0) {
            core0_usage(stdout);
            return 0;
        } else {
            core0_usage(stderr);
            return 2;
        }
    }

    (void)signal(SIGINT, core0_on_signal);
    (void)signal(SIGTERM, core0_on_signal);

    core0_map_t m;
    if (core0_map_open(&m, shm_name, (size_t)CL_ROOT_BYTES) != 0) {
        perror("core0: shm_open/map failed");
        return 1;
    }

    /* Minimal sanity: Root-Magic/Endian/Schema prüfen (FAILFAST nur wenn Flag gesetzt) */
    cl_root_4096_t *root = core0_root_ptr(m.base);

    if (root->root_magic != CL_ROOT_MAGIC_U32) {
        fprintf(stderr, "core0: root_magic mismatch (0x%08x)\n", root->root_magic);
        core0_map_close(&m);
        return 1;
    }
    if (root->endian_magic != CL_ENDIAN_MAGIC_U32) {
        fprintf(stderr, "core0: endian_magic mismatch (0x%08x)\n", root->endian_magic);
        core0_map_close(&m);
        return 1;
    }
    if (root->schema_version != CL_SCHEMA_VERSION_U32) {
        fprintf(stderr, "core0: schema_version mismatch (0x%08x)\n", root->schema_version);
        core0_map_close(&m);
        return 1;
    }

    /* FAILFAST_ABI: wenn abi_layout_checksum != expected und ihr expected habt, dann hier prüfen.
     * In deinem Schema steht CL_ABI_CHECKSUM_NONE; daher kein harter Vergleich.
     */
    if ((root->root_flags & CL_ROOT_FLAG_FAILFAST_ABI) != 0) {
        if (root->abi_layout_checksum != CL_ABI_CHECKSUM_NONE) {
            /* Wenn ihr später eine echte Checksum habt, wird hier verglichen. */
        }
    }

    while (!g_stop) {
        core0_tick(&m);

        struct timespec req;
        req.tv_sec  = (time_t)(tick_ms / 1000u);
        req.tv_nsec = (long)((tick_ms % 1000u) * 1000000u);
        (void)nanosleep(&req, NULL);
    }

    core0_map_close(&m);
    return 0;
}


<<< END FILE: ./src/core/core0.c

>>> START FILE: ./src/flow/flow0.c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>

#include "cl_runtime/cl_runtime.h"
#include "cl_runtime/cl_service_seg_256.h"

static uint64_t now_ns(void){ struct timespec ts; clock_gettime(CLOCK_MONOTONIC,&ts); return (uint64_t)ts.tv_sec*1000000000ull+(uint64_t)ts.tv_nsec; }

static int map_core_rw(void **out_base, size_t *out_sz){
    int fd=shm_open(CL_CORE_SHM_NAME,O_RDWR,0); if(fd<0) return -1;
    struct stat st; if(fstat(fd,&st)!=0){close(fd);return -2;} if(st.st_size<=0){close(fd);return -3;}
    void *p=mmap(NULL,(size_t)st.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); close(fd);
    if(p==MAP_FAILED) return -4; *out_base=p; *out_sz=(size_t)st.st_size; return 0;
}

static cl_service_seg_256_t* find_service_seg(void *core_base){
    cl_root_t *r=(cl_root_t*)core_base;
    cl_toc_t *toc=(cl_toc_t*)((uint8_t*)core_base+(size_t)r->toc_offset);
    for(uint32_t i=0;i<toc->header.entry_count && i<CL_TOC_MAX_ENTRIES;i++){
        cl_toc_entry_t *e=&toc->entries[i];
        if((uint16_t)e->type==(uint16_t)CL_SERVICE_SEG_256) return (cl_service_seg_256_t*)((uint8_t*)core_base+(size_t)e->offset_bytes);
    }
    return NULL;
}

static cl_service_slot_32_t* slot_for(cl_service_seg_256_t *svc, cl_service_id_t id){
    switch(id){
        case CL_SVC_CORE0: return &svc->g1.s0;
        case CL_SVC_HAL0: return &svc->g1.s1;
        case CL_SVC_LINK0: return &svc->g2.s2;
        case CL_SVC_FLOW0: return &svc->g2.s3;
        case CL_SVC_ORACLE0: return &svc->g3.s4;
        case CL_SVC_MONITOR: return &svc->g3.s5;
        default: return NULL;
    }
}

int main(void){
    void *core=NULL; size_t core_sz=0;
    int rc=map_core_rw(&core,&core_sz);
    if(rc!=0){ printf("flow0: cannot map core shm: rc=%d errno=%d (%s)\n",rc,errno,strerror(errno)); return 2; }
    cl_service_seg_256_t *svc=find_service_seg(core);
    if(!svc){ printf("flow0: service segment not found\n"); return 3; }
    cl_service_slot_32_t *sl=slot_for(svc,CL_SVC_FLOW0);
    if(!sl) return 4;

    for(;;){
        atomic_store(&sl->last_heartbeat_ns, now_ns());
        struct timespec ts={0}; ts.tv_nsec=250000000L; nanosleep(&ts,NULL);
    }
}


<<< END FILE: ./src/flow/flow0.c

>>> START FILE: ./src/hal/hal0.c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>

#include "cl_runtime/cl_runtime.h"
#include "cl_runtime/cl_service_seg_256.h"

static uint64_t now_ns(void){ struct timespec ts; clock_gettime(CLOCK_MONOTONIC,&ts); return (uint64_t)ts.tv_sec*1000000000ull+(uint64_t)ts.tv_nsec; }

static int map_core_rw(void **out_base, size_t *out_sz){
    int fd=shm_open(CL_CORE_SHM_NAME,O_RDWR,0); if(fd<0) return -1;
    struct stat st; if(fstat(fd,&st)!=0){close(fd);return -2;} if(st.st_size<=0){close(fd);return -3;}
    void *p=mmap(NULL,(size_t)st.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); close(fd);
    if(p==MAP_FAILED) return -4; *out_base=p; *out_sz=(size_t)st.st_size; return 0;
}

static cl_service_seg_256_t* find_service_seg(void *core_base){
    cl_root_t *r=(cl_root_t*)core_base;
    cl_toc_t *toc=(cl_toc_t*)((uint8_t*)core_base+(size_t)r->toc_offset);
    for(uint32_t i=0;i<toc->header.entry_count && i<CL_TOC_MAX_ENTRIES;i++){
        cl_toc_entry_t *e=&toc->entries[i];
        if((uint16_t)e->type==(uint16_t)CL_SERVICE_SEG_256) return (cl_service_seg_256_t*)((uint8_t*)core_base+(size_t)e->offset_bytes);
    }
    return NULL;
}

static cl_service_slot_32_t* slot_for(cl_service_seg_256_t *svc, cl_service_id_t id){
    switch(id){
        case CL_SVC_CORE0: return &svc->g1.s0;
        case CL_SVC_HAL0: return &svc->g1.s1;
        case CL_SVC_LINK0: return &svc->g2.s2;
        case CL_SVC_FLOW0: return &svc->g2.s3;
        case CL_SVC_ORACLE0: return &svc->g3.s4;
        case CL_SVC_MONITOR: return &svc->g3.s5;
        default: return NULL;
    }
}

int main(void){
    void *core=NULL; size_t core_sz=0;
    int rc=map_core_rw(&core,&core_sz);
    if(rc!=0){ printf("hal0: cannot map core shm: rc=%d errno=%d (%s)\n",rc,errno,strerror(errno)); return 2; }
    cl_service_seg_256_t *svc=find_service_seg(core);
    if(!svc){ printf("hal0: service segment not found\n"); return 3; }
    cl_service_slot_32_t *sl=slot_for(svc,CL_SVC_HAL0);
    if(!sl) return 4;

    for(;;){
        atomic_store(&sl->last_heartbeat_ns, now_ns());
        struct timespec ts={0}; ts.tv_nsec=250000000L; nanosleep(&ts,NULL);
    }
}


<<< END FILE: ./src/hal/hal0.c

>>> START FILE: ./src/link/link0.c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>

#include "cl_runtime/cl_runtime.h"
#include "cl_runtime/cl_service_seg_256.h"

static uint64_t now_ns(void){ struct timespec ts; clock_gettime(CLOCK_MONOTONIC,&ts); return (uint64_t)ts.tv_sec*1000000000ull+(uint64_t)ts.tv_nsec; }

static int map_core_rw(void **out_base, size_t *out_sz){
    int fd=shm_open(CL_CORE_SHM_NAME,O_RDWR,0); if(fd<0) return -1;
    struct stat st; if(fstat(fd,&st)!=0){close(fd);return -2;} if(st.st_size<=0){close(fd);return -3;}
    void *p=mmap(NULL,(size_t)st.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); close(fd);
    if(p==MAP_FAILED) return -4; *out_base=p; *out_sz=(size_t)st.st_size; return 0;
}

static cl_service_seg_256_t* find_service_seg(void *core_base){
    cl_root_t *r=(cl_root_t*)core_base;
    cl_toc_t *toc=(cl_toc_t*)((uint8_t*)core_base+(size_t)r->toc_offset);
    for(uint32_t i=0;i<toc->header.entry_count && i<CL_TOC_MAX_ENTRIES;i++){
        cl_toc_entry_t *e=&toc->entries[i];
        if((uint16_t)e->type==(uint16_t)CL_SERVICE_SEG_256) return (cl_service_seg_256_t*)((uint8_t*)core_base+(size_t)e->offset_bytes);
    }
    return NULL;
}

static cl_service_slot_32_t* slot_for(cl_service_seg_256_t *svc, cl_service_id_t id){
    switch(id){
        case CL_SVC_CORE0: return &svc->g1.s0;
        case CL_SVC_HAL0: return &svc->g1.s1;
        case CL_SVC_LINK0: return &svc->g2.s2;
        case CL_SVC_FLOW0: return &svc->g2.s3;
        case CL_SVC_ORACLE0: return &svc->g3.s4;
        case CL_SVC_MONITOR: return &svc->g3.s5;
        default: return NULL;
    }
}

int main(void){
    void *core=NULL; size_t core_sz=0;
    int rc=map_core_rw(&core,&core_sz);
    if(rc!=0){ printf("link0: cannot map core shm: rc=%d errno=%d (%s)\n",rc,errno,strerror(errno)); return 2; }
    cl_service_seg_256_t *svc=find_service_seg(core);
    if(!svc){ printf("link0: service segment not found\n"); return 3; }
    cl_service_slot_32_t *sl=slot_for(svc,CL_SVC_LINK0);
    if(!sl) return 4;

    for(;;){
        atomic_store(&sl->last_heartbeat_ns, now_ns());
        struct timespec ts={0}; ts.tv_nsec=250000000L; nanosleep(&ts,NULL);
    }
}


<<< END FILE: ./src/link/link0.c

>>> START FILE: ./src/monitor/.nfs.8180f1a2.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.8180f1a2.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.818142e8.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.818142e8.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8182daea.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.8182daea.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.81870104.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_YELLOW, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.81870104.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.81876a53.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLUE, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_YELLOW, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.81876a53.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8187d662.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_YELLOW, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.8187d662.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8187fa1d.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_YELLOW, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.8187fa1d.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8188f583.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.8188f583.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.81895f53.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.81895f53.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8189ddaa.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_WHITE, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.8189ddaa.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.818cfa69.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.818cfa69.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.818d2fcc.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.818d2fcc.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.818d72b1.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.818d72b1.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.818dc014.5aaa4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.818dc014.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.818e1f1d.5aaa4.4
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>

#include "monitor_curses.h"
#include "monitor_ui.h"
#include "tabs.h"

/* State Definitions */
typedef enum {
    TAB_DASHBOARD = 0,
    TAB_CPU,
    TAB_MEM,
    /* ... weitere ... */
    TAB_COUNT
} AppTab;

int main(void) {
    ui_init();

    int running = 1;
    AppTab current_tab = TAB_DASHBOARD;
    int ch;

    while (running) {
        /* 1. Global UI zeichnen */
        ui_draw_screen_bg();
        ui_draw_header("CommanderLink - Monitor v0.1", 
                       "F1:Dash  F2:CPU  F3:Mem  F10:Quit");
        
        /* 2. Aktiven Tab zeichnen */
        int h = getmaxy(stdscr);
        int w = getmaxx(stdscr);
        
        switch (current_tab) {
            case TAB_DASHBOARD:
                tab_dashboard_draw(h, w);
                break;
            default:
                mvprintw(h/2, w/2 - 10, "Tab not implemented yet.");
                break;
        }

        /* 3. Statusbar update */
        ui_draw_statusbar("Status: CONNECTED", "Mode: VIEW");

        refresh();

        /* 4. Input Loop */
        ch = getch();
        switch (ch) {
            case KEY_F(1): current_tab = TAB_DASHBOARD; break;
            case KEY_F(2): current_tab = TAB_CPU; break;
            case KEY_F(3): current_tab = TAB_MEM; break;
            case KEY_F(10): running = 0; break;
            case 27: /* ESC */ running = 0; break;
            
            default:
                /* Input an den Tab weiterleiten */
                if (current_tab == TAB_DASHBOARD) {
                    tab_dashboard_input(ch);
                }
                break;
        }
        
        /* Kurzes Sleep um CPU zu sparen (Monitor ist passiv) */
        /* usleep(10000); -> ncurses getch() blockt eh standardmäßig oder hat timeout */
    }

    ui_shutdown();
    printf("[Monitor] Terminated gracefully.\n");
    return 0;
}

<<< END FILE: ./src/monitor/.nfs.818e1f1d.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8190a368.5aaa4.4
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "monitor_curses.h"
#include "monitor_ui.h"
#include "monitor_state.h" // NEU
#include "monitor_input.h" // NEU
#include "tabs.h"

int main(void) {
    ui_init();
    
    /* State holen */
    cl_monitor_state_t *st = monitor_state();

    while (st->running) {
        /* 1. Global UI & Header */
        ui_draw_screen_bg();
        
        /* Dynamischer Header je nach Tab */
        const char *title = "CommanderLink Monitor";
        if (st->active_tab == TAB_DASHBOARD) title = "CL - Dashboard";
        if (st->active_tab == TAB_CPU)       title = "CL - CPU Core Physics";
        if (st->active_tab == TAB_MEM)       title = "CL - Memory Matrix";

        ui_draw_header(title, "TAB/Arrows: Switch   F1:Dash F2:CPU F3:Mem   F10:Quit");
        
        /* 2. Aktiven Tab zeichnen */
        int h = getmaxy(stdscr);
        int w = getmaxx(stdscr);
        
        switch (st->active_tab) {
            case TAB_DASHBOARD:
                tab_dashboard_draw(h, w);
                break;
            case TAB_CPU:
                mvprintw(h/2, w/2 - 10, "[ CPU TAB PLACEHOLDER ]");
                break;
            case TAB_MEM:
                mvprintw(h/2, w/2 - 10, "[ MEM TAB PLACEHOLDER ]");
                break;
            default:
                break;
        }

        /* 3. Statusbar */
        ui_draw_statusbar("Status: CONNECTED", "Mode: VIEW");

        refresh();

        /* 4. Input an Handler delegieren */
        int ch = getch();
        monitor_handle_input(ch);
    }

    ui_shutdown();
    return 0;
}

<<< END FILE: ./src/monitor/.nfs.8190a368.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8197ae7d.5aaa4.4
#ifndef CL_MONITOR_UI_H
#define CL_MONITOR_UI_H

#include "monitor_curses.h"

/* Farben (TVision Style) */
#define CL_COLOR_BG       1  /* Blau / Weiß */
#define CL_COLOR_TITLE    2  /* Schwarz / Cyan */
#define CL_COLOR_STATUS   3  /* Schwarz / Grau */
#define CL_COLOR_TEXT     4  /* Weiß / Blau */
#define CL_COLOR_ALERT    5  /* Weiß / Rot */

void ui_init(void);
void ui_shutdown(void);

/* Zeichen-Primitive */
void ui_draw_screen_bg(void);
void ui_draw_header(const char *title, const char *subtitle);
void ui_draw_statusbar(const char *status_left, const char *status_right);
void ui_draw_box(int y, int x, int h, int w, const char *title);
void ui_draw_label_value(int y, int x, const char *label, const char *value);

#endif

<<< END FILE: ./src/monitor/.nfs.8197ae7d.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.8197e4da.5aaa4.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_BLACK, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

<<< END FILE: ./src/monitor/.nfs.8197e4da.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.819d3e2f.5aaa4.4
#ifndef CL_MONITOR_STATE_H
#define CL_MONITOR_STATE_H

typedef enum {
    TAB_DASHBOARD = 0,
    TAB_CPU,
    TAB_MEM,
    /* Hier kommen später TAB_NIC, TAB_ZFS etc. dazu */
    TAB_COUNT
} cl_mon_tab_t;

/* Singleton State Accessor */
typedef struct {
    cl_mon_tab_t active_tab;
    int running;
} cl_monitor_state_t;

cl_monitor_state_t* monitor_state(void);

#endif

<<< END FILE: ./src/monitor/.nfs.819d3e2f.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.819db378.5aaa4.4
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h> /* Für snprintf */

#include "monitor_curses.h"
#include "monitor_ui.h"
#include "monitor_state.h"
#include "monitor_input.h"
#include "tabs.h"

int main(void) {
    ui_init();
    
    /* State holen */
    cl_monitor_state_t *st = monitor_state();

    while (st->running) {
        /* 1. Global UI & Header */
        ui_draw_screen_bg();
        
        /* A. Titel-Logik: "CommanderLink Monitor - [TABNAME]" */
        char title_buf[128];
        const char *tab_name = "Unknown";
        
        switch (st->active_tab) {
            case TAB_DASHBOARD: tab_name = "Dashboard"; break;
            case TAB_CPU:       tab_name = "CPU Core Physics"; break;
            case TAB_MEM:       tab_name = "Memory Matrix"; break;
            default:            tab_name = "Section"; break;
        }
        
        snprintf(title_buf, sizeof(title_buf), "CommanderLink Monitor - %s", tab_name);

        /* B. Header zeichnen: Titel + F-Tasten direkt darunter */
        ui_draw_header(title_buf, " F1:Dash  F2:CPU  F3:Mem  F10:Quit");
        
        /* 2. Aktiven Tab zeichnen */
        int h = getmaxy(stdscr);
        int w = getmaxx(stdscr);
        
        /* Content-Bereich etwas kleiner machen, da Header 2 Zeilen nutzt */
        /* Die ui_draw_header nimmt Zeile 0 und 1. Content startet ab Zeile 2 */
        
        switch (st->active_tab) {
            case TAB_DASHBOARD:
                tab_dashboard_draw(h, w);
                break;
            case TAB_CPU:
                /* Platzhalter bis Tab implementiert ist */
                ui_draw_box(h/2 - 2, w/2 - 20, 5, 40, "Info");
                mvprintw(h/2, w/2 - 18, "CPU Tab implementing...");
                break;
            case TAB_MEM:
                ui_draw_box(h/2 - 2, w/2 - 20, 5, 40, "Info");
                mvprintw(h/2, w/2 - 18, "Memory Tab implementing...");
                break;
            default:
                break;
        }

        /* 3. Statusbar unten: Navigation links, Status rechts */
        /* Hier kommt deine gewünschte Änderung rein */
        ui_draw_statusbar(" TAB/Arrows: Switch Tab | ENTER: Select", "Status: CONNECTED");

        refresh();

        /* 4. Input an Handler delegieren */
        int ch = getch();
        monitor_handle_input(ch);
    }

    ui_shutdown();
    return 0;
}

<<< END FILE: ./src/monitor/.nfs.819db378.5aaa4.4

>>> START FILE: ./src/monitor/.nfs.81d5f1a7.69804.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_BLACK, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

void ui_draw_progressbar(int y, int x, int width, int permille, int color_pair) {
    if (width < 3) return;
    
    int fill_w = (width * permille) / 1000;
    if (fill_w > width) fill_w = width;
    
    attron(COLOR_PAIR(color_pair));
    
    /* Rahmen optional oder direkt Balken */
    mvprintw(y, x, "[");
    for (int i = 0; i < width - 2; i++) {
        if (i < fill_w) addch('|'); // Oder ACS_BLOCK für vollen Block
        else addch('.');
    }
    mvprintw(y, x + width - 1, "]");
    
    /* Prozentzahl in die Mitte (optional) */
    char buf[16];
    snprintf(buf, sizeof(buf), " %3d%% ", permille / 10);
    if ((int)strlen(buf) < width - 4) {
        mvprintw(y, x + (width/2) - (strlen(buf)/2), "%s", buf);
    }
    
    attroff(COLOR_PAIR(color_pair));
}

<<< END FILE: ./src/monitor/.nfs.81d5f1a7.69804.4

>>> START FILE: ./src/monitor/.nfs.81d702e1.69804.4
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLACK);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_BLACK, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

void ui_draw_progressbar(int y, int x, int width, int permille, int color_pair) {
    if (width < 3) return;
    
    int fill_w = (width * permille) / 1000;
    if (fill_w > width) fill_w = width;
    
    attron(COLOR_PAIR(color_pair));
    
    /* Rahmen optional oder direkt Balken */
    mvprintw(y, x, "[");
    for (int i = 0; i < width - 2; i++) {
        if (i < fill_w) addch('|'); // Oder ACS_BLOCK für vollen Block
        else addch('.');
    }
    mvprintw(y, x + width - 1, "]");
    
    /* Prozentzahl in die Mitte (optional) */
    char buf[16];
    snprintf(buf, sizeof(buf), " %3d%% ", permille / 10);
    if ((int)strlen(buf) < width - 4) {
        mvprintw(y, x + (width/2) - (strlen(buf)/2), "%s", buf);
    }
    
    attroff(COLOR_PAIR(color_pair));
}

<<< END FILE: ./src/monitor/.nfs.81d702e1.69804.4

>>> START FILE: ./src/monitor/.nfs.81f6b82b.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.81f6b82b.75fb4.4

>>> START FILE: ./src/monitor/.nfs.81f7161b.75fb4.4 (BINARY SKIPPED)
[Binary Content Hidden]
<<< END FILE: ./src/monitor/.nfs.81f7161b.75fb4.4

>>> START FILE: ./src/monitor/.nfs.81f7495c.75fb4.4
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>      /* shm_open */
#include <sys/mman.h>   /* mmap */
#include <sys/stat.h>
#include <errno.h>

#include "monitor_curses.h"
#include "monitor_ui.h"
#include "monitor_state.h"
#include "monitor_input.h"
#include "tabs.h"

/* HIER ist der Name definiert: */
#include "../../include/cl_runtime/cl_shm_layout.h"

/* Helper: SHM verbinden */
static void attach_shm(cl_monitor_state_t *st) {
    /* Benutzt "/cl_core_root" aus dem Header */
    int fd = shm_open(CL_CORE_SHM_NAME, O_RDONLY, 0);
    if (fd == -1) {
        st->core_base = NULL;
        st->core_size = 0;
        return;
    }

    struct stat sb;
    if (fstat(fd, &sb) == -1) {
        close(fd);
        return;
    }

    st->core_size = (size_t)sb.st_size;
    st->core_base = mmap(NULL, st->core_size, PROT_READ, MAP_SHARED, fd, 0);
    close(fd);

    if (st->core_base == MAP_FAILED) {
        st->core_base = NULL;
        st->core_size = 0;
    }
}

static void detach_shm(cl_monitor_state_t *st) {
    if (st->core_base && st->core_base != MAP_FAILED) {
        munmap(st->core_base, st->core_size);
    }
}

int main(void) {
    cl_monitor_state_t *st = monitor_state();
    
    attach_shm(st); /* Versucht Verbindung */

    ui_init();

    while (st->running) {
        ui_draw_screen_bg();
        
        char title_buf[128];
        const char *tab_name = "Unknown";
        
        switch (st->active_tab) {
            case TAB_DASHBOARD: tab_name = "Dashboard"; break;
            case TAB_CPU:       tab_name = "CPU Core Physics"; break;
            case TAB_MEM:       tab_name = "Memory Matrix"; break;
            default:            tab_name = "Section"; break;
        }
        
        snprintf(title_buf, sizeof(title_buf), "CommanderLink Monitor - %s", tab_name);
        ui_draw_header(title_buf, " F1:Dash  F2:CPU  F3:Mem  F10:Quit");
        
        int h = getmaxy(stdscr);
        int w = getmaxx(stdscr);
        
        switch (st->active_tab) {
            case TAB_DASHBOARD:
                tab_dashboard_draw(h, w);
                break;
            case TAB_CPU:
                ui_draw_box(h/2 - 2, w/2 - 20, 5, 40, "Info");
                mvprintw(h/2, w/2 - 18, "CPU Tab implementing...");
                break;
            case TAB_MEM:
                ui_draw_box(h/2 - 2, w/2 - 20, 5, 40, "Info");
                mvprintw(h/2, w/2 - 18, "Memory Tab implementing...");
                break;
            default: break;
        }

        /* Statusbar mit SHM Info */
        char status_right[64];
        if (st->core_base) {
            snprintf(status_right, sizeof(status_right), "SHM: ONLINE (%zu B)", st->core_size);
        } else {
            snprintf(status_right, sizeof(status_right), "SHM: WAIT (%s)", CL_CORE_SHM_NAME);
        }
        
        ui_draw_statusbar(" TAB/Arrows: Switch Tab | ENTER: Select", status_right);

        refresh();

        int ch = getch();
        monitor_handle_input(ch);
    }

    ui_shutdown();
    detach_shm(st);
    
    return 0;
}

<<< END FILE: ./src/monitor/.nfs.81f7495c.75fb4.4

>>> START FILE: ./src/monitor/monitor_curses.h
#ifndef CL_MONITOR_CURSES_H
#define CL_MONITOR_CURSES_H

#if defined(__sun)
/* OmniOS/illumos: ncurses header is available as ncurses/ncurses.h -> curses.h */
  #include <ncurses/ncurses.h>
#else
  /* Linux + BSD */
  #include <ncurses.h>
#endif

#endif


<<< END FILE: ./src/monitor/monitor_curses.h

>>> START FILE: ./src/monitor/monitor_input.c
#include "monitor_curses.h" // Für Key-Definitionen
#include "monitor_state.h"
#include "tabs.h"

void monitor_handle_input(int key) {
    cl_monitor_state_t *st = monitor_state();

    switch (key) {
        /* --- GLOBAL NAVIGATION --- */
        
        /* TAB oder RECHTS -> Nächster Tab */
        case '\t': 
        case KEY_RIGHT:
            st->active_tab = (st->active_tab + 1) % TAB_COUNT;
            break;

        /* SHIFT+TAB (Backtab) oder LINKS -> Vorheriger Tab */
        case KEY_BTAB: // Shift-Tab (wird von vielen Terminals unterstützt)
        case KEY_LEFT:
            /* Trick für Modulo mit negativen Zahlen in C: + COUNT addieren */
            st->active_tab = (st->active_tab - 1 + TAB_COUNT) % TAB_COUNT;
            break;

        /* F-Keys direkt */
        case KEY_F(1): st->active_tab = TAB_DASHBOARD; break;
        case KEY_F(2): st->active_tab = TAB_CPU; break;
        case KEY_F(3): st->active_tab = TAB_MEM; break;
        
        case KEY_F(10): 
        case 27: /* ESC */
            st->running = 0; 
            break;

        /* --- CONTENT PASS-THROUGH --- */
        default:
            /* Input an den aktiven Tab weiterreichen (z.B. für Scrollen in Listen) */
            if (st->active_tab == TAB_DASHBOARD) {
                tab_dashboard_input(key);
            }
            break;
    }
}

<<< END FILE: ./src/monitor/monitor_input.c

>>> START FILE: ./src/monitor/monitor_input.h
#ifndef CL_MONITOR_INPUT_H
#define CL_MONITOR_INPUT_H

void monitor_handle_input(int key);

#endif

<<< END FILE: ./src/monitor/monitor_input.h

>>> START FILE: ./src/monitor/monitor_shm.c
#define _POSIX_C_SOURCE 200809L
#include "monitor_shm.h"
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

void mon_shm_connect(cl_monitor_state_t *st) {
    /* Reset */
    st->core_base = NULL;
    st->core_size = 0;

    int fd = shm_open(CL_CORE_SHM_NAME, O_RDONLY, 0);
    if (fd == -1) return; 

    struct stat sb;
    if (fstat(fd, &sb) == -1) { close(fd); return; }

    void *map = mmap(NULL, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
    close(fd);

    if (map == MAP_FAILED) return;

    if (sb.st_size < sizeof(cl_root_4096_t)) {
        munmap(map, sb.st_size);
        return;
    }

    st->core_base = map;
    st->core_size = (size_t)sb.st_size;
}

void mon_shm_disconnect(cl_monitor_state_t *st) {
    if (st->core_base && st->core_base != MAP_FAILED) {
        munmap(st->core_base, st->core_size);
    }
    st->core_base = NULL;
    st->core_size = 0;
}

const cl_root_4096_t* mon_get_root(cl_monitor_state_t *st) {
    if (!st->core_base) return NULL;
    const cl_root_4096_t *r = (const cl_root_4096_t*)st->core_base;
    if (r->root_magic != CL_ROOT_MAGIC_U32) return NULL;
    return r;
}

const cl_toc_t* mon_get_toc(cl_monitor_state_t *st, const cl_root_4096_t *root) {
    if (!root) return NULL;
    if (root->toc_offset >= st->core_size) return NULL;
    if (root->toc_offset + sizeof(cl_toc_header_t) > st->core_size) return NULL;

    const cl_toc_t *toc = (const cl_toc_t*)((const uint8_t*)st->core_base + root->toc_offset);
    
    /* Grober Bounds Check für den ganzen TOC */
    size_t toc_min_size = sizeof(cl_toc_header_t) + (toc->header.entry_count * sizeof(cl_toc_entry_t));
    if (root->toc_offset + toc_min_size > st->core_size) return NULL;

    return toc;
}

const cl_toc_entry_t* mon_find_entry(cl_monitor_state_t *st, const cl_toc_t *toc, uint16_t seg_type) {
    (void)st;
    if (!toc) return NULL;
    for (uint32_t i = 0; i < toc->header.entry_count; i++) {
        if (toc->entries[i].type == seg_type) return &toc->entries[i];
    }
    return NULL;
}

const void* mon_map_segment(cl_monitor_state_t *st, const cl_toc_entry_t *e, uint32_t idx) {
    if (!st->core_base || !e) return NULL;
    if (idx >= e->count) return NULL;

    uint64_t start = e->offset_bytes + (idx * (uint64_t)e->stride_bytes);
    if (start + e->stride_bytes > st->core_size) return NULL;

    return (const void*)((const uint8_t*)st->core_base + start);
}

<<< END FILE: ./src/monitor/monitor_shm.c

>>> START FILE: ./src/monitor/monitor_shm.h
#ifndef CL_MONITOR_SHM_H
#define CL_MONITOR_SHM_H

#include <stdint.h>
#include "monitor_state.h"

/* Runtime Headers */
#include "../../include/cl_runtime/cl_shm_layout.h"
#include "../../include/cl_runtime/cl_toc.h"

void mon_shm_connect(cl_monitor_state_t *st);
void mon_shm_disconnect(cl_monitor_state_t *st);

const cl_root_4096_t* mon_get_root(cl_monitor_state_t *st);
const cl_toc_t* mon_get_toc(cl_monitor_state_t *st, const cl_root_4096_t *root);
const cl_toc_entry_t* mon_find_entry(cl_monitor_state_t *st, const cl_toc_t *toc, uint16_t seg_type);
const void* mon_map_segment(cl_monitor_state_t *st, const cl_toc_entry_t *e, uint32_t idx);

#endif

<<< END FILE: ./src/monitor/monitor_shm.h

>>> START FILE: ./src/monitor/monitor_state.c
#include "monitor_state.h"

static cl_monitor_state_t g_state = {
    .active_tab = TAB_DASHBOARD,
    .running = 1
};

cl_monitor_state_t* monitor_state(void) {
    return &g_state;
}

<<< END FILE: ./src/monitor/monitor_state.c

>>> START FILE: ./src/monitor/monitor_state.h
#ifndef CL_MONITOR_STATE_H
#define CL_MONITOR_STATE_H

#include <stddef.h> /* size_t */

typedef enum {
    TAB_DASHBOARD = 0,
    TAB_CPU,
    TAB_MEM,
    TAB_COUNT
} cl_mon_tab_t;

typedef struct {
    cl_mon_tab_t active_tab;
    int running;
    
    /* Der Live-Pointer ins SHM */
    void *core_base;    
    size_t core_size;

} cl_monitor_state_t;

cl_monitor_state_t* monitor_state(void);

#endif

<<< END FILE: ./src/monitor/monitor_state.h

>>> START FILE: ./src/monitor/monitor_ui.c
#include "monitor_ui.h"
#include <string.h>

void ui_init(void) {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0); /* Cursor verstecken */
    start_color();

    /* TVision Palette definieren */
    init_pair(CL_COLOR_BG,     COLOR_WHITE, COLOR_BLUE);
    init_pair(CL_COLOR_TITLE,  COLOR_BLACK, COLOR_CYAN);
    init_pair(CL_COLOR_STATUS, COLOR_BLACK, COLOR_WHITE);
    init_pair(CL_COLOR_TEXT,   COLOR_BLACK, COLOR_BLUE);
    init_pair(CL_COLOR_ALERT,  COLOR_BLACK, COLOR_RED);
}

void ui_shutdown(void) {
    endwin();
}

void ui_draw_screen_bg(void) {
    bkgd(COLOR_PAIR(CL_COLOR_BG));
    clear();
}

void ui_draw_header(const char *title, const char *subtitle) {
    int w = getmaxx(stdscr);
    attron(COLOR_PAIR(CL_COLOR_TITLE));
    mvprintw(0, 0, " %s", title);
    for (int i = strlen(title) + 1; i < w; i++) addch(' ');
    
    /* F-Keys Leiste drunter */
    mvprintw(1, 0, " %s", subtitle);
    for (int i = strlen(subtitle) + 1; i < w; i++) addch(' ');
    attroff(COLOR_PAIR(CL_COLOR_TITLE));
}

void ui_draw_statusbar(const char *status_left, const char *status_right) {
    int h = getmaxy(stdscr);
    int w = getmaxx(stdscr);
    
    attron(COLOR_PAIR(CL_COLOR_STATUS));
    move(h-1, 0);
    for(int i=0; i<w; i++) addch(' ');
    mvprintw(h-1, 1, "%s", status_left);
    mvprintw(h-1, w - strlen(status_right) - 1, "%s", status_right);
    attroff(COLOR_PAIR(CL_COLOR_STATUS));
}

void ui_draw_box(int y, int x, int h, int w, const char *title) {
    /* Rahmen zeichnen */
    attron(COLOR_PAIR(CL_COLOR_BG));
    /* Ecken und Linien (ACS = Alternate Character Set) */
    mvaddch(y, x, ACS_ULCORNER);
    mvaddch(y, x + w - 1, ACS_URCORNER);
    mvaddch(y + h - 1, x, ACS_LLCORNER);
    mvaddch(y + h - 1, x + w - 1, ACS_LRCORNER);
    
    for (int i = 1; i < w - 1; i++) {
        mvaddch(y, x + i, ACS_HLINE);
        mvaddch(y + h - 1, x + i, ACS_HLINE);
    }
    for (int i = 1; i < h - 1; i++) {
        mvaddch(y + i, x, ACS_VLINE);
        mvaddch(y + i, x + w - 1, ACS_VLINE);
    }
    
    /* Titel mittig im oberen Rahmen */
    if (title) {
        attron(A_BOLD);
        mvprintw(y, x + 2, " %s ", title);
        attroff(A_BOLD);
    }
}

void ui_draw_label_value(int y, int x, const char *label, const char *value) {
    attron(COLOR_PAIR(CL_COLOR_BG));
    mvprintw(y, x, "%s:", label);
    attron(COLOR_PAIR(CL_COLOR_TEXT) | A_BOLD);
    mvprintw(y, x + strlen(label) + 2, "%s", value);
    attroff(A_BOLD);
}

void ui_draw_progressbar(int y, int x, int width, int permille, int color_pair) {
    if (width < 3) return;
    
    int fill_w = (width * permille) / 1000;
    if (fill_w > width) fill_w = width;
    
    attron(COLOR_PAIR(color_pair));
    
    /* Rahmen optional oder direkt Balken */
    mvprintw(y, x, "[");
    for (int i = 0; i < width - 2; i++) {
        if (i < fill_w) addch('|'); // Oder ACS_BLOCK für vollen Block
        else addch('.');
    }
    mvprintw(y, x + width - 1, "]");
    
    /* Prozentzahl in die Mitte (optional) */
    char buf[16];
    snprintf(buf, sizeof(buf), " %3d%% ", permille / 10);
    if ((int)strlen(buf) < width - 4) {
        mvprintw(y, x + (width/2) - (strlen(buf)/2), "%s", buf);
    }
    
    attroff(COLOR_PAIR(color_pair));
}

<<< END FILE: ./src/monitor/monitor_ui.c

>>> START FILE: ./src/monitor/monitor_ui.h
#ifndef CL_MONITOR_UI_H
#define CL_MONITOR_UI_H

#include "monitor_curses.h"

/* Farben (TVision Style) */
#define CL_COLOR_BG       1  /* Blau / Weiß */
#define CL_COLOR_TITLE    2  /* Schwarz / Cyan */
#define CL_COLOR_STATUS   3  /* Schwarz / Grau */
#define CL_COLOR_TEXT     4  /* Weiß / Blau */
#define CL_COLOR_ALERT    5  /* Weiß / Rot */

void ui_init(void);
void ui_shutdown(void);

/* Zeichen-Primitive */
void ui_draw_screen_bg(void);
void ui_draw_header(const char *title, const char *subtitle);
void ui_draw_statusbar(const char *status_left, const char *status_right);
void ui_draw_box(int y, int x, int h, int w, const char *title);
void ui_draw_label_value(int y, int x, const char *label, const char *value);
void ui_draw_progressbar(int y, int x, int width, int permille, int color_pair);

#endif

<<< END FILE: ./src/monitor/monitor_ui.h

>>> START FILE: ./src/monitor/monitor.c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include "monitor_curses.h"
#include "monitor_ui.h"
#include "monitor_state.h"
#include "monitor_input.h"
#include "monitor_shm.h" /* WICHTIG: Neue API */
#include "tabs.h"

int main(void) {
    cl_monitor_state_t *st = monitor_state();
    
    /* Neue API Verbindung */
    mon_shm_connect(st);

    ui_init();

    while (st->running) {
        ui_draw_screen_bg();
        
        char title_buf[128];
        const char *tab_name = "Unknown";
        switch (st->active_tab) {
            case TAB_DASHBOARD: tab_name = "Dashboard"; break;
            case TAB_CPU:       tab_name = "CPU Core Physics"; break;
            case TAB_MEM:       tab_name = "Memory Matrix"; break;
            default:            tab_name = "Section"; break;
        }
        snprintf(title_buf, sizeof(title_buf), "CommanderLink Monitor - %s", tab_name);
        ui_draw_header(title_buf, " F1:Dash  F2:CPU  F3:Mem  F10:Quit");
        
        int h = getmaxy(stdscr);
        int w = getmaxx(stdscr);
        
        /* Zeichnen */
        switch (st->active_tab) {
            case TAB_DASHBOARD: tab_dashboard_draw(h, w); break;
            case TAB_CPU:       /* Placeholder oder Implementierung */ break;
            case TAB_MEM:       /* Placeholder */ break;
            default: break;
        }

        /* Statusbar & Reconnect Logic */
        char status_right[64];
        if (st->core_base) {
            snprintf(status_right, sizeof(status_right), "SHM: ONLINE (%zu B)", st->core_size);
        } else {
            snprintf(status_right, sizeof(status_right), "SHM: SEARCHING...");
            mon_shm_connect(st); /* Auto-Reconnect Versuch jeden Frame */
        }
        
        ui_draw_statusbar(" TAB/Arrows: Switch Tab | ENTER: Select", status_right);

        refresh();
        monitor_handle_input(getch());
    }

    ui_shutdown();
    mon_shm_disconnect(st);
    
    return 0;
}

<<< END FILE: ./src/monitor/monitor.c

>>> START FILE: ./src/monitor/tabs.h
#ifndef CL_TABS_H
#define CL_TABS_H

#include "monitor_curses.h"

/* Jeder Tab muss diese Signatur haben */
typedef void (*tab_draw_fn)(int h, int w);
typedef void (*tab_input_fn)(int key);

/* Dashboard Tab (Demo) */
void tab_dashboard_draw(int h, int w);
void tab_dashboard_input(int key);

#endif

<<< END FILE: ./src/monitor/tabs.h

>>> START FILE: ./src/monitor/tabs/tab_dashboard.c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <math.h>

#include "../monitor_ui.h"
#include "../monitor_curses.h"
#include "../tabs.h"
#include "../monitor_state.h"
#include "../monitor_shm.h" // Unsere neue SSOT API

/* Runtime Headers für die Struct-Casts */
#include "../../../include/cl_runtime/cl_seg_cpu_1024.h"
#include "../../../include/cl_runtime/cl_seg_mem_256.h"
#include "../../../include/cl_runtime/cl_seg_dma_4096.h"
#include "../../../include/cl_runtime/cl_seg_zfs_4096.h"

/* --- Helpers --- */

static void fmt_size(char *buf, size_t sz, uint64_t bytes) {
    const double GiB = 1024.0 * 1024.0 * 1024.0;
    const double MiB = 1024.0 * 1024.0;
    
    if (bytes >= GiB) snprintf(buf, sz, "%.2f GiB", (double)bytes / GiB);
    else if (bytes >= MiB) snprintf(buf, sz, "%.2f MiB", (double)bytes / MiB);
    else snprintf(buf, sz, "%" PRIu64 " B", bytes);
}

static void fmt_time(char *buf, size_t sz, uint64_t ns) {
    uint64_t s = ns / 1000000000ULL;
    uint32_t h = s / 3600;
    uint32_t m = (s % 3600) / 60;
    uint32_t sec = s % 60;
    snprintf(buf, sz, "%02u:%02u:%02u", h, m, sec);
}

/* --- Drawing --- */

void tab_dashboard_draw(int h, int w) {
    cl_monitor_state_t *st = monitor_state();

    /* 1. SSOT: Root holen */
    const cl_root_4096_t *root = mon_get_root(st);
    if (!root) {
        ui_draw_box(h/2-2, w/2-20, 5, 40, "OFFLINE");
        mvprintw(h/2, w/2-15, "Waiting for Shared Memory...");
        return;
    }

    /* 2. SSOT: TOC holen */
    const cl_toc_t *toc = mon_get_toc(st, root);
    if (!toc) {
        ui_draw_box(h/2-2, w/2-20, 5, 40, "ERROR");
        mvprintw(h/2, w/2-15, "TOC Integrity Check Failed");
        return;
    }

    /* 3. Layout Grid berechnen */
    int col_width = (w / 2) - 2;
    int col2_x = col_width + 4;
    
    /* --- SECTION: GLOBAL HEALTH (Oben) --- */
    ui_draw_box(2, 2, 5, w-4, "System Health");
    
    char tbuf[64];
    fmt_time(tbuf, sizeof(tbuf), atomic_load(&root->uptime_ns));
    ui_draw_label_value(4, 4, "Uptime", tbuf);

    uint64_t seq = atomic_load(&root->seq_cnt);
    snprintf(tbuf, sizeof(tbuf), "%" PRIu64, seq);
    ui_draw_label_value(4, 30, "Heartbeat", tbuf);

    uint32_t rx = atomic_load(&root->rx_gate);
    uint32_t tx = atomic_load(&root->tx_gate);
    
    attron(COLOR_PAIR(CL_COLOR_TEXT));
    mvprintw(4, 55, "GATES: RX[%c] TX[%c]", 
             rx ? 'X' : 'O', 
             tx ? 'X' : 'O');
    attroff(COLOR_PAIR(CL_COLOR_TEXT));


    /* --- SECTION: COMPUTE UNIT (Links) --- */
    ui_draw_box(7, 2, 14, col_width, "Compute Unit (CPU)");
    
    const cl_toc_entry_t *e_cpu = mon_find_entry(st, toc, CL_CPU_SEG_1024);
    if (e_cpu) {
        uint32_t count = e_cpu->count;
        uint64_t load_sum = 0;
        uint64_t temp_sum = 0;
        char model[64] = "Unknown";

        /* Aggregate Stats */
        for (uint32_t i=0; i<count; i++) {
            const cl_cpu_seg_1024_t *cpu = (const cl_cpu_seg_1024_t*)mon_map_segment(st, e_cpu, i);
            if (cpu) {
                load_sum += atomic_load(&cpu->hot_a.load_permille);
                temp_sum += atomic_load(&cpu->hot_a.temp_c_x10);
                if (i==0) {
                     snprintf(model, sizeof(model), "%s %s", 
                        cpu->cold_b.vendor_str, cpu->cold_b.model_str_a);
                }
            }
        }
        
        uint32_t avg_load = (count > 0) ? (load_sum / count) : 0;
        uint32_t avg_temp = (count > 0) ? (temp_sum / count) : 0; // x10

        ui_draw_label_value(9, 4, "Model", model);
        snprintf(tbuf, sizeof(tbuf), "%u Physical Cores", count);
        ui_draw_label_value(10, 4, "Topology", tbuf);

        /* Load Bar */
        mvprintw(12, 4, "Avg Load:");
        /* Load is permille (0-1000). Green < 50%, Yellow < 80%, Red > 80% */
        int color = CL_COLOR_TEXT; // Standard Blau/Gelb
        if (avg_load > 800) color = CL_COLOR_ALERT;
        ui_draw_progressbar(13, 4, col_width-6, avg_load, color);

        /* Temp Bar */
        double temp_c = (double)avg_temp / 10.0;
        snprintf(tbuf, sizeof(tbuf), "Thermals (%.1f %cC)", temp_c, ACS_DEGREE);
        mvprintw(15, 4, "%s", tbuf);
        
        /* Temp Scaling: 0°C - 100°C maps to 0-1000 permille for bar */
        int temp_permille = avg_temp; // da avg_temp schon x10 ist (450 = 45.0 = 45%)
        if (temp_permille > 1000) temp_permille = 1000;
        
        int t_color = CL_COLOR_TEXT;
        if (temp_c > 75.0) t_color = CL_COLOR_ALERT;
        ui_draw_progressbar(16, 4, col_width-6, temp_permille, t_color);

    } else {
        mvprintw(10, 4, "No CPU Segment found.");
    }


    /* --- SECTION: MEMORY MATRIX (Rechts) --- */
    ui_draw_box(7, col2_x, 14, col_width, "Memory Matrix");
    
    const cl_toc_entry_t *e_mem = mon_find_entry(st, toc, CL_MEM_SEG_256);
    if (e_mem) {
        const cl_mem_seg_256_t *mem = (const cl_mem_seg_256_t*)mon_map_segment(st, e_mem, 0);
        if (mem) {
            uint64_t total = atomic_load(&mem->hot.total_bytes);
            uint64_t free  = atomic_load(&mem->hot.free_bytes);
            uint64_t used  = total - free;
            uint32_t press = atomic_load(&mem->hot.pressure_permille);

            char s_tot[32], s_free[32], s_used[32];
            fmt_size(s_tot, sizeof(s_tot), total);
            fmt_size(s_free, sizeof(s_free), free);
            fmt_size(s_used, sizeof(s_used), used);

            ui_draw_label_value(9, col2_x+2,  "Total", s_tot);
            ui_draw_label_value(10, col2_x+2, "Used ", s_used);
            ui_draw_label_value(11, col2_x+2, "Free ", s_free);

            /* Usage Bar */
            int usage_permille = 0;
            if (total > 0) usage_permille = (used * 1000) / total;
            
            mvprintw(13, col2_x+2, "RAM Usage:");
            ui_draw_progressbar(14, col2_x+2, col_width-6, usage_permille, CL_COLOR_TEXT);

            /* Pressure Bar (Memory Pressure Stall Information simulator) */
            mvprintw(16, col2_x+2, "Pressure Index:");
            int p_color = (press > 300) ? CL_COLOR_ALERT : CL_COLOR_TEXT;
            ui_draw_progressbar(17, col2_x+2, col_width-6, press, p_color);
        }
    } else {
        mvprintw(10, col2_x+2, "No MEM Segment found.");
    }


    /* --- SECTION: DATA PLANE / INFRA (Unten) --- */
    /* Check for DMA or ZFS segments */
    const cl_toc_entry_t *e_dma = mon_find_entry(st, toc, CL_DMA_SEG_4096);
    const cl_toc_entry_t *e_zfs = mon_find_entry(st, toc, CL_ZFS_SEG_4096);

    ui_draw_box(21, 2, 6, w-4, "Data Plane & Storage");

    if (e_dma) {
        /* DMA meist Ringbuffer */
        ui_draw_label_value(23, 4, "DMA Engine", "ONLINE");
        mvprintw(23, 30, "[Active Ring Handling]");
    } else {
        ui_draw_label_value(23, 4, "DMA Engine", "N/A");
    }

    if (e_zfs) {
        const cl_zfs_seg_4096_t *zfs = (const cl_zfs_seg_4096_t*)mon_map_segment(st, e_zfs, 0);
        if (zfs) {
             /* HIER WAR DER FEHLER: Zugriff über .arc Unterstruktur */
             uint64_t hits = atomic_load(&zfs->arc.arc_hits);
             uint64_t miss = atomic_load(&zfs->arc.arc_misses);
             uint64_t total_arc = hits + miss;
             int ratio = 0;
             if (total_arc > 0) ratio = (hits * 100) / total_arc;
             
             snprintf(tbuf, sizeof(tbuf), "ARC Hitrate: %d%%", ratio);
             ui_draw_label_value(24, 4, "ZFS Cache", tbuf);
        }
    } else {
        ui_draw_label_value(24, 4, "ZFS Cache", "No Segment");
    }

}

void tab_dashboard_input(int key) {
    (void)key;
}

<<< END FILE: ./src/monitor/tabs/tab_dashboard.c

>>> START FILE: ./src/oracle/oracle0.c
#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>

#include "cl_runtime/cl_runtime.h"
#include "cl_runtime/cl_service_seg_256.h"

static uint64_t now_ns(void){ struct timespec ts; clock_gettime(CLOCK_MONOTONIC,&ts); return (uint64_t)ts.tv_sec*1000000000ull+(uint64_t)ts.tv_nsec; }

static int map_core_rw(void **out_base, size_t *out_sz){
    int fd=shm_open(CL_CORE_SHM_NAME,O_RDWR,0); if(fd<0) return -1;
    struct stat st; if(fstat(fd,&st)!=0){close(fd);return -2;} if(st.st_size<=0){close(fd);return -3;}
    void *p=mmap(NULL,(size_t)st.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); close(fd);
    if(p==MAP_FAILED) return -4; *out_base=p; *out_sz=(size_t)st.st_size; return 0;
}

static cl_service_seg_256_t* find_service_seg(void *core_base){
    cl_root_t *r=(cl_root_t*)core_base;
    cl_toc_t *toc=(cl_toc_t*)((uint8_t*)core_base+(size_t)r->toc_offset);
    for(uint32_t i=0;i<toc->header.entry_count && i<CL_TOC_MAX_ENTRIES;i++){
        cl_toc_entry_t *e=&toc->entries[i];
        if((uint16_t)e->type==(uint16_t)CL_SERVICE_SEG_256) return (cl_service_seg_256_t*)((uint8_t*)core_base+(size_t)e->offset_bytes);
    }
    return NULL;
}

static cl_service_slot_32_t* slot_for(cl_service_seg_256_t *svc, cl_service_id_t id){
    switch(id){
        case CL_SVC_CORE0: return &svc->g1.s0;
        case CL_SVC_HAL0: return &svc->g1.s1;
        case CL_SVC_LINK0: return &svc->g2.s2;
        case CL_SVC_FLOW0: return &svc->g2.s3;
        case CL_SVC_ORACLE0: return &svc->g3.s4;
        case CL_SVC_MONITOR: return &svc->g3.s5;
        default: return NULL;
    }
}

int main(void){
    void *core=NULL; size_t core_sz=0;
    int rc=map_core_rw(&core,&core_sz);
    if(rc!=0){ printf("oracle0: cannot map core shm: rc=%d errno=%d (%s)\n",rc,errno,strerror(errno)); return 2; }
    cl_service_seg_256_t *svc=find_service_seg(core);
    if(!svc){ printf("oracle0: service segment not found\n"); return 3; }
    cl_service_slot_32_t *sl=slot_for(svc,CL_SVC_ORACLE0);
    if(!sl) return 4;

    for(;;){
        atomic_store(&sl->last_heartbeat_ns, now_ns());
        struct timespec ts={0}; ts.tv_nsec=250000000L; nanosleep(&ts,NULL);
    }
}


<<< END FILE: ./src/oracle/oracle0.c

>>> START FILE: ./tools/cl_abi_report/cl_abi_report.c
/*
 * ============================================================================
 * CommanderLink – ABI / Layout Report Tool (Truth Meter) – FINAL Endausbau
 * Datei: tools/cl_abi_report/cl_abi_report.c
 * ============================================================================
 *
 * Zweck:
 *   - Compile-time ABI: Größen/Alignments/Offsets prüfen (muss immer grün)
 *   - Runtime ABI (optional): Root + TOC + Segment-Geometrie gegen SHM prüfen
 *
 * Maschinenregeln:
 *   - Keine Heuristik. Keine Policy. Nur Verifikation.
 *   - Wenn Root FAILFAST setzt, ist ABI-Mismatch hartes Fail.
 *
 * Plattform:
 *   - Linux / BSD / OmniOS (POSIX shm_open + mmap)
 * ============================================================================
 */

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <stddef.h>
#include <stdalign.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include "../../include/cl_runtime/cl_runtime.h"

/* --------------------------- Hash (FNV-1a 64) ---------------------------- */

static uint64_t fnv1a64_init(void) { return 1469598103934665603ull; }
static uint64_t fnv1a64_u64(uint64_t h, uint64_t v) {
    for (int i = 0; i < 8; i++) {
        uint8_t b = (uint8_t)((v >> (i * 8)) & 0xffu);
        h ^= (uint64_t)b;
        h *= 1099511628211ull;
    }
    return h;
}
static uint64_t fnv1a64_u32(uint64_t h, uint32_t v) { return fnv1a64_u64(h, (uint64_t)v); }
static uint64_t fnv1a64_sz(uint64_t h, size_t v) { return fnv1a64_u64(h, (uint64_t)v); }

/* ABI-Fingerprint: compile-time Wahrheiten */
static uint64_t cl_compute_abi_fingerprint(void) {
    uint64_t h = fnv1a64_init();

    /* Schema */
    h = fnv1a64_u32(h, (uint32_t)CL_SCHEMA_VERSION_U32);
    h = fnv1a64_u32(h, (uint32_t)CL_ENDIAN_MAGIC_U32);
    h = fnv1a64_u32(h, (uint32_t)CL_SHM_PAGE_BYTES);

    /* Root/TOC sizes */
    h = fnv1a64_sz(h, sizeof(cl_root_t));
    h = fnv1a64_sz(h, sizeof(cl_toc_header_t));
    h = fnv1a64_sz(h, sizeof(cl_toc_entry_t));
    h = fnv1a64_u32(h, (uint32_t)CL_TOC_MAX_ENTRIES);
    h = fnv1a64_u32(h, (uint32_t)CL_TOC_VERSION);

    /* Segment sizes (SSOT = struct sizes) */
    h = fnv1a64_sz(h, sizeof(cl_cpu_seg_1024_t));
    h = fnv1a64_sz(h, sizeof(cl_budget_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_mem_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_link_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_overlay_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_watchdog_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_pcie_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_time_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_mesh_neighbor_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_mesh_peer_seg_256_t));
    h = fnv1a64_sz(h, sizeof(cl_oracle_seg_256_t));

    h = fnv1a64_sz(h, sizeof(cl_nic_seg_512_t));
    h = fnv1a64_sz(h, sizeof(cl_board_seg_512_t));

    h = fnv1a64_sz(h, sizeof(cl_dma_seg_4096_t));
    h = fnv1a64_sz(h, sizeof(cl_history_seg_4096_t));
    h = fnv1a64_sz(h, sizeof(cl_forensics_seg_4096_t));
    h = fnv1a64_sz(h, sizeof(cl_zfs_seg_4096_t));

    /* Alignments */
    h = fnv1a64_sz(h, (size_t)alignof(cl_root_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_cpu_seg_1024_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_dma_seg_4096_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_zfs_seg_4096_t));

    /* Critical offsets: Root */
    h = fnv1a64_sz(h, offsetof(cl_root_t, abi_layout_checksum));
    h = fnv1a64_sz(h, offsetof(cl_root_t, toc_offset));
    h = fnv1a64_sz(h, offsetof(cl_root_t, toc_size));
    h = fnv1a64_sz(h, offsetof(cl_root_t, schema_version));
    h = fnv1a64_sz(h, offsetof(cl_root_t, endian_magic));
    h = fnv1a64_sz(h, offsetof(cl_root_t, root_magic));
    h = fnv1a64_sz(h, offsetof(cl_root_t, root_flags));
    h = fnv1a64_sz(h, offsetof(cl_root_t, bulk_present));
    h = fnv1a64_sz(h, offsetof(cl_root_t, bulk_epoch));

    /* Critical offsets: TOC entry */
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, type));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, stride_bytes));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, count));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, offset_bytes));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, source_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, access_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, presence_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, layout_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, gates_possible));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, gates_effective));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, epoch));

    return h;
}

/* ---------------------------- Helpers ----------------------------------- */

static int is_allowed_stride(uint32_t s) {
    return (s == 256u) || (s == 512u) || (s == 1024u) || (s == 4096u);
}

static int check_bounds_u64(uint64_t off, uint64_t len, uint64_t total) {
    if (off > total) return 0;
    if (len > total) return 0;
    if (off + len > total) return 0;
    return 1;
}

static int map_shm_ro(const char *name, void **out_base, size_t *out_sz) {
    int fd = shm_open(name, O_RDONLY, 0);
    if (fd < 0) return -1;

    struct stat st;
    if (fstat(fd, &st) != 0) {
        close(fd);
        return -2;
    }
    if (st.st_size <= 0) {
        close(fd);
        return -3;
    }

    void *p = mmap(NULL, (size_t)st.st_size, PROT_READ, MAP_SHARED, fd, 0);
    close(fd);
    if (p == MAP_FAILED) return -4;

    *out_base = p;
    *out_sz = (size_t)st.st_size;
    return 0;
}

static void unmap_shm(void *base, size_t sz) {
    if (base && sz) (void)munmap(base, sz);
}

/* ---------------------------- Reports ----------------------------------- */

static int report_compile_time_sizes(void) {
    int ok = 1;

    if (sizeof(cl_root_t) != 4096u) ok = 0;
    if (sizeof(cl_toc_header_t) != 64u) ok = 0;
    if (sizeof(cl_toc_entry_t) != 64u) ok = 0;

    if (sizeof(cl_budget_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_mem_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_link_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_time_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_overlay_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_watchdog_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_pcie_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_mesh_neighbor_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_mesh_peer_seg_256_t) != 256u) ok = 0;
    if (sizeof(cl_oracle_seg_256_t) != 256u) ok = 0;

    if (sizeof(cl_nic_seg_512_t) != 512u) ok = 0;
    if (sizeof(cl_board_seg_512_t) != 512u) ok = 0;

    if (sizeof(cl_cpu_seg_1024_t) != 1024u) ok = 0;

    if (sizeof(cl_dma_seg_4096_t) != 4096u) ok = 0;
    if (sizeof(cl_history_seg_4096_t) != 4096u) ok = 0;
    if (sizeof(cl_forensics_seg_4096_t) != 4096u) ok = 0;
    if (sizeof(cl_zfs_seg_4096_t) != 4096u) ok = 0;

    if (!ok) {
        printf("CT FAIL: size drift detected.\n");
        return 1;
    }

    printf("CT OK: sizes stable.\n");
    printf("ABI fingerprint (CT): 0x%016" PRIx64 "\n", cl_compute_abi_fingerprint());
    return 0;
}

static int report_runtime_shm(void *core_base, size_t core_sz,
                              void *bulk_base, size_t bulk_sz, int bulk_mapped) {
    (void)bulk_base; /* optional */
    (void)bulk_sz;

    const cl_root_t *r = (const cl_root_t*)core_base;

    if (r->root_magic != CL_ROOT_MAGIC_U32) return 10;
    if (r->endian_magic != CL_ENDIAN_MAGIC_U32) return 11;
    if (r->schema_version != CL_SCHEMA_VERSION_U32) return 12;

    uint64_t want = cl_compute_abi_fingerprint();
    if (r->abi_layout_checksum != want) {
        if ((r->root_flags & CL_ROOT_FLAG_FAILFAST_ABI) != 0u) return 13;
    }

    if (!check_bounds_u64(r->toc_offset, r->toc_size, (uint64_t)core_sz)) return 14;
    if (r->toc_size < sizeof(cl_toc_header_t)) return 15;

    const cl_toc_t *toc = (const cl_toc_t*)((const uint8_t*)core_base + (size_t)r->toc_offset);
    if (toc->header.entry_count > CL_TOC_MAX_ENTRIES) return 16;

    uint64_t need = (uint64_t)sizeof(cl_toc_header_t) +
                    (uint64_t)toc->header.entry_count * (uint64_t)sizeof(cl_toc_entry_t);
    if (need > r->toc_size) return 17;

    for (uint32_t i = 0; i < toc->header.entry_count; i++) {
        const cl_toc_entry_t *e = &toc->entries[i];
        uint32_t stride = (uint32_t)e->stride_bytes;
        uint32_t count  = (uint32_t)e->count;
        uint64_t off    = (uint64_t)e->offset_bytes;

        if (!is_allowed_stride(stride)) return 18;

        uint64_t seg_bytes = (uint64_t)stride * (uint64_t)count;
        if ((off % (uint64_t)stride) != 0u) return 19;

        const int in_bulk = ((e->flags & CL_TOC_FLAG_RECLAIMABLE) != 0u);
        if (!in_bulk) {
            if (!check_bounds_u64(off, seg_bytes, (uint64_t)core_sz)) return 20;
        } else {
            if (bulk_mapped) {
                if (!check_bounds_u64(off, seg_bytes, (uint64_t)bulk_sz)) return 21;
            }
        }
    }

    return 0;
}

int main(void) {
    /* compile-time ABI must be green */
    int ct = report_compile_time_sizes();
    if (ct != 0) return ct;

    /* runtime check is optional; if no SHM exists, exit clean */
    void *core_base = NULL;
    size_t core_sz = 0;
    int rc = map_shm_ro(CL_CORE_SHM_NAME, &core_base, &core_sz);
    if (rc != 0) {
           printf("RT INFO: core shm not mapped (%s): rc=%d errno=%d (%s); compile-time ABI is green.\n",
           CL_CORE_SHM_NAME, rc, errno, strerror(errno));
    return 0;
    }

    void *bulk_base = NULL;
    size_t bulk_sz = 0;
    int bulk_mapped = (map_shm_ro(CL_BULK_SHM_NAME, &bulk_base, &bulk_sz) == 0);

    int rt = report_runtime_shm(core_base, core_sz, bulk_base, bulk_sz, bulk_mapped);

    unmap_shm(core_base, core_sz);
    if (bulk_mapped) unmap_shm(bulk_base, bulk_sz);

    if (rt == 0) {
        printf("RT OK: root/toc/segments geometry validated.\n");
        return 0;
    }
    printf("RT FAIL: code=%d\n", rt);
    return rt;
}


<<< END FILE: ./tools/cl_abi_report/cl_abi_report.c

>>> START FILE: ./tools/cl_abi_report/README.md
# cl_abi_report

ABI-/Layout-Prüfgerät für CommanderLink.

## Zweck
- Prüft Root/TOC/Segment-Geometrie gegen reale SHM-Mappings.
- Meldet ABI-Drift deterministisch.

## Ablauf
1) `cl_dummy_shm` starten (erzeugt /cl_core_root)
2) `cl_abi_report` starten (liest /cl_core_root, prüft TOC/Segmente)

## Ausgabe
- `ABI_STABLE` oder `ABI_UNSTABLE`


<<< END FILE: ./tools/cl_abi_report/README.md

>>> START FILE: ./tools/cl_dummy_shm/cl_dummy_shm.c
/*
 * ============================================================================
 * CommanderLink – Dummy SHM Generator (Core-SHM) – FINAL Endausbau
 * Datei: tools/cl_dummy_shm/cl_dummy_shm.c
 * ============================================================================
 *
 * Zweck:
 *   - Erzeugt /cl_core_root (Core-SHM) mit Root + TOC + Segment-Records
 *   - Initialisiert einen minimalen, konsistenten Runtime-Snapshot
 *   - Dient NUR für Tests/Bringup (Monitor/ABI-Report/shm_dump), nicht produktiv
 *
 * Maschinenregel:
 *   - Host-Order im SHM
 *   - Keine packed Layouts
 *   - Stride/Offsets exakt wie in den Headern
 *   - TOC ist Header+Entries (keine Legacy-Felder)
 *
 * Hinweis:
 *   - Bulk-SHM wird hier NICHT erzeugt. bulk_present = 0.
 * ============================================================================
 */

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdatomic.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>

#include "../../include/cl_runtime/cl_runtime.h"

/* --------------------------------------------------------------------------
 * Zeit
 * -------------------------------------------------------------------------- */
static uint64_t now_ns(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)ts.tv_sec * 1000000000ull + (uint64_t)ts.tv_nsec;
}

/* --------------------------------------------------------------------------
 * Hash (FNV-1a 64) – identisch zum ABI-Report
 * -------------------------------------------------------------------------- */
static uint64_t fnv1a64_init(void) { return 1469598103934665603ull; }

static uint64_t fnv1a64_u64(uint64_t h, uint64_t v) {
    for (int i = 0; i < 8; i++) {
        uint8_t b = (uint8_t)((v >> (i * 8)) & 0xffu);
        h ^= (uint64_t)b;
        h *= 1099511628211ull;
    }
    return h;
}
static uint64_t fnv1a64_u32(uint64_t h, uint32_t v) { return fnv1a64_u64(h, (uint64_t)v); }
static uint64_t fnv1a64_sz(uint64_t h, size_t v) { return fnv1a64_u64(h, (uint64_t)v); }

static uint64_t cl_compute_abi_fingerprint(void) {
    uint64_t h = fnv1a64_init();

    /* Schema */
    h = fnv1a64_u32(h, (uint32_t)CL_SCHEMA_VERSION_U32);
    h = fnv1a64_u32(h, (uint32_t)CL_ENDIAN_MAGIC_U32);
    h = fnv1a64_u32(h, (uint32_t)CL_SHM_PAGE_BYTES);

    /* Root / TOC */
    h = fnv1a64_sz(h, sizeof(cl_root_t));
    h = fnv1a64_sz(h, sizeof(cl_toc_header_t));
    h = fnv1a64_sz(h, sizeof(cl_toc_entry_t));
    h = fnv1a64_u32(h, (uint32_t)CL_TOC_MAX_ENTRIES);
    h = fnv1a64_u32(h, (uint32_t)CL_TOC_VERSION);

    /* Segmentgrößen (Strides) */
    h = fnv1a64_sz(h, sizeof(cl_seg_cpu_1024_t));
    h = fnv1a64_sz(h, sizeof(cl_budget_seg_256_t));     /* Budget */
    h = fnv1a64_sz(h, sizeof(cl_seg_mem_256_t));        /* Memory */
    h = fnv1a64_sz(h, sizeof(cl_seg_nic_512_t));        /* NIC */
    h = fnv1a64_sz(h, sizeof(cl_seg_link_256_t));       /* Link Summary */
    h = fnv1a64_sz(h, sizeof(cl_overlay_seg_256_t));    /* Overlay */
    h = fnv1a64_sz(h, sizeof(cl_watchdog_seg_256_t));   /* Watchdog */
    h = fnv1a64_sz(h, sizeof(cl_seg_pcie_256_t));       /* PCIe */
    h = fnv1a64_sz(h, sizeof(cl_seg_board_512_t));      /* Board */
    h = fnv1a64_sz(h, sizeof(cl_seg_time_256_t));       /* Timebase */
    h = fnv1a64_sz(h, sizeof(cl_seg_mesh_neighbor_256_t)); /* Hot Neighbor */
    h = fnv1a64_sz(h, sizeof(cl_seg_zfs_4096_t));       /* ZFS Summary */

    /* Alignments */
    h = fnv1a64_sz(h, (size_t)alignof(cl_root_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_seg_cpu_1024_t));
    h = fnv1a64_sz(h, (size_t)alignof(cl_seg_zfs_4096_t));

    /* Root Offsets (kritisch) */
    h = fnv1a64_sz(h, offsetof(cl_root_t, abi_layout_checksum));
    h = fnv1a64_sz(h, offsetof(cl_root_t, toc_offset));
    h = fnv1a64_sz(h, offsetof(cl_root_t, toc_size));
    h = fnv1a64_sz(h, offsetof(cl_root_t, schema_version));
    h = fnv1a64_sz(h, offsetof(cl_root_t, endian_magic));
    h = fnv1a64_sz(h, offsetof(cl_root_t, root_magic));
    h = fnv1a64_sz(h, offsetof(cl_root_t, root_flags));
    h = fnv1a64_sz(h, offsetof(cl_root_t, bulk_present));
    h = fnv1a64_sz(h, offsetof(cl_root_t, bulk_epoch));

    /* TOC Entry Offsets */
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, type));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, stride_bytes));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, count));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, offset_bytes));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, source_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, access_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, presence_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, layout_flags));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, gates_possible));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, gates_effective));
    h = fnv1a64_sz(h, offsetof(cl_toc_entry_t, epoch));

    return h;
}

/* --------------------------------------------------------------------------
 * Alignment Helper
 * -------------------------------------------------------------------------- */
static size_t align_up(size_t v, size_t a) {
    if (a == 0) return v;
    size_t r = v % a;
    return r ? (v + (a - r)) : v;
}

/* --------------------------------------------------------------------------
 * TOC Helper (neues Layout)
 * -------------------------------------------------------------------------- */
static void toc_init(cl_toc_t *toc, uint64_t total_bytes, uint64_t build_id) {
    memset(toc, 0, sizeof(*toc));
    toc->header.version = CL_TOC_VERSION;
    toc->header.entry_count = 0;
    toc->header.total_bytes = total_bytes;
    toc->header.build_id = build_id;
    toc->header.epoch = 1;
}

static cl_toc_entry_t* toc_add(cl_toc_t *toc,
                               cl_segment_type_t type,
                               uint16_t seg_version,
                               cl_toc_flags_t flags,
                               uint32_t stride_bytes,
                               uint32_t count,
                               uint64_t offset_bytes,
                               uint16_t source_flags,
                               uint16_t access_flags,
                               uint16_t presence_flags,
                               uint16_t layout_flags,
                               uint64_t gates_possible,
                               uint64_t gates_effective,
                               uint64_t epoch)
{
    if (toc->header.entry_count >= CL_TOC_MAX_ENTRIES) return NULL;

    cl_toc_entry_t *e = &toc->entries[toc->header.entry_count++];
    memset(e, 0, sizeof(*e));

    e->type = (uint16_t)type;
    e->version = seg_version;
    e->flags = (uint32_t)flags;

    e->stride_bytes = stride_bytes;
    e->count = count;
    e->offset_bytes = offset_bytes;

    e->source_flags = source_flags;
    e->access_flags = access_flags;
    e->presence_flags = presence_flags;
    e->layout_flags = layout_flags;

    e->gates_possible = (cl_gate_mask_t)gates_possible;
    e->gates_effective = (cl_gate_mask_t)gates_effective;

    e->epoch = epoch;
    e->reserved0 = 0;

    return e;
}

/* --------------------------------------------------------------------------
 * Minimal Fill Helpers (keine Heuristik)
 * -------------------------------------------------------------------------- */
static void fill_budget(cl_budget_seg_256_t *b) {
    /* Alle Felder deterministisch: nur ein Snapshot */
    b->cl0_ident.v.epoch = 1;
    b->cl0_ident.v.tsc_last_update = 0;
    b->cl0_ident.v.window_ns = 250000000ull; /* 250ms window als Beispiel */
    b->cl0_ident.v.window_start_tsc = 0;

    b->cl1_capacity.v.cpu_possible_ns = 250000000ull;
    b->cl1_capacity.v.cpu_effective_ns = 250000000ull;
    b->cl1_capacity.v.net_possible_ns = 250000000ull;
    b->cl1_capacity.v.net_effective_ns = 250000000ull;

    b->cl2_usage.v.cpu_used_ns = 0;
    b->cl2_usage.v.net_used_ns = 0;
    b->cl2_usage.v.stall_events = 0;
    b->cl2_usage.v.interactive_events = 0;

    b->cl3_state.v.gates.possible = 0;
    b->cl3_state.v.gates.effective = 0;
    b->cl3_state.v.gates_seen = 0;
    b->cl3_state.v.reclaim_events = 0;
}

static void fill_mem(cl_seg_mem_256_t *m) {
    atomic_store(&m->hot.total_bytes, 32ull * 1024ull * 1024ull * 1024ull);
    atomic_store(&m->hot.used_bytes,  8ull * 1024ull * 1024ull * 1024ull);
    atomic_store(&m->hot.free_bytes, 24ull * 1024ull * 1024ull * 1024ull);
    atomic_store(&m->hot.ecc_err_cnt, 0u);

    atomic_store(&m->hot.pressure_permille, 50u);
    atomic_store(&m->hot.reason_code, 0u);

    m->hot.src = 0;
    m->hot.qual = 0;

    atomic_store(&m->warm.bw_read_bps, 0u);
    atomic_store(&m->warm.bw_write_bps, 0u);
    atomic_store(&m->warm.timing_tcl, 0u);
    atomic_store(&m->warm.timing_trcd, 0u);
    atomic_store(&m->warm.timing_trp, 0u);
    atomic_store(&m->warm.timing_tras, 0u);
    atomic_store(&m->warm.channel_state, 0u);
    atomic_store(&m->warm.reclaim_events, 0u);
    atomic_store(&m->warm.last_update_ns, now_ns());

    memset(m->cold.dimm_mode, 0, sizeof(m->cold.dimm_mode));
    memset(m->cold.channel_mode, 0, sizeof(m->cold.channel_mode));
    strncpy(m->cold.dimm_mode, "DDR", sizeof(m->cold.dimm_mode)-1);
    strncpy(m->cold.channel_mode, "DUAL", sizeof(m->cold.channel_mode)-1);
    m->cold.src = 0;
    m->cold.qual = 0;

    atomic_store(&m->rsv.gates_possible, 0u);
    atomic_store(&m->rsv.gates_effective, 0u);
    atomic_store(&m->rsv.gates_seen, 0u);
    atomic_store(&m->rsv.oom_events, 0u);
    atomic_store(&m->rsv.reclaim_failures, 0u);
    atomic_store(&m->rsv.epoch, 1u);
    atomic_store(&m->rsv.last_gate_change_ns, now_ns());
}

static void fill_overlay(cl_overlay_seg_256_t *o) {
    o->cl0_ident.v.mesh_id = 0;
    o->cl0_ident.v.node_id = 0;
    o->cl0_ident.v.overlay_ipv4 = 0;
    o->cl0_ident.v.overlay_prefix = 32;
    o->cl0_ident.v.collision_offset = 0;
    o->cl0_ident.v.active = 0;

    o->cl1_trust.v.trust_state = 0;
    o->cl1_trust.v.join_epoch = 0;
    o->cl1_trust.v.grants_active = 0;
    o->cl1_trust.v.grants_revoked = 0;

    o->cl2_routing.v.routes_installed = 0;
    o->cl2_routing.v.routes_failed = 0;
    o->cl2_routing.v.fail_open = 0;
    o->cl2_routing.v.unreachable_peers = 0;

    o->cl3_state.v.gates.possible = 0;
    o->cl3_state.v.gates.effective = 0;
    o->cl3_state.v.gates_seen = 0;
    o->cl3_state.v.security_events = 0;
}

static void fill_watchdog(cl_watchdog_seg_256_t *w) {
    atomic_store(&w->cl0_liveness.v.heartbeat_seq, 1u);
    atomic_store(&w->cl0_liveness.v.last_heartbeat_tsc, 0u);
    atomic_store(&w->cl0_liveness.v.timeout_ns, 1000000000ull);
    atomic_store(&w->cl0_liveness.v.epoch, 1u);

    atomic_store(&w->cl1_faults.v.fault_flags, 0u);
    atomic_store(&w->cl1_faults.v.fault_epoch, 0u);
    atomic_store(&w->cl1_faults.v.escalation_level, 0u);
    atomic_store(&w->cl1_faults.v.escalation_count, 0u);

    atomic_store(&w->cl2_recovery.v.soft_restarts, 0u);
    atomic_store(&w->cl2_recovery.v.hard_restarts, 0u);
    atomic_store(&w->cl2_recovery.v.last_restart_tsc, 0u);
    atomic_store(&w->cl2_recovery.v.recovery_failures, 0u);

    w->cl3_state.v.gates.possible = 0;
    w->cl3_state.v.gates.effective = 0;
    w->cl3_state.v.gates_seen = 0;
    w->cl3_state.v.fatal_events = 0;
}

/* --------------------------------------------------------------------------
 * Main
 * -------------------------------------------------------------------------- */
int main(void) {
    const uint64_t boot_ns = now_ns();
    const uint64_t abi_fp = cl_compute_abi_fingerprint();

    /* Root(4096) + TOC(4096) + Segmente … */
    size_t toc_offset = CL_SHM_PAGE_BYTES;
    size_t toc_size   = CL_SHM_PAGE_BYTES;

    /* Start of segments after TOC page */
    size_t off = toc_offset + toc_size;
    off = align_up(off, 256);

    /* Segment Layout (Core-only in Dummy) */
    const uint32_t cpu_count = 1;
    const uint32_t nic_count = 1;
    const uint32_t neighbor_count = 32; /* Hot neighbors Ziel */

    /* Offsets: align to stride */
    size_t off_link      = align_up(off, 256);  off = off_link + sizeof(cl_seg_link_256_t);
    size_t off_budget    = align_up(off, 256);  off = off_budget + sizeof(cl_budget_seg_256_t);
    size_t off_mem       = align_up(off, 256);  off = off_mem + sizeof(cl_seg_mem_256_t);
    size_t off_overlay   = align_up(off, 256);  off = off_overlay + sizeof(cl_overlay_seg_256_t);
    size_t off_watchdog  = align_up(off, 256);  off = off_watchdog + sizeof(cl_watchdog_seg_256_t);

    size_t off_cpu       = align_up(off, 1024); off = off_cpu + cpu_count * sizeof(cl_seg_cpu_1024_t);
    size_t off_nic       = align_up(off, 512);  off = off_nic + nic_count * sizeof(cl_seg_nic_512_t);

    size_t off_pcie      = align_up(off, 256);  off = off_pcie + sizeof(cl_seg_pcie_256_t);
    size_t off_board     = align_up(off, 512);  off = off_board + sizeof(cl_seg_board_512_t);
    size_t off_time      = align_up(off, 256);  off = off_time + sizeof(cl_seg_time_256_t);

    size_t off_neighbor  = align_up(off, 256);  off = off_neighbor + neighbor_count * sizeof(cl_seg_mesh_neighbor_256_t);

    size_t off_zfs       = align_up(off, 4096); off = off_zfs + sizeof(cl_seg_zfs_4096_t);

    size_t core_total = align_up(off, 4096);

    /* Create SHM */
    shm_unlink(CL_CORE_SHM_NAME);
    int fd = shm_open(CL_CORE_SHM_NAME, O_CREAT | O_RDWR, 0600);
    if (fd < 0) {
        printf("FAIL: shm_open(%s): errno=%d (%s)\n", CL_CORE_SHM_NAME, errno, strerror(errno));
        return 2;
    }
    if (ftruncate(fd, (off_t)core_total) != 0) {
        printf("FAIL: ftruncate core_total=%zu: errno=%d (%s)\n", core_total, errno, strerror(errno));
        close(fd);
        return 3;
    }
    void *base = mmap(NULL, core_total, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    close(fd);
    if (base == MAP_FAILED) {
        printf("FAIL: mmap core: errno=%d (%s)\n", errno, strerror(errno));
        return 4;
    }

    memset(base, 0, core_total);

    /* Root */
    cl_root_t *root = (cl_root_t*)base;
    root->abi_layout_checksum = abi_fp;

    atomic_store(&root->seq_cnt, 1u);
    atomic_store(&root->uptime_ns, 0u);

    atomic_store(&root->bulk_epoch, 0u);
    root->boot_id_ns = boot_ns;

    root->mesh_tag64 = 0;
    root->node_tag64 = 0;

    root->core_total_bytes = (uint64_t)core_total;
    root->bulk_total_bytes = 0;

    root->toc_offset = (uint64_t)toc_offset;
    root->toc_size   = (uint64_t)toc_size;

    atomic_store(&root->gates_possible, 0u);
    atomic_store(&root->gates_effective, 0u);

    root->root_magic = CL_ROOT_MAGIC_U32;
    root->schema_version = CL_SCHEMA_VERSION_U32;
    root->endian_magic = CL_ENDIAN_MAGIC_U32;

    root->root_flags = CL_ROOT_FLAG_FAILFAST_ABI | CL_ROOT_FLAG_BULK_OPTIONAL;

    atomic_store(&root->bulk_present, 0u);

    /* TOC */
    cl_toc_t *toc = (cl_toc_t*)((uint8_t*)base + toc_offset);
    toc_init(toc, (uint64_t)core_total, abi_fp);

    /* Add segments (Core) */
    (void)toc_add(toc, CL_SEG_LINK_SUMMARY, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL,
                  256, 1, (uint64_t)off_link,
                  CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_BUDGET, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL,
                  256, 1, (uint64_t)off_budget,
                  CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_MEMORY, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_DATA,
                  256, 1, (uint64_t)off_mem,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_OVERLAY, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_CONTROL,
                  256, 1, (uint64_t)off_overlay,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_WATCHDOG, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_CONTROL | CL_TOC_FLAG_FORENSICS,
                  256, 1, (uint64_t)off_watchdog,
                  CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_CPU, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA | CL_TOC_FLAG_FIXED_COUNT,
                  1024, cpu_count, (uint64_t)off_cpu,
                  CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_NIC, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA | CL_TOC_FLAG_FIXED_COUNT,
                  512, nic_count, (uint64_t)off_nic,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_PCIe, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_DATA,
                  256, 1, (uint64_t)off_pcie,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_BOARD, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_DATA,
                  512, 1, (uint64_t)off_board,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_TIMEBASE, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_WARM | CL_TOC_FLAG_CONTROL,
                  256, 1, (uint64_t)off_time,
                  CL_TOC_SOURCE_DIRECT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_MESH_NEIGHBOR, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_HOT | CL_TOC_FLAG_DATA | CL_TOC_FLAG_FIXED_COUNT,
                  256, neighbor_count, (uint64_t)off_neighbor,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE | CL_TOC_LAYOUT_ARRAY, 0, 0, 1);

    (void)toc_add(toc, CL_SEG_ZFS_SUMMARY, 1,
                  CL_TOC_FLAG_RESIDENT | CL_TOC_FLAG_OBSERVABLE | CL_TOC_FLAG_COLD | CL_TOC_FLAG_DATA,
                  4096, 1, (uint64_t)off_zfs,
                  CL_TOC_SOURCE_BEST_EFFORT, CL_TOC_ACCESS_READ | CL_TOC_ACCESS_WRITE | CL_TOC_ACCESS_ATOMIC,
                  CL_TOC_PRESENT, CL_TOC_LAYOUT_CACHELINE, 0, 0, 1);

    /* Fill segments minimal */
    cl_seg_link_256_t *link = (cl_seg_link_256_t*)((uint8_t*)base + off_link);
    memset(link, 0, sizeof(*link)); /* Link wird in Monitor ohnehin gelesen */
    /* Optional: könnte man deterministisch setzen, aber nicht nötig fürs ABI */

    cl_budget_seg_256_t *budget = (cl_budget_seg_256_t*)((uint8_t*)base + off_budget);
    memset(budget, 0, sizeof(*budget));
    fill_budget(budget);

    cl_seg_mem_256_t *mem = (cl_seg_mem_256_t*)((uint8_t*)base + off_mem);
    memset(mem, 0, sizeof(*mem));
    fill_mem(mem);

    cl_overlay_seg_256_t *ovl = (cl_overlay_seg_256_t*)((uint8_t*)base + off_overlay);
    memset(ovl, 0, sizeof(*ovl));
    fill_overlay(ovl);

    cl_watchdog_seg_256_t *wd = (cl_watchdog_seg_256_t*)((uint8_t*)base + off_watchdog);
    memset(wd, 0, sizeof(*wd));
    fill_watchdog(wd);

    /* CPU/NIC/PCIE/BOARD/TIME/MESH/ZFS werden hier bewusst nur genullt:
     * Dummy ist Testharness; der Aufbau zählt, nicht „Simulation“. */
    memset((uint8_t*)base + off_cpu, 0, cpu_count * sizeof(cl_seg_cpu_1024_t));
    memset((uint8_t*)base + off_nic, 0, nic_count * sizeof(cl_seg_nic_512_t));
    memset((uint8_t*)base + off_pcie, 0, sizeof(cl_seg_pcie_256_t));
    memset((uint8_t*)base + off_board, 0, sizeof(cl_seg_board_512_t));
    memset((uint8_t*)base + off_time, 0, sizeof(cl_seg_time_256_t));
    memset((uint8_t*)base + off_neighbor, 0, neighbor_count * sizeof(cl_seg_mesh_neighbor_256_t));
    memset((uint8_t*)base + off_zfs, 0, sizeof(cl_seg_zfs_4096_t));

    /* Fertig */
    msync(base, core_total, MS_SYNC);
    munmap(base, core_total);

    printf("OK: created CORE SHM %s size=%zu\n", CL_CORE_SHM_NAME, core_total);
    printf("    toc_offset=%zu toc_size=%zu entries=%u\n",
           toc_offset, toc_size, (unsigned)toc->header.entry_count);
    printf("    abi_fingerprint=0x%016" PRIx64 "\n", abi_fp);

    return 0;
}


<<< END FILE: ./tools/cl_dummy_shm/cl_dummy_shm.c

>>> START FILE: ./tools/cl_shm_dump/cl_shm_dump.c
/*
 * ============================================================================
 * CommanderLink – SHM Dump Tool (read-only) – FINAL Endausbau
 * Datei: tools/cl_shm_dump/cl_shm_dump.c
 * ============================================================================
 *
 * Zweck:
 *   - Read-only Dump von Core-SHM Root + TOC + Segment-Geometrie.
 *   - Keine Policy, keine Interpretation, keine Heuristik.
 *   - Zeigt die physikalische Wahrheit: Offsets/Strides/Counts/Flags/Gates.
 *
 * Plattform:
 *   - Linux / BSD / OmniOS (POSIX shm_open + mmap)
 * ============================================================================
 */

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdatomic.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include "../../include/cl_runtime/cl_runtime.h"

/* --------------------------------------------------------------------------
 * Helpers: POSIX SHM Mapping
 * -------------------------------------------------------------------------- */

static int map_shm_ro(const char *name, void **out_base, size_t *out_sz) {
    int fd = shm_open(name, O_RDONLY, 0);
    if (fd < 0) return -1;

    struct stat st;
    if (fstat(fd, &st) != 0) {
        close(fd);
        return -2;
    }
    if (st.st_size <= 0) {
        close(fd);
        return -3;
    }

    void *p = mmap(NULL, (size_t)st.st_size, PROT_READ, MAP_SHARED, fd, 0);
    close(fd);
    if (p == MAP_FAILED) return -4;

    *out_base = p;
    *out_sz = (size_t)st.st_size;
    return 0;
}

static void unmap_shm(void *base, size_t sz) {
    if (base && sz) (void)munmap(base, sz);
}

/* --------------------------------------------------------------------------
 * Helpers: Segment-Type Name
 *
 * Hinweis:
 *   Die Typ-IDs sind manifest-nahe. Die Größe (Stride) steht im TOC.
 * -------------------------------------------------------------------------- */
static const char* seg_type_name(uint32_t t) {
    switch ((cl_seg_type_t)t) {
        case CL_SEG_CPU:           return "CPU";
        case CL_SEG_MEMORY:        return "MEMORY";
        case CL_SEG_PCIe:          return "PCIe";
        case CL_SEG_BOARD:         return "BOARD";
        case CL_SEG_TIMEBASE:      return "TIMEBASE";
        case CL_SEG_BUDGET:        return "BUDGET";
        case CL_SEG_WATCHDOG:      return "WATCHDOG";
        case CL_SEG_NIC:           return "NIC";
        case CL_SEG_LINK_SUMMARY:  return "LINK_SUMMARY";
        case CL_SEG_DMA:           return "DMA";
        case CL_SEG_OVERLAY:       return "OVERLAY";
        case CL_SEG_MESH_NEIGHBOR: return "MESH_NEIGHBOR";
        case CL_SEG_MESH_PEER:     return "MESH_PEER";
        case CL_SEG_ZFS_SUMMARY:   return "ZFS_SUMMARY";
        case CL_SEG_ZFS_POOL:      return "ZFS_POOL";
        case CL_SEG_ZFS_VDEV:      return "ZFS_VDEV";
        case CL_SEG_ZFS_DATASET:   return "ZFS_DATASET";
        case CL_SEG_ZFS_ZVOL:      return "ZFS_ZVOL";
        case CL_SEG_HISTORY:       return "HISTORY";
        case CL_SEG_FORENSICS:     return "FORENSICS";
        default:                   return "UNKNOWN";
    }
}

/* --------------------------------------------------------------------------
 * Helpers: Flags pretty-print (keine Interpretation, nur Anzeige)
 * -------------------------------------------------------------------------- */
static void print_flags_u32(const char *label, uint32_t v) {
    printf("    %-14s 0x%08x\n", label, v);
}

static void print_u16_flags(const char *label, uint16_t v) {
    printf("    %-14s 0x%04x\n", label, (unsigned)v);
}

/* --------------------------------------------------------------------------
 * Dump Root
 * -------------------------------------------------------------------------- */
static int dump_root(const cl_root_t *r, size_t core_sz) {
    printf("ROOT (Core-SHM):\n");
    printf("  root_magic:      0x%08x\n", r->root_magic);
    printf("  schema_version:  0x%08x\n", r->schema_version);
    printf("  endian_magic:    0x%08x\n", r->endian_magic);
    printf("  root_flags:      0x%08x\n", r->root_flags);
    printf("  abi_checksum:    0x%016" PRIx64 "\n", (uint64_t)r->abi_layout_checksum);

    printf("  seq_cnt:         %" PRIu64 "\n", (uint64_t)atomic_load(&r->seq_cnt));
    printf("  uptime_ns:       %" PRIu64 "\n", (uint64_t)atomic_load(&r->uptime_ns));
    printf("  bulk_epoch:      %" PRIu64 "\n", (uint64_t)atomic_load(&r->bulk_epoch));
    printf("  bulk_present:    %u\n", (unsigned)atomic_load(&r->bulk_present));

    printf("  core_total:      %" PRIu64 "\n", (uint64_t)r->core_total_bytes);
    printf("  bulk_total:      %" PRIu64 "\n", (uint64_t)r->bulk_total_bytes);

    printf("  toc_offset:      %" PRIu64 "\n", (uint64_t)r->toc_offset);
    printf("  toc_size:        %" PRIu64 "\n", (uint64_t)r->toc_size);

    printf("  gates_possible:  0x%016" PRIx64 "\n", (uint64_t)atomic_load(&r->gates_possible));
    printf("  gates_effective: 0x%016" PRIx64 "\n", (uint64_t)atomic_load(&r->gates_effective));

    if (r->root_magic != CL_ROOT_MAGIC_U32) {
        printf("  FAIL: root_magic mismatch (expected 0x%08x)\n", (unsigned)CL_ROOT_MAGIC_U32);
        return 1;
    }
    if (r->endian_magic != CL_ENDIAN_MAGIC_U32) {
        printf("  FAIL: endian_magic mismatch (expected 0x%08x)\n", (unsigned)CL_ENDIAN_MAGIC_U32);
        return 2;
    }
    if (r->schema_version != CL_SCHEMA_VERSION_U32) {
        printf("  FAIL: schema_version mismatch (expected 0x%08x)\n", (unsigned)CL_SCHEMA_VERSION_U32);
        return 3;
    }
    if (r->toc_offset + r->toc_size > (uint64_t)core_sz) {
        printf("  FAIL: toc_offset/toc_size out of core mapping\n");
        return 4;
    }
    if (r->toc_size < sizeof(cl_toc_header_t)) {
        printf("  FAIL: toc_size too small\n");
        return 5;
    }
    return 0;
}

/* --------------------------------------------------------------------------
 * Dump TOC
 * -------------------------------------------------------------------------- */
static void dump_toc(const cl_toc_t *toc, uint64_t toc_size_bytes) {
    printf("\nTOC:\n");
    printf("  version:      %u\n", (unsigned)toc->header.version);
    printf("  entry_count:  %u\n", (unsigned)toc->header.entry_count);
    printf("  total_bytes:  %" PRIu64 "\n", (uint64_t)toc->header.total_bytes);
    printf("  build_id:     0x%016" PRIx64 "\n", (uint64_t)toc->header.build_id);
    printf("  epoch:        %" PRIu64 "\n", (uint64_t)toc->header.epoch);

    uint64_t need = (uint64_t)sizeof(cl_toc_header_t) +
                    (uint64_t)toc->header.entry_count * (uint64_t)sizeof(cl_toc_entry_t);

    printf("  toc_size:     %" PRIu64 "\n", toc_size_bytes);
    printf("  need_bytes:   %" PRIu64 "\n", need);

    if (toc->header.entry_count > CL_TOC_MAX_ENTRIES) {
        printf("  WARN: entry_count > CL_TOC_MAX_ENTRIES (%u)\n", (unsigned)CL_TOC_MAX_ENTRIES);
    }
    if (need > toc_size_bytes) {
        printf("  FAIL: TOC size too small for header+entries\n");
        return;
    }

    for (uint32_t i = 0; i < toc->header.entry_count && i < CL_TOC_MAX_ENTRIES; i++) {
        const cl_toc_entry_t *e = &toc->entries[i];

        const uint32_t type   = (uint32_t)e->type;
        const uint32_t flags  = (uint32_t)e->flags;
        const uint32_t stride = (uint32_t)e->stride_bytes;
        const uint32_t count  = (uint32_t)e->count;
        const uint64_t off    = (uint64_t)e->offset_bytes;

        printf("\n  SEG[%u]: %s (type=0x%04x)\n", i, seg_type_name(type), type);
        printf("    offset_bytes   %" PRIu64 "\n", off);
        printf("    stride_bytes   %u\n", stride);
        printf("    count          %u\n", count);

        print_flags_u32("flags", flags);
        print_u16_flags("source",  (uint16_t)e->source_flags);
        print_u16_flags("access",  (uint16_t)e->access_flags);
        print_u16_flags("presence",(uint16_t)e->presence_flags);
        print_u16_flags("layout",  (uint16_t)e->layout_flags);

        printf("    gates_possible 0x%016" PRIx64 "\n", (uint64_t)e->gates_possible);
        printf("    gates_effective 0x%016" PRIx64 "\n", (uint64_t)e->gates_effective);
        printf("    epoch          %" PRIu64 "\n", (uint64_t)e->epoch);
    }
}

int main(void) {
    void *core_base = NULL;
    size_t core_sz = 0;

    int rc = map_shm_ro(CL_CORE_SHM_NAME, &core_base, &core_sz);
    if (rc != 0) {
        printf("FAIL: cannot map CORE SHM (%s): rc=%d errno=%d (%s)\n",
               CL_CORE_SHM_NAME, rc, errno, strerror(errno));
        return 2;
    }

    const cl_root_t *root = (const cl_root_t*)core_base;
    int root_rc = dump_root(root, core_sz);
    if (root_rc != 0) {
        unmap_shm(core_base, core_sz);
        return 3;
    }

    const cl_toc_t *toc = (const cl_toc_t*)((const uint8_t*)core_base + (size_t)root->toc_offset);
    dump_toc(toc, (uint64_t)root->toc_size);

    unmap_shm(core_base, core_sz);
    return 0;
}


<<< END FILE: ./tools/cl_shm_dump/cl_shm_dump.c

>>> START FILE: ./tools/cl_shm_dump/README.md
# cl_shm_dump

CLI-Tool zur Prüfung des CommanderLink Core-SHM.

## Zweck
- Root lesen (Host-Order)
- TOC iterieren
- Segmentübersicht ausgeben

## Build
Wird später per Makefile-Target eingebunden.

## Lauf
- benötigt laufenden Core/Dummy-SHM, der `/cl_core_root` erstellt.


<<< END FILE: ./tools/cl_shm_dump/README.md

========================================
 PROJECT STRUCTURE TREE
========================================
.
├── .nfs.7ffe91f3.09684.4
├── .nfs.800e85df.0c9b4.4
├── .nfs.800eb7f6.0c9b4.4
├── .nfs.80574f08.1d974.4
├── .nfs.807390a5.23d94.4
├── .nfs.807dad42.25eb4.4
├── .nfs.81313032.25eb4.4
├── .nfs.81626978.533d4.4
├── .nfs.81626f5f.533d4.4
├── .nfs.817dcc22.081d4.4
├── .nfs.817ddd81.081d4.4
├── .nfs.818494ad.5aaa4.4
├── .nfs.818e88d5.5aaa4.4
├── .nfs.818ea65e.5aaa4.4
├── .nfs.819ee2b4.5aaa4.4
├── .nfs.819ef8e4.5aaa4.4
├── .nfs.819f1274.5aaa4.4
├── .nfs.81a0a8d7.61884.4
├── .nfs.81a0eb27.61884.4
├── .nfs.81a49dab.61884.4
├── .nfs.81b2cd1c.66e54.4
├── .nfs.81daded4.6f534.4
├── .nfs.81dbb6a4.6f534.4
├── .nfs.81dbfbec.6f534.4
├── .nfs.81de4be0.6f534.4
├── .nfs.81e67082.6f534.4
├── .nfs.81eb6f66.6f534.4
├── .nfs.81f60fa2.081d4.4
├── .nfs.81f62280.081d4.4
├── .nfs.81f79b50.75fb4.4
├── .nfs.81faa63c.75fb4.4
├── .nfs.81fb0cd4.75fb4.4
├── .nfs.81fdbb28.75fb4.4
├── .nfs.81fe21c7.75fb4.4
├── .nfs.823f1438.75fb4.4
├── .nfs.823f6169.75fb4.4
├── .nfs.823f9c3c.75fb4.4
├── .nfs.8241688c.75fb4.4
├── .nfs.8241a1fc.75fb4.4
├── .nfs.8241bfa8.75fb4.4
├── .nfs.8242c97a.75fb4.4
├── .nfs.8243fc24.75fb4.4
├── .nfs.824400c7.75fb4.4
├── .nfs.8255d539.75fb4.4
├── .nfs.82560a18.75fb4.4
├── .nfs.82562c91.75fb4.4
├── .nfs.82563421.75fb4.4
├── .nfs.8256f306.75fb4.4
├── .nfs.82582300.75fb4.4
├── .nfs.825830ec.75fb4.4
├── .nfs.82bd2602.081d4.4
├── .nfs.82bdb153.081d4.4
├── BUILD REQUIREMENTS.md
├── docs
│   ├── .nfs.81897eb6.63604.4
│   ├── .nfs.818a45af.63604.4
│   ├── ABI_LAYOUT.md
│   ├── ENGINEERING_RULES.md
│   ├── laws
│   │   ├── 00_PHYSICS.md
│   │   ├── ANNEX_36_SHM_ENFORCEMENT.md
│   │   ├── LAW_00_PHYSICS.md
│   │   ├── LAW_01_CPU.md
│   │   ├── LAW_02_MEMORY.md
│   │   ├── LAW_03_NETWORK.md
│   │   ├── LAW_04_TIME.md
│   │   ├── LAW_05_POWER.md
│   │   ├── LAW_06_SCHEDULING.md
│   │   ├── LAW_07_IO.md
│   │   ├── LAW_08_SECURITY.md
│   │   ├── LAW_09_MEASUREMENT.md
│   │   ├── LAW_10_FAILURE.md
│   │   ├── LAW_11_CONTROL.md
│   │   ├── LAW_12_IDENTITY.md
│   │   ├── LAW_13_STATE.md
│   │   ├── LAW_14_INTERFACE.md
│   │   ├── LAW_15_CONFIGURATION.md
│   │   ├── LAW_16_DEPLOYMENT.md
│   │   ├── LAW_17_GOVERNANCE.md
│   │   ├── LAW_18_DOCUMENTATION.md
│   │   ├── LAW_19_IMPLEMENTATION.md
│   │   ├── LAW_20_VERIFICATION.md
│   │   ├── LAW_21_SCOPE.md
│   │   ├── LAW_22_STATUS.md
│   │   ├── LAW_23_SYMBIONT.md
│   │   ├── LAW_24_READINESS.md
│   │   ├── LAW_25_CONFORMANCE.md
│   │   ├── LAW_26_LAYOUT.md
│   │   ├── LAW_27_COVERAGE.md
│   │   ├── LAW_28_STRUCTURE.md
│   │   ├── LAW_29_NAMING.md
│   │   ├── LAW_30_MANIFEST_START.md
│   │   ├── LAW_31_TERMS.md
│   │   ├── LAW_32_BASE.md
│   │   ├── LAW_33_POLICY.md
│   │   ├── LAW_34_RUNTIME_START.md
│   │   ├── LAW_35_ABI.md
│   │   ├── LAW_36_SHM.md
│   │   ├── LAW_37_RUNTIME_STATE.md
│   │   ├── LAW_38_BUDGET.md
│   │   ├── LAW_39_WIRE.md
│   │   ├── LAW_40_MONITOR.md
│   │   ├── LAW_41_TOOLING.md
│   │   └── LAW_42_FINAL.md
│   ├── MEMORY_MODEL.md
│   ├── PROJECT_GUARDRAILS.md
│   ├── SECURITY_AND_JOIN_POLICY.md
│   ├── SPEC_EXEC_CTX_64.md
│   ├── TYPES_AND_ABI.md
│   ├── WATCHDOG_AND_FORENSICS.md
│   ├── WATCHDOG.md
│   ├── ZERO_LAWS_2.md
│   └── ZERO_LAWS.md
├── include
│   ├── cl_common
│   │   ├── cl_align.h
│   │   └── cl_endian.h
│   ├── cl_core
│   ├── cl_flow
│   ├── cl_hal
│   ├── cl_link
│   ├── cl_manifest
│   │   ├── cl_enums.h
│   │   ├── cl_features.h
│   │   ├── cl_ids.h
│   │   ├── cl_join_policy.h
│   │   ├── cl_limits.h
│   │   ├── cl_link_modes.h
│   │   ├── cl_manifest.h
│   │   ├── cl_modeling_rule.h
│   │   ├── cl_oob_wire.h
│   │   ├── cl_oob.h
│   │   ├── cl_overlay.h
│   │   ├── cl_simd_policy.h
│   │   ├── cl_trust.h
│   │   ├── cl_wire_crc.h
│   │   ├── cl_wire.h
│   │   └── cl_zero_transform.h
│   ├── cl_monitor
│   │   └── cl_monitor.h
│   ├── cl_oracle
│   └── cl_runtime
│       ├── cl_gates.h
│       ├── cl_quality.h
│       ├── cl_runtime.h
│       ├── cl_schema.h
│       ├── cl_seg_board_512.h
│       ├── cl_seg_budget_256.h
│       ├── cl_seg_cpu_1024.h
│       ├── cl_seg_dma_4096.h
│       ├── cl_seg_forensics_4096.h
│       ├── cl_seg_history_4096.h
│       ├── cl_seg_link_256.h
│       ├── cl_seg_mem_256.h
│       ├── cl_seg_mesh_neighbor_256.h
│       ├── cl_seg_mesh_peer_256.h
│       ├── cl_seg_nic_512.h
│       ├── cl_seg_oracle_256.h
│       ├── cl_seg_overlay_256.h
│       ├── cl_seg_pcie_256.h
│       ├── cl_seg_time_256.h
│       ├── cl_seg_watchdog_256.h
│       ├── cl_seg_zfs_4096.h
│       ├── cl_service_seg_256.h
│       ├── cl_shm_layout.h
│       └── cl_toc.h
├── Makefile
├── README.md
├── single_dump.sh
├── src
│   ├── clboot
│   │   └── clboot.c
│   ├── cld
│   │   └── cld.c
│   ├── clinit
│   │   └── clinit.c
│   ├── core
│   │   └── core0.c
│   ├── flow
│   │   └── flow0.c
│   ├── hal
│   │   └── hal0.c
│   ├── link
│   │   └── link0.c
│   ├── monitor
│   │   ├── .nfs.8180f1a2.5aaa4.4
│   │   ├── .nfs.818142e8.5aaa4.4
│   │   ├── .nfs.8182daea.5aaa4.4
│   │   ├── .nfs.81870104.5aaa4.4
│   │   ├── .nfs.81876a53.5aaa4.4
│   │   ├── .nfs.8187d662.5aaa4.4
│   │   ├── .nfs.8187fa1d.5aaa4.4
│   │   ├── .nfs.8188f583.5aaa4.4
│   │   ├── .nfs.81895f53.5aaa4.4
│   │   ├── .nfs.8189ddaa.5aaa4.4
│   │   ├── .nfs.818cfa69.5aaa4.4
│   │   ├── .nfs.818d2fcc.5aaa4.4
│   │   ├── .nfs.818d72b1.5aaa4.4
│   │   ├── .nfs.818dc014.5aaa4.4
│   │   ├── .nfs.818e1f1d.5aaa4.4
│   │   ├── .nfs.8190a368.5aaa4.4
│   │   ├── .nfs.8197ae7d.5aaa4.4
│   │   ├── .nfs.8197e4da.5aaa4.4
│   │   ├── .nfs.819d3e2f.5aaa4.4
│   │   ├── .nfs.819db378.5aaa4.4
│   │   ├── .nfs.81d5f1a7.69804.4
│   │   ├── .nfs.81d702e1.69804.4
│   │   ├── .nfs.81f6b82b.75fb4.4
│   │   ├── .nfs.81f7161b.75fb4.4
│   │   ├── .nfs.81f7495c.75fb4.4
│   │   ├── monitor_curses.h
│   │   ├── monitor_input.c
│   │   ├── monitor_input.h
│   │   ├── monitor_shm.c
│   │   ├── monitor_shm.h
│   │   ├── monitor_state.c
│   │   ├── monitor_state.h
│   │   ├── monitor_ui.c
│   │   ├── monitor_ui.h
│   │   ├── monitor.c
│   │   ├── tabs
│   │   │   └── tab_dashboard.c
│   │   └── tabs.h
│   ├── oracle
│   │   └── oracle0.c
│   └── wire
└── tools
    ├── cl_abi_report
    │   ├── cl_abi_report.c
    │   └── README.md
    ├── cl_dummy_shm
    │   └── cl_dummy_shm.c
    └── cl_shm_dump
        ├── cl_shm_dump.c
        └── README.md

29 directories, 207 files
