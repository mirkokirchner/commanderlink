
>>> START FILE: ./cl_gates.h
#pragma once
/* ============================================================================
 * CommanderLink – Globale Gates (Systemzustände & physikalische Schranken)
 *
 * Datei:        include/cl_runtime/cl_gates.h
 *
 * Beschreibung:
 *   Dieses Header definiert die globalen Gates von CommanderLink.
 *
 *   Gates sind KEINE Policy.
 *   Gates sind KEINE Heuristik.
 *   Gates sind KEINE Entscheidung.
 *
 *   Gates sind die materialisierte physikalische Realität des Systems:
 *     - thermische Grenzen
 *     - elektrische Grenzen (VRM/Power)
 *     - Budget- und Interaktivitätszwänge
 *     - Sicherheits- und Trust-Zustände
 *
 *   Alle Runtime-Segmente referenzieren diese Gates.
 *   Kein Segment darf eigene Gate-Semantik erfinden.
 *
 *   Architektur:
 *     - x86_64, little-endian Host
 *     - 64-bit Gate-Masken
 *     - atomar lesbar/schreibbar
 *
 *   WICHTIG:
 *     Dieses Header enthält bewusst KEINE Logik.
 *     Auswertung, Reaktion und Policy liegen außerhalb.
 * ========================================================================== */

#ifndef CL_GATES_H
#define CL_GATES_H

#include <stdint.h>

/* --------------------------------------------------------------------------
 * Architekturannahmen (explizit)
 * -------------------------------------------------------------------------- */
#if !defined(__x86_64__) && !defined(_M_X64)
#error "CommanderLink ist x86_64-first. cl_gates.h setzt x86_64 voraus."
#endif

/* --------------------------------------------------------------------------
 * Gate-Typen: Grundsätzliches Modell
 *
 * - Gates werden als Bitmasken in uint64_t geführt.
 * - Mehrere Gates können gleichzeitig aktiv sein.
 * - Gates sind rein deskriptiv.
 *
 * Begriffe:
 *   possible  : physikalisch / logisch möglich
 *   effective : aktuell wirksam (nach allen Überlagerungen)
 *
 * Beispiel:
 *   AVX-512 possible, aber wegen Thermal-Gate nicht effective.
 * -------------------------------------------------------------------------- */

/* --------------------------------------------------------------------------
 * Gate-Klassen (logische Gruppierung, KEINE Bitwerte)
 * -------------------------------------------------------------------------- */
typedef enum cl_gate_class {
    CL_GATE_CLASS_THERMAL = 0,   /* Temperatur / thermische Limits        */
    CL_GATE_CLASS_POWER,        /* Strom, VRM, Package Power             */
    CL_GATE_CLASS_BUDGET,       /* Zeit-/CPU-/IO-Budget                  */
    CL_GATE_CLASS_INTERACTIVE,  /* Nutzer-Interaktivität                 */
    CL_GATE_CLASS_TRUST,        /* Join / Trust / Security               */
    CL_GATE_CLASS_PLATFORM,     /* Plattform- / Umgebungsrestriktionen   */
    CL_GATE_CLASS_INTERNAL      /* interne Schutzmechanismen             */
} cl_gate_class_t;

/* --------------------------------------------------------------------------
 * Gate-Bits (physikalische Zustände)
 *
 * Bitlayout:
 *   - Niedrige Bits: harte physikalische Schranken
 *   - Mittlere Bits: weiche / adaptive Schranken
 *   - Hohe Bits: logische / sicherheitsrelevante Zustände
 * -------------------------------------------------------------------------- */
typedef uint64_t cl_gate_mask_t;

/* --- Thermische Gates ----------------------------------------------------- */
#define CL_GATE_THERMAL_SOFT        (1ULL << 0)   /* Temperatur hoch, Drossel empfohlen */
#define CL_GATE_THERMAL_HARD        (1ULL << 1)   /* Temperatur kritisch, Drossel Pflicht */

/* --- Power / VRM Gates ---------------------------------------------------- */
#define CL_GATE_POWER_SOFT          (1ULL << 2)   /* Power Budget angespannt             */
#define CL_GATE_POWER_HARD          (1ULL << 3)   /* Power Budget überschritten          */
#define CL_GATE_VRM_LIMIT           (1ULL << 4)   /* VRM meldet Limit / Instabilität     */

/* --- Budget Gates --------------------------------------------------------- */
#define CL_GATE_BUDGET_EXCEEDED     (1ULL << 5)   /* Laufzeit-Budget überschritten       */
#define CL_GATE_BUDGET_RECLAIM      (1ULL << 6)   /* Reclaim aktiv (Bulk freigegeben)    */

/* --- Interaktivität ------------------------------------------------------- */
#define CL_GATE_INTERACTIVE_ACTIVE  (1ULL << 7)   /* Nutzer-/Systeminteraktivität aktiv  */

/* --- Trust / Security ----------------------------------------------------- */
#define CL_GATE_TRUST_NONE          (1ULL << 16)  /* kein Trust (Default-Deny)           */
#define CL_GATE_TRUST_ESTABLISHED   (1ULL << 17)  /* Trust ausgehandelt                  */
#define CL_GATE_TRUST_ACTIVE        (1ULL << 18)  /* Trust aktiv, Data Plane erlaubt     */

#define CL_GATE_SECURITY_DEGRADED   (1ULL << 19)  /* Security nicht voll gewährleistet   */

/* --- Plattform / Umgebung ------------------------------------------------ */
#define CL_GATE_PLATFORM_VM         (1ULL << 24)  /* Ausführung in VM                    */
#define CL_GATE_PLATFORM_LIMITED    (1ULL << 25)  /* reduzierte Telemetrie / Caps        */

/* --- Interne Schutzmechanismen ------------------------------------------- */
#define CL_GATE_WATCHDOG_TRIGGERED  (1ULL << 32)  /* Watchdog hat ausgelöst              */
#define CL_GATE_INTERNAL_ERROR      (1ULL << 33)  /* interner Inkonsistenzschutz         */

/* --------------------------------------------------------------------------
 * Gate-Masken (Zusammenfassungen)
 * -------------------------------------------------------------------------- */

/* Alle Gates, die harte Drosselung erzwingen */
#define CL_GATE_MASK_HARD_LIMITS ( \
    CL_GATE_THERMAL_HARD      |   \
    CL_GATE_POWER_HARD        |   \
    CL_GATE_VRM_LIMIT         |   \
    CL_GATE_WATCHDOG_TRIGGERED )

/* Gates, die Interaktivität schützen */
#define CL_GATE_MASK_INTERACTIVE ( \
    CL_GATE_INTERACTIVE_ACTIVE |  \
    CL_GATE_BUDGET_RECLAIM )

/* Gates, die Data Plane grundsätzlich verbieten */
#define CL_GATE_MASK_NO_DATAPLANE ( \
    CL_GATE_TRUST_NONE        |    \
    CL_GATE_SECURITY_DEGRADED |    \
    CL_GATE_WATCHDOG_TRIGGERED )

/* --------------------------------------------------------------------------
 * Gate-Zustandscontainer
 *
 * Wird in Segmenten verwendet, um possible/effective sauber zu trennen.
 * Größe: 16 Byte (2 × u64), cacheline-neutral.
 * -------------------------------------------------------------------------- */
typedef struct cl_gate_state {
    cl_gate_mask_t possible;   /* was physikalisch / logisch möglich ist */
    cl_gate_mask_t effective;  /* was aktuell wirksam ist                */
} cl_gate_state_t;

_Static_assert(sizeof(cl_gate_state_t) == 16,
               "cl_gate_state_t muss exakt 16 Byte groß sein");

/* --------------------------------------------------------------------------
 * Semantik-Hinweise (KEIN Code!)
 *
 * - possible darf nur erweitert werden, niemals implizit eingeschränkt.
 * - effective ist das Ergebnis aller aktuell aktiven Gates.
 * - Kein Modul darf Gates „wegdiskutieren“.
 * - Monitor zeigt possible vs effective explizit getrennt an.
 * -------------------------------------------------------------------------- */

#endif /* CL_GATES_H */


<<< END FILE: ./cl_gates.h

>>> START FILE: ./cl_identity_seg_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Identity (256B, resident) – FINAL SSOT
 * Datei: include/cl_runtime/cl_identity_seg_256.h
 * ============================================================================
 *
 * SSOT-Vertrag:
 *   - Identity liefert ausschließlich cld (Persistenz: identity.bin + CRC32C).
 *   - CORE ist Authority über identity_state (VALID/INVALID/QUARANTINED).
 *   - HAL/LINK/FLOW/MONITOR erzeugen keine IDs und schreiben keine identity.bin.
 *
 * Root enthält KEINE IDs (NodeTag/MeshTag).
 * IDs sind Segment-Wahrheit (Identity-Segment).
 *
 * Layout:
 *   256B = 4 Cachelines à 64B
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_ids.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* Identity State (P0) */
typedef enum cl_identity_state {
    CL_IDENTITY_UNINITIALIZED = 0,
    CL_IDENTITY_VALID         = 1,
    CL_IDENTITY_MISSING       = 2,
    CL_IDENTITY_INVALID       = 3,
    CL_IDENTITY_QUARANTINED   = 4
} cl_identity_state_t;

/* CL0 (HOT 64): aktuelle Identity-Wahrheit */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) identity_epoch;     /* bump bei jedem valid publish */

        _Atomic(uint32_t) identity_state;     /* cl_identity_state_t */
        _Atomic(uint32_t) reason_code;        /* P0 reason code (SSOT reason order) */

        cl_node_tag64_t node_tag64;           /* 0 wenn nicht VALID */
        cl_mesh_tag64_t mesh_tag64;           /* 0 wenn nicht VALID */

        _Atomic(uint32_t) flags;              /* identity flags (z.B. domain-join später) */
        _Atomic(uint32_t) reserved0;

        uint8_t src;                          /* SOURCE (DIRECT/BEST_EFFORT/...) */
        uint8_t qual;                         /* QUALITY */
        uint16_t reserved1;

        uint32_t reserved2;
    };
    uint8_t raw[64];
} cl_identity_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_identity_hot_64_t) == 64, "identity hot 64");

/* CL1 (WARM 64): Persistenz-/Forensik-Meta (rein beschreibend) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) file_epoch;         /* bump wenn identity.bin neu geschrieben */
        _Atomic(uint64_t) created_time_ns;    /* aus identity.bin (optional) */

        _Atomic(uint32_t) crc32c_ok;          /* 1 wenn CRC ok, sonst 0 */
        _Atomic(uint32_t) reserved0;

        _Atomic(uint64_t) last_load_ns;       /* wann cld zuletzt geladen hat */
        _Atomic(uint64_t) last_write_ns;      /* wann cld zuletzt geschrieben hat */
    };
    uint8_t raw[64];
} cl_identity_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_identity_warm_64_t) == 64, "identity warm 64");

/* CL2 (COLD 64): Salt-Hash (nur SSOT Sicht; keine Rohdatenexfiltration) */
typedef union CL_ALIGNAS(8) {
    struct {
        uint64_t salt_hash64;                 /* Hash(node_salt[32]) – optional */
        uint64_t fp_hash64;                   /* Hash(hw_fingerprint) – optional */
        uint64_t reserved0;
        uint64_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_identity_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_identity_cold_64_t) == 64, "identity cold 64");

/* CL3 (RSV 64): Reserve */
typedef union CL_ALIGNAS(8) {
    struct { uint64_t r[8]; };
    uint8_t raw[64];
} cl_identity_rsv_64_t;

CL_STATIC_ASSERT(sizeof(cl_identity_rsv_64_t) == 64, "identity rsv 64");

/* Segment 256 */
typedef struct CL_ALIGNAS(256) cl_identity_seg_256 {
    cl_identity_hot_64_t  hot;
    cl_identity_warm_64_t warm;
    cl_identity_cold_64_t cold;
    cl_identity_rsv_64_t  rsv;
} cl_identity_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_identity_seg_256_t) == 256, "identity seg 256");


<<< END FILE: ./cl_identity_seg_256.h

>>> START FILE: ./cl_quality.h
#pragma once
/* ============================================================================
 * CommanderLink – Source/Quality (Runtime) – FINAL
 * Datei: include/cl_runtime/cl_quality.h
 * ============================================================================
 *
 * Zweck:
 *   - Herkunft und Güte von Telemetrie (Maximalmodell).
 *   - Monitor zeigt Source/Quality lückenlos.
 *   - Oracle/Flow entscheiden anhand Quality, ob Werte kontrollwirksam sind.
 * ============================================================================
 */

#include <stdint.h>

typedef enum {
    CL_SRC_UNSPECIFIED = 0,
    CL_SRC_DIRECT_HW   = 1,
    CL_SRC_OS_IFACE    = 2,
    CL_SRC_TOOL        = 3,
    CL_SRC_INFERRED    = 4,
    CL_SRC_SIMULATED   = 5
} cl_source_t;

typedef enum {
    CL_QUAL_UNSUPPORTED = 0,
    CL_QUAL_ESTIMATED   = 1,
    CL_QUAL_BEST_EFFORT = 2,
    CL_QUAL_DIRECT      = 3
} cl_quality_t;

static inline int cl_quality_control_ok(cl_quality_t q) {
    return (q == CL_QUAL_DIRECT) || (q == CL_QUAL_BEST_EFFORT);
}


<<< END FILE: ./cl_quality.h

>>> START FILE: ./cl_runtime.h
#pragma once
/* ============================================================================
 * CommanderLink – Runtime Frontdoor
 * Datei: include/cl_runtime/cl_runtime.h
 * ============================================================================
 *
 * Zweck:
 *   Diese Datei ist die EINZIGE offizielle Eintrittsstelle in die
 *   CommanderLink Runtime-Wahrheit.
 *
 *   Wer dieses Header includiert, erklärt:
 *     - ich lese Laufzeit-Zustand (SHM)
 *     - ich erwarte keine Policy
 *     - ich erwarte keine Logik
 *
 *   Die Runtime beschreibt:
 *     - WAS zur Laufzeit existiert
 *     - WIE es physikalisch im Speicher liegt
 *     - WIE es beobachtet werden darf
 *
 *   Die Runtime beschreibt NICHT:
 *     - WANN etwas geschieht
 *     - WARUM etwas entschieden wird
 *     - WIE Initialisierung erfolgt
 *
 *   Architektur:
 *     - x86_64 first
 *     - Host-Endianness
 *     - Cacheline-exakt
 *     - ABI-stabil
 *
 *   Plattformen:
 *     - Linux
 *     - FreeBSD / GhostBSD
 *     - OmniOS / illumos
 *
 *   KEINE Policy. KEINE Heuristik. KEINE Logik.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

/* --------------------------------------------------------------------------
 * 1) Fundamentale Runtime-Typen (ohne Abhängigkeiten)
 * -------------------------------------------------------------------------- */

/* Gates = physikalische Schranken */
#include "cl_gates.h"

/* Beobachtungsqualität / Quelle */
#include "cl_quality.h"

/* --------------------------------------------------------------------------
 * 2) Manifest-nahe Definitionen (symbolische Wahrheit)
 * -------------------------------------------------------------------------- */

/* Enums & IDs (reine Zustandskodierung) */
#include "../cl_manifest/cl_enums.h"
#include "../cl_manifest/cl_ids.h"

/* --------------------------------------------------------------------------
 * 3) Runtime-Ordnung & Verkabelung
 * -------------------------------------------------------------------------- */

/* Table of Contents (physikalische SHM-Struktur) */
#include "cl_toc.h"

/* SHM-Layout & Speicherklassen */
#include "cl_shm_layout.h"

/* Runtime-Schema (Pflicht / Optional / Feature-gebunden) */
#include "cl_schema.h"
#include "cl_identity_seg_256.h"

/* BOOTEN VON CL */
#include "cl_service_seg_256.h"

/* --------------------------------------------------------------------------
 * 4) Runtime-Segmente (SHM-Wahrheit)
 * -------------------------------------------------------------------------- */

/* Kernsegmente - INVENTAR */
#include "cl_seg_cpu_1024.h"
#include "cl_seg_budget_256.h"
#include "cl_seg_mem_256.h"
#include "cl_seg_time_256.h"
#include "cl_seg_board_512.h"

/* Netzwerk / Transfer */
#include "cl_seg_nic_512.h"
#include "cl_seg_link_256.h"
#include "cl_seg_overlay_256.h"
#include "cl_seg_mesh_neighbor_256.h"
#include "cl_seg_mesh_peer_256.h"
#include "cl_seg_dma_4096.h"
#include "cl_seg_flow_cmd_256.h"

/* System / Stabilität */
#include "cl_seg_watchdog_256.h"
#include "cl_seg_pcie_256.h"

/* Storage */
#include "cl_seg_zfs_4096.h"

/* Analyse / Langzeit */
#include "cl_seg_oracle_256.h"
#include "cl_seg_history_4096.h"
#include "cl_seg_forensics_4096.h"

/* Datenpaket */


/* --------------------------------------------------------------------------
 * 5) Runtime-Meta (rein beschreibend)
 * -------------------------------------------------------------------------- */

/*
 * cl_runtime_caps_t beschreibt, welche Teile der Runtime
 * in einer konkreten Instanz existieren KÖNNEN.
 *
 * Dies ist KEINE Initialisierung, KEINE Policy, KEINE Logik.
 * Es ist eine deklarative Zusammenfassung für:
 *   - Monitor
 *   - Tools
 *   - Minimal-Boot
 */
typedef struct cl_runtime_caps {

    /* Grundlegende Verfügbarkeit */
    uint8_t has_cpu;
    uint8_t has_memory;
    uint8_t has_budget;

    /* Netzwerk */
    uint8_t has_nic;
    uint8_t has_mesh;
    uint8_t has_dma;

    /* Storage */
    uint8_t has_zfs;

    /* Analyse */
    uint8_t has_oracle;
    uint8_t has_history;
    uint8_t has_forensics;

} cl_runtime_caps_t;

/*
 * Hinweis:
 *   cl_runtime_caps_t wird NICHT von der Runtime gesetzt.
 *   Es ist eine deklarative Beschreibung dessen,
 *   was prinzipiell Teil der Runtime sein kann.
 */



<<< END FILE: ./cl_runtime.h

>>> START FILE: ./cl_schema.h
#pragma once
/* ============================================================================
 * CommanderLink – Schema/ABI Contract (Runtime) – FINAL
 * Datei: include/cl_runtime/cl_schema.h
 * ============================================================================
 *
 * Zweck:
 *   - Einmalige, zentrale Definition der Runtime-Schema-Version.
 *   - Endianness Magic (Host sanity).
 *   - Page-Größe/Alignment (Root-Page).
 *
 * Maschinenregel:
 *   - SHM ist Host-Order.
 *   - endian_magic muss beim Attach geprüft werden.
 *   - Schema bump nur bei semantisch relevanten Layout-Änderungen.
 * ============================================================================
 */

#include <stdint.h>

#define CL_SCHEMA_VERSION_U32  0x00000111u
#define CL_ENDIAN_MAGIC_U32    0x12345678u
#define CL_SHM_PAGE_BYTES      4096u

#define CL_ABI_CHECKSUM_NONE   0ull



<<< END FILE: ./cl_schema.h

>>> START FILE: ./cl_seg_board_512.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Board/VRM/Power (512B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_board_512.h
 * ============================================================================
 *
 * Maximalmodell:
 * - Board/VRM/Power sind Safety Cutoff Inputs, nicht Hot-Pacing Inputs.
 * - Alle Werte haben state/source/quality.
 * - Hersteller/Name/Serial ist in COLD enthalten (Monitor-Anforderung).
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT A 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) board_therm_state; /* cl_thermal_state_t */
        _Atomic(uint32_t) board_cap_flags;   /* constraint bits (VRM/POWER/THERM) */

        _Atomic(uint32_t) vrm_temp_c_x10;
        _Atomic(uint32_t) pch_temp_c_x10;

        _Atomic(uint32_t) pwr_package_mw;
        _Atomic(uint32_t) pwr_limit_mw;

        _Atomic(uint32_t) vrm_ripple_mv_x10;
        _Atomic(uint32_t) power_unstable;    /* 0/1 */

        _Atomic(uint64_t) last_update_ns;
    };
    uint8_t raw[64];
} cl_board_hot_64a_t;

CL_STATIC_ASSERT(sizeof(cl_board_hot_64a_t) == 64, "board hot a 64");

/* HOT B 64 (smoothed outputs + events) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) vrm_temp_avg_c_x10;
        _Atomic(uint32_t) pwr_pkg_avg_mw;
        _Atomic(uint32_t) ripple_avg_mv_x10;
        _Atomic(uint32_t) vrm_trend_permille;

        _Atomic(uint64_t) cap_events_total;
        _Atomic(uint64_t) power_events_total;
        _Atomic(uint64_t) thermal_events_total;

        uint64_t reserved0;
    };
    uint8_t raw[64];
} cl_board_hot_64b_t;

CL_STATIC_ASSERT(sizeof(cl_board_hot_64b_t) == 64, "board hot b 64");

/* WARM A 64 (fans/rails) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) fan_rpm_0;
        _Atomic(uint32_t) fan_rpm_1;
        _Atomic(uint32_t) fan_rpm_2;
        _Atomic(uint32_t) fan_rpm_3;

        _Atomic(uint32_t) v12_mv;
        _Atomic(uint32_t) v5_mv;

        _Atomic(uint32_t) vrm_supported;
        _Atomic(uint32_t) ripple_supported;

        uint64_t reserved0;
    };
    uint8_t raw[64];
} cl_board_warm_64a_t;

CL_STATIC_ASSERT(sizeof(cl_board_warm_64a_t) == 64, "board warm a 64");

/* WARM B 64 (feature states) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint16_t) vrm_state;     /* cl_feature_state_t */
        _Atomic(uint16_t) ripple_state;  /* cl_feature_state_t */
        _Atomic(uint16_t) pwr_state;     /* cl_feature_state_t */
        _Atomic(uint16_t) therm_state;   /* cl_feature_state_t */

        _Atomic(uint32_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
        _Atomic(uint64_t) reserved4;
    };
    uint8_t raw[64];
} cl_board_warm_64b_t;

CL_STATIC_ASSERT(sizeof(cl_board_warm_64b_t) == 64, "board warm b 64");

/* COLD 64 (Inventory strings: vendor/model/serial) */
typedef union CL_ALIGNAS(8) {
    struct {
        char vendor[16];
        char model[16];
        char serial[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;

        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_board_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_board_cold_64_t) == 64, "board cold 64");

/* RSV lines */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_board_rsv_64_t;

typedef struct CL_ALIGNAS(512) {
    cl_board_hot_64a_t  hot_a;
    cl_board_hot_64b_t  hot_b;
    cl_board_warm_64a_t warm_a;
    cl_board_warm_64b_t warm_b;
    cl_board_cold_64_t  cold;
    cl_board_rsv_64_t   rsv0;
    cl_board_rsv_64_t   rsv1;
    cl_board_rsv_64_t   rsv2;
} cl_board_seg_512_t;

CL_STATIC_ASSERT(sizeof(cl_board_seg_512_t) == 512, "board seg 512");


<<< END FILE: ./cl_seg_board_512.h

>>> START FILE: ./cl_seg_budget_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Budget (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_budget_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - zeigt verfügbares RAM, staging caps, pressure, reclaim events
 * - zeigt, ob CL gerade aggressiv Ressourcen nutzt oder zurückzieht
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) budget_state;          /* cl_budget_state_t */
        _Atomic(uint32_t) interactive_hint;      /* 0/1 */

        _Atomic(uint32_t) cpu_pressure_permille; /* 0..1000 */
        _Atomic(uint32_t) mem_pressure_permille; /* 0..1000 */

        _Atomic(uint64_t) total_ram_bytes;       /* best-effort */
        _Atomic(uint64_t) free_ram_bytes;        /* best-effort */

        _Atomic(uint64_t) bulk_bytes_current;
        _Atomic(uint64_t) bulk_bytes_cap;
    };
    uint8_t raw[64];
} cl_budget_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_budget_hot_64_t) == 64, "budget hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) reclaim_events;
        _Atomic(uint64_t) shadow_events;
        _Atomic(uint64_t) user_activity_events;

        _Atomic(uint64_t) mem_reclaim_ns;

        _Atomic(uint32_t) io_pressure_permille;  /* best-effort */
        _Atomic(uint32_t) storage_pressure_permille; /* disk sink/backlog */

        _Atomic(uint64_t) last_pressure_ts_ns;
        _Atomic(uint64_t) reserved0;
    };
    uint8_t raw[64];
} cl_budget_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_budget_warm_64_t) == 64, "budget warm 64");

/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;

        uint32_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
        uint64_t reserved6;
    };
    uint8_t raw[64];
} cl_budget_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_budget_cold_64_t) == 64, "budget cold 64");

/* RSV 64 (append-only space) */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_budget_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_budget_hot_64_t  hot;
    cl_budget_warm_64_t warm;
    cl_budget_cold_64_t cold;
    cl_budget_rsv_64_t  rsv;
} cl_budget_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_budget_seg_256_t) == 256, "budget seg 256");


<<< END FILE: ./cl_seg_budget_256.h

>>> START FILE: ./cl_seg_cpu_1024.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: CPU Core (1024B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_cpu_1024.h
 * ============================================================================
 *
 * Record = 16 Cachelines à 64B.
 * Maximalmodell:
 * - ISA possible/effective/state
 * - Thermik/Throttle/Headroom (state+reason)
 * - Hersteller/Modell/µcode (COLD strings)
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "../cl_manifest/cl_features.h"
#include "cl_quality.h"

/* HOT 0 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) tsc_val;
        _Atomic(uint64_t) last_update_ns;

        _Atomic(uint32_t) local_seq;
        _Atomic(uint32_t) load_permille;

        _Atomic(uint32_t) temp_c_x10;
        _Atomic(uint32_t) throttling;       /* 0/1 */

        _Atomic(uint32_t) headroom_permille;/* best-effort */
        _Atomic(uint32_t) reason_code;      /* cl_reason_code_t */

        _Atomic(uint32_t) constraint_flags; /* thermal/power/budget */
        _Atomic(uint32_t) reserved0;
    };
    uint8_t raw[64];
} cl_cpu_hot_64a_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_hot_64a_t)==64, "cpu hot 64a");

/* HOT 1 (ISA) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) isa_possible_mask;  /* cl_cpu_isa_mask_t */
        _Atomic(uint32_t) isa_effective;      /* cl_cpu_isa_effective_t */

        _Atomic(uint16_t) isa_state;          /* cl_feature_state_t */
        _Atomic(uint16_t) avx512_risk;        /* cl_avx512_risk_t (manifest) */
        _Atomic(uint16_t) simd_effective;     /* cl_simd_effective_t (manifest) */
        _Atomic(uint16_t) reserved0;

        _Atomic(uint64_t) inst_retired;
        _Atomic(uint64_t) cycles;

        _Atomic(uint64_t) uops_issued;
        _Atomic(uint64_t) uops_stalled;
    };
    uint8_t raw[64];
} cl_cpu_hot_64b_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_hot_64b_t)==64, "cpu hot 64b");

/* WARM lines 2..7 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) l1d_misses;
        _Atomic(uint64_t) itlb_misses;
        _Atomic(uint64_t) dtlb_misses;
        _Atomic(uint64_t) llc_misses;

        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
    };
    uint8_t raw[64];
} cl_cpu_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_warm_64_t)==64, "cpu warm 64");

/* COLD 8 (IDs) */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t vendor_id;
        uint32_t device_id;
        uint32_t model_id;
        uint32_t stepping;

        uint32_t numa_node;
        uint32_t reserved0;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
        uint32_t reserved2;

        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_cpu_cold_64a_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_cold_64a_t)==64, "cpu cold 64a");

/* COLD 9 (strings vendor/model) Teil 1*/
typedef union CL_ALIGNAS(8) {
    struct {
        char vendor_str[16];   /* "GenuineIntel" etc */
        char model_str_a[16];  /* Modelname Teil A */
        char model_str_b[16];  /* Modelname Teil B */

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_cpu_cold_64b_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_cold_64b_t)==64, "cpu cold 64b");

/* COLD 10 (strings) TEIL 2 */
typedef union CL_ALIGNAS(8) {
    struct {
        char model_str_c[32];  /* Modelname Teil C (weitere 32 Zeichen) */
        char ucode_str[16];    /* Microcode/Revision kurz */
        
        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_cpu_cold_64c_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_cold_64c_t)==64, "cpu cold 64c");

/* COLD 11..15 reserved/topology */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_cpu_cold_64r_t;
CL_STATIC_ASSERT(sizeof(cl_cpu_cold_64r_t)==64, "cpu cold r 64");

/* Record 1024 */
typedef struct CL_ALIGNAS(1024) {
    cl_cpu_hot_64a_t hot_a;           /* 0 */
    cl_cpu_hot_64b_t hot_b;           /* 1 */
    cl_cpu_warm_64_t warm[6];         /* 2..7 */
    cl_cpu_cold_64a_t cold_a;         /* 8 */
    cl_cpu_cold_64b_t cold_b;         /* 9 */
    cl_cpu_cold_64c_t cold_c;         /* 9 */
    cl_cpu_cold_64r_t cold_r[5];      /* 11..15 */
} cl_cpu_seg_1024_t;

CL_STATIC_ASSERT(sizeof(cl_cpu_seg_1024_t)==1024, "cpu seg 1024");


<<< END FILE: ./cl_seg_cpu_1024.h

>>> START FILE: ./cl_seg_dma_4096.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: DMA Meta (4096B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_dma_4096.h
 * ============================================================================
 *
 * Zweck:
 *   - RX/TX Ring Meta, Slot Meta; Payload liegt backend-spezifisch außerhalb SHM.
 *
 * Maximalmodell:
 *   - alignment/headroom/atom geometry sichtbar
 *   - crc/fec counters sichtbar
 *
 * Layout:
 *   4096B = 64 Cachelines:
 *     RX hdr: 4 lines (256B)
 *     TX hdr: 4 lines (256B)
 *     Slot meta: 56 lines
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* Slot state */
typedef enum { CL_DMA_SLOT_FREE=0, CL_DMA_SLOT_BUSY=1, CL_DMA_SLOT_READY=2 } cl_dma_slot_state_t;

/* Ring header line 64B */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) ring_size;
        _Atomic(uint32_t) ring_mask;
        _Atomic(uint32_t) head;
        _Atomic(uint32_t) tail;

        _Atomic(uint64_t) slots_ready;
        _Atomic(uint64_t) slots_busy;

        _Atomic(uint32_t) alignment_bytes;     /* expected 64 */
        _Atomic(uint32_t) headroom_bytes;      /* expected 64 */

        _Atomic(uint32_t) payload_quantum_bytes; /* 64 */
        _Atomic(uint32_t) reserved0;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
        uint32_t reserved2;
    };
    uint8_t raw[64];
} cl_dma_ring_hdr_64_t;

CL_STATIC_ASSERT(sizeof(cl_dma_ring_hdr_64_t)==64, "dma ring hdr 64");

/* Slot meta line 64B */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) seq;
        _Atomic(uint64_t) ts_ns;
        _Atomic(uint64_t) opaque_ref64;  /* UMEM offset / netmap token / ptr */
        _Atomic(uint64_t) reserved0;

        _Atomic(uint32_t) state;         /* cl_dma_slot_state_t */
        _Atomic(uint32_t) payload_len;

        _Atomic(uint32_t) crc32c;        /* optional: per-slot/atom CRC summary */
        _Atomic(uint32_t) reserved1;

        _Atomic(uint64_t) reserved2;
    };
    uint8_t raw[64];
} cl_dma_slot_meta_64_t;

CL_STATIC_ASSERT(sizeof(cl_dma_slot_meta_64_t)==64, "dma slot meta 64");

/* Segment 4096 */
typedef struct CL_ALIGNAS(4096) {
    cl_dma_ring_hdr_64_t rx_hdr[4];
    cl_dma_ring_hdr_64_t tx_hdr[4];
    cl_dma_slot_meta_64_t slot[56];
} cl_dma_seg_4096_t;

CL_STATIC_ASSERT(sizeof(cl_dma_seg_4096_t)==4096, "dma seg 4096");


<<< END FILE: ./cl_seg_dma_4096.h

>>> START FILE: ./cl_seg_flow_cmd_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: FLOW Command/Intent (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_flow_cmd_256.h
 *
 * Zweck:
 *   SSOT-Kanal FLOW → LINK. Definiert Autopacing/Credits-Policy (nicht Reality).
 *
 * Writer: FLOW
 * Reader: LINK (Apply-Cut-Point), Monitor (read-only)
 *
 * Commit:
 *   - FLOW schreibt Felder, dann cmd_version++ (Release).
 *   - LINK liest stable cmd_version (Acquire).
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) cmd_version;           /* commit marker */
        _Atomic(uint32_t) cmd_reason_mask;       /* why clamp/scale (bitmask, extend-only) */

        _Atomic(uint64_t) send_rate_target_bps;  /* policy */
        _Atomic(uint64_t) pacing_quantum_ns;     /* policy */

        _Atomic(uint64_t) max_inflight_bytes;    /* POLICY credits cap */
        _Atomic(uint64_t) burst_cap_bytes;       /* bounded burst */

        _Atomic(uint32_t) stream_count;          /* multistream */
        _Atomic(uint32_t) stream_policy;         /* enum */

        _Atomic(uint32_t) backend_intent;        /* cl_backend_active_t (prefer) */
        _Atomic(uint32_t) mtu_intent;            /* 1500/4096/9000 */

        _Atomic(uint32_t) compression_rung;      /* LZ4 ladder */
        _Atomic(uint32_t) integrity_rung;        /* CRC/FEC ladder */
    };
    uint8_t raw[64];
} cl_flow_cmd_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_flow_cmd_hot_64_t) == 64, "flow cmd hot 64");

typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_flow_cmd_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_flow_cmd_hot_64_t hot;
    cl_flow_cmd_rsv_64_t rsv1;
    cl_flow_cmd_rsv_64_t rsv2;
    cl_flow_cmd_rsv_64_t rsv3;
} cl_flow_cmd_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_flow_cmd_seg_256_t) == 256, "flow cmd seg 256");


<<< END FILE: ./cl_seg_flow_cmd_256.h

>>> START FILE: ./cl_seg_forensics_4096.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Forensics (4096B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_forensics_4096.h
 * ============================================================================
 *
 * Zweck:
 *   - Ringbuffer seltener, hochrelevanter Events.
 *   - Maximalmodell: commit_epoch + grant_id + reason/constraints immer dabei.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* Forensics Event IDs (append-only) */
typedef enum {
    CL_FX_NONE = 0,

    /* Discovery / Join */
    CL_FX_BEACON_SEEN = 100,
    CL_FX_HELLO_SENT = 101,
    CL_FX_HELLO_ACK_RX = 102,
    CL_FX_AUTH_FAIL = 110,
    CL_FX_REPLAY_DETECTED = 111,
    CL_FX_VERSION_MISMATCH = 112,
    CL_FX_MESH_MISMATCH = 113,
    CL_FX_IP_COLLISION = 114,
    CL_FX_TRUSTED_ACTIVE = 120,
    CL_FX_DENIED = 121,

    /* Grants / Credits */
    CL_FX_GRANT_RX = 200,
    CL_FX_GRANT_EXPIRED = 201,
    CL_FX_CREDIT_STARVATION = 202,

    /* Autopath */
    CL_FX_BACKEND_UPGRADE = 300,
    CL_FX_BACKEND_DOWNGRADE = 301,
    CL_FX_TCP_FALLBACK = 302
} cl_forensics_event_id_t;

/* Event 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) ts_ns;
        _Atomic(uint64_t) commit_epoch;
        _Atomic(uint64_t) grant_id;
        _Atomic(uint64_t) param1;

        _Atomic(uint32_t) event_id;
        _Atomic(uint32_t) reason_code;

        _Atomic(uint32_t) constraint_flags;
        _Atomic(uint32_t) aux;

        _Atomic(uint64_t) param2;
        _Atomic(uint64_t) param3;
    };
    uint8_t raw[64];
} cl_forensics_event_64_t;

CL_STATIC_ASSERT(sizeof(cl_forensics_event_64_t)==64, "forensics event 64");

/* Header 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) head;
        _Atomic(uint32_t) tail;
        _Atomic(uint32_t) mask;      /* 63 */
        _Atomic(uint32_t) dropped;

        _Atomic(uint64_t) last_event_ns;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;

        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
    };
    uint8_t raw[64];
} cl_forensics_hdr_64_t;

CL_STATIC_ASSERT(sizeof(cl_forensics_hdr_64_t)==64, "forensics hdr 64");

typedef struct CL_ALIGNAS(4096) {
    cl_forensics_hdr_64_t hdr;
    cl_forensics_event_64_t ev[63];
} cl_forensics_seg_4096_t;

CL_STATIC_ASSERT(sizeof(cl_forensics_seg_4096_t)==4096, "forensics seg 4096");


<<< END FILE: ./cl_seg_forensics_4096.h

>>> START FILE: ./cl_seg_history_4096.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: History (4096B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_history_4096.h
 * ============================================================================
 *
 * Zweck:
 *   - Oracle Trenddaten (eine Metrik pro Segmentinstanz).
 *   - Maximalmodell: Trends werden als Werte+Quelle/Qualität abgebildet.
 *
 * Layout:
 *   Header 64B + 63 Points à 64B.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "cl_quality.h"

/* Metric IDs (extend-only) */
typedef enum {
    CL_HIST_TX_BPS = 1,
    CL_HIST_RX_BPS = 2,
    CL_HIST_LOSS_PPM = 3,
    CL_HIST_JITTER_P99_US = 4,
    CL_HIST_CPU_PRESSURE = 5,
    CL_HIST_MEM_PRESSURE = 6,
    CL_HIST_STORAGE_SINK = 7,
    CL_HIST_THERMAL = 8
} cl_hist_metric_id_t;

/* Header 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) metric_id;
        _Atomic(uint32_t) write_idx;
        _Atomic(uint32_t) count;
        _Atomic(uint32_t) reserved0;

        _Atomic(uint64_t) last_ts_ns;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
        uint32_t reserved2;

        uint64_t reserved3;
        uint64_t reserved4;
    };
    uint8_t raw[64];
} cl_hist_hdr_64_t;

CL_STATIC_ASSERT(sizeof(cl_hist_hdr_64_t)==64, "hist hdr 64");

/* Point 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) ts_ns;
        _Atomic(uint64_t) value;
        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
        _Atomic(uint64_t) reserved4;
        _Atomic(uint64_t) reserved5;
    };
    uint8_t raw[64];
} cl_hist_point_64_t;

CL_STATIC_ASSERT(sizeof(cl_hist_point_64_t)==64, "hist point 64");

typedef struct CL_ALIGNAS(4096) {
    cl_hist_hdr_64_t hdr;
    cl_hist_point_64_t pts[63];
} cl_history_seg_4096_t;

CL_STATIC_ASSERT(sizeof(cl_history_seg_4096_t)==4096, "history seg 4096");


<<< END FILE: ./cl_seg_history_4096.h

>>> START FILE: ./cl_seg_link_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Link Summary (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_link_256.h
 * ============================================================================
 *
 * Record = 4 Cachelines à 64B:
 *   HOT   : effektiver Pfad/Backend/Mode/Profile + pacing/tick/mtu/batch + reasons
 *   WARM A: commit epochs + throughput totals + starvation + partials
 *   WARM B: Zero-Transform Geometrie + Accept + FEC/CRC/PHV + Compression + States
 *   COLD  : desired targets (policy) + src/qual
 *
 * Maximalmodell:
 *   - possible/effective/state für Integrity (CRC/FEC) und Zero-Transform
 *   - keine impliziten Defaults
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) path_state;
        _Atomic(uint32_t) backend_active;
        _Atomic(uint32_t) backend_detail;
        _Atomic(uint32_t) profile_effective;

        _Atomic(uint32_t) mode_active;
        _Atomic(uint32_t) constraint_flags;
        _Atomic(uint32_t) reason_code;
        _Atomic(uint32_t) global_health;

        /* NEW: Apply / Redirect audit */
        _Atomic(uint32_t) rule_set_version;      /* monotonic */
        _Atomic(uint32_t) last_redirect_reason;  /* cl_reason_code_t (P0–P3) */
        _Atomic(uint64_t) apply_epoch;           /* monotonic ns or epoch */

        /* NEW: Credits reality */
        _Atomic(uint64_t) tx_inflight_bytes;         /* real inflight */
        _Atomic(uint32_t) tx_queue_pressure_permille;/* 0..1000 */
        _Atomic(uint32_t) reserved0;

        _Atomic(uint16_t) mtu_effective;
        _Atomic(uint16_t) batch_target;

        _Atomic(uint32_t) batch_eff_permille;
    };
    uint8_t raw[64];
} cl_link_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_link_hot_64_t) == 64, "link hot 64");

/* WARM A 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_commit_epoch;

        _Atomic(uint64_t) bytes_sent_1s;
        _Atomic(uint64_t) pkts_sent_1s;

        _Atomic(uint64_t) bytes_sent_total;
        _Atomic(uint64_t) pkts_sent_total;

        _Atomic(uint64_t) inject_partial_cnt;
        _Atomic(uint64_t) prepare_expired_cnt;
        _Atomic(uint64_t) credit_starvation_ns;
    };
    uint8_t raw[64];
} cl_link_warm_64a_t;

CL_STATIC_ASSERT(sizeof(cl_link_warm_64a_t) == 64, "link warm a 64");

/* WARM B 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        /* Zero-Transform / Atom-Geometry (Truth) */
        _Atomic(uint32_t) payload_quantum_bytes;   /* default 64 */
        _Atomic(uint32_t) payload_headroom_bytes;  /* negotiated/setup */

        /* Transfer Semantik */
        _Atomic(uint32_t) accept_mode;             /* cl_accept_mode_t */
        _Atomic(uint32_t) durable_granularity_bytes;

        /* Integrity: possible/effective/state */
        _Atomic(uint32_t) crc_mode_possible;       /* bitmask over cl_crc_mode_t */
        _Atomic(uint32_t) fec_mode_possible;       /* bitmask over cl_fec_mode_t */

        _Atomic(uint32_t) crc_mode_effective;      /* cl_crc_mode_t */
        _Atomic(uint32_t) fec_mode_effective;      /* cl_fec_mode_t */

        /* FEC parameters */
        _Atomic(uint16_t) fec_n;                   /* atoms per block */
        _Atomic(uint16_t) fec_k;                   /* parity atoms */
        _Atomic(uint16_t) crc_state;               /* cl_feature_state_t (fits u16) */
        _Atomic(uint16_t) fec_state;               /* cl_feature_state_t */

        /* Predict-Verify Gate state (optional) */
        _Atomic(uint16_t) phv_state;               /* cl_feature_state_t */
        uint16_t reserved0;

        /* Compression ladder (effective) */
        _Atomic(uint32_t) comp_mode;               /* cl_comp_mode_t */
    };
    uint8_t raw[64];
} cl_link_warm_64b_t;

CL_STATIC_ASSERT(sizeof(cl_link_warm_64b_t) == 64, "link warm b 64");

/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t profile_desired;
        uint32_t backend_desired;
        uint32_t mode_desired;
        uint32_t reserved0;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;

        uint32_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_link_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_link_cold_64_t) == 64, "link cold 64");

typedef struct CL_ALIGNAS(256) {
    cl_link_hot_64_t   hot;
    cl_link_warm_64a_t warm_a;
    cl_link_warm_64b_t warm_b;
    cl_link_cold_64_t  cold;
} cl_link_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_link_seg_256_t) == 256, "link seg 256");


<<< END FILE: ./cl_seg_link_256.h

>>> START FILE: ./cl_seg_mem_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Memory (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_mem_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - total/free/used/ecc
 * - memory bandwidth hints (best-effort)
 * - DIMM mode strings optional via reserved/bulk later
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) total_bytes;
        _Atomic(uint64_t) used_bytes;
        _Atomic(uint64_t) free_bytes;
        _Atomic(uint64_t) ecc_err_cnt;

        _Atomic(uint32_t) pressure_permille;
        _Atomic(uint32_t) reason_code;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
    };
    uint8_t raw[64];
} cl_mem_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_mem_hot_64_t)==64, "mem hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) bw_read_bps;
        _Atomic(uint64_t) bw_write_bps;

        _Atomic(uint32_t) timing_tcl;
        _Atomic(uint32_t) timing_trcd;
        _Atomic(uint32_t) timing_trp;
        _Atomic(uint32_t) timing_tras;

        _Atomic(uint32_t) channel_state; /* cl_feature_state_t */
        _Atomic(uint32_t) reserved0;

        _Atomic(uint64_t) last_update_ns;
    };
    uint8_t raw[64];
} cl_mem_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_mem_warm_64_t)==64, "mem warm 64");

/* COLD 64 (inventory strings) */
typedef union CL_ALIGNAS(8) {
    struct {
        char dimm_mode[16];    /* "DDR4-2133" / "XMP" etc best-effort */
        char channel_mode[16]; /* "DUAL" "SINGLE" etc */
        char reserved_str[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;

        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_mem_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_mem_cold_64_t)==64, "mem cold 64");

/* RSV 64 */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_mem_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_mem_hot_64_t  hot;
    cl_mem_warm_64_t warm;
    cl_mem_cold_64_t cold;
    cl_mem_rsv_64_t  rsv;
} cl_mem_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_mem_seg_256_t)==256, "mem seg 256");


<<< END FILE: ./cl_seg_mem_256.h

>>> START FILE: ./cl_seg_mesh_neighbor_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Mesh Neighbor HOT (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_mesh_neighbor_256.h
 * ============================================================================
 *
 * 32 Hot Neighbor Records (CL_MESH_HOT_NEIGHBORS) sind Ziel.
 * Maximalmodell: trust/state/negotiated/why + source/quality.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "../cl_manifest/cl_ids.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_seen_ns;

        _Atomic(uint32_t) trust_state;     /* cl_peer_trust_state_t */
        _Atomic(uint32_t) peer_state;      /* cl_peer_state_t */

        uint32_t peer_overlay_ip;
        uint32_t mtu_negotiated;

        uint32_t backend_active;           /* cl_backend_active_t */
        uint32_t profile_effective;        /* cl_transfer_profile_t */

        uint32_t loss_ppm;
        uint32_t jitter_p99_us;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
    };
    uint8_t raw[64];
} cl_mesh_neighbor_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_neighbor_hot_64_t) == 64, "mesh neighbor hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t ports_count;
        uint32_t link_speed_mbps;
        uint64_t rx_window_bytes;
        uint64_t drain_bps;

        uint32_t constraint_flags;
        uint32_t reason_code;

        uint16_t payload_quantum_bytes;
        uint16_t payload_headroom_bytes;
        uint16_t fec_n;
        uint16_t fec_k;

        uint32_t crc_mode_effective;
        uint32_t fec_mode_effective;
    };
    uint8_t raw[64];
} cl_mesh_neighbor_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_neighbor_warm_64_t) == 64, "mesh neighbor warm 64");

/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        cl_node_tag64_t node_tag64;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;

        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_mesh_neighbor_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_neighbor_cold_64_t) == 64, "mesh neighbor cold 64");

/* RSV 64 */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_mesh_neighbor_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_mesh_neighbor_hot_64_t  hot;
    cl_mesh_neighbor_warm_64_t warm;
    cl_mesh_neighbor_cold_64_t cold;
    cl_mesh_neighbor_rsv_64_t  rsv;
} cl_mesh_neighbor_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_neighbor_seg_256_t) == 256, "mesh neighbor seg 256");


<<< END FILE: ./cl_seg_mesh_neighbor_256.h

>>> START FILE: ./cl_seg_mesh_peer_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Mesh Peer (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_mesh_peer_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - Trust (state + last_event + denied_reason)
 * - Negotiation (geometry + integrity)
 * - Credits (pkts/bytes) + durable progress
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "../cl_manifest/cl_ids.h"
#include "../cl_manifest/cl_trust.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_seen_ns;
        _Atomic(uint64_t) last_oob_rx_ns;

        _Atomic(uint32_t) trust_state;       /* cl_peer_trust_state_t */
        _Atomic(uint32_t) peer_state;        /* cl_peer_state_t */

        _Atomic(uint32_t) peer_overlay_ip;
        _Atomic(uint32_t) route_state;       /* cl_overlay_route_state_t (numeric) */

        _Atomic(uint32_t) constraint_flags;
        _Atomic(uint32_t) reason_code;

        _Atomic(uint32_t) trust_last_event;   /* cl_trust_event_id_t */
        _Atomic(uint32_t) trust_denied_reason;/* cl_reason_code_t subset */

        uint64_t reserved0;
    };
    uint8_t raw[64];
} cl_mesh_peer_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_hot_64_t) == 64, "mesh peer hot 64");

/* WARM A 64 (negotiated) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) rx_window_bytes;
        _Atomic(uint64_t) drain_bps;

        _Atomic(uint32_t) mtu_negotiated;
        _Atomic(uint32_t) ports_count;

        _Atomic(uint32_t) profile_allowed_mask;
        _Atomic(uint32_t) backend_allowed_mask;

        _Atomic(uint32_t) payload_quantum_bytes;
        _Atomic(uint32_t) payload_headroom_bytes;
    };
    uint8_t raw[64];
} cl_mesh_peer_warm_64a_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_warm_64a_t) == 64, "mesh peer warm a 64");

/* WARM B 64 (credits + accept/integrity progress) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) grant_id;
        _Atomic(uint64_t) refill_epoch;

        _Atomic(uint32_t) grant_ttl_ms;
        _Atomic(uint32_t) grant_age_ms;

        _Atomic(uint64_t) credits_pkts;
        _Atomic(uint64_t) credits_bytes;

        _Atomic(uint32_t) accept_mode;        /* cl_accept_mode_t */
        _Atomic(uint32_t) durable_lag_bytes;

        _Atomic(uint64_t) durable_commit_epoch;
        _Atomic(uint64_t) reserved0;
    };
    uint8_t raw[64];
} cl_mesh_peer_warm_64b_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_warm_64b_t) == 64, "mesh peer warm b 64");

/* WARM C 64 (Join/Replay/Rate-Limit – gedämpft, monitor-sichtbar) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) last_oob_epoch_seen;  /* lower 32 bits of last accepted epoch */
        _Atomic(uint32_t) replay_hits_total;

        _Atomic(uint32_t) join_attempts_total;
        _Atomic(uint32_t) join_rejects_total;

        _Atomic(uint32_t) rate_limited_total;
        _Atomic(uint32_t) reserved0;

        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
        _Atomic(uint64_t) reserved4;
        _Atomic(uint64_t) reserved5;
    };
    uint8_t raw[64];
} cl_mesh_peer_warm_64c_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_warm_64c_t) == 64, "mesh peer warm c 64");


/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        cl_mesh_tag64_t mesh_tag64;
        cl_node_tag64_t node_tag64;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;

        uint64_t reserved2;
        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_mesh_peer_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_cold_64_t) == 64, "mesh peer cold 64");

typedef struct CL_ALIGNAS(256) {
    cl_mesh_peer_hot_64_t   hot;
    cl_mesh_peer_warm_64a_t warm_a;
    cl_mesh_peer_warm_64b_t warm_b;
    cl_mesh_peer_cold_64_t  cold;
} cl_mesh_peer_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_mesh_peer_seg_256_t) == 256, "mesh peer seg 256");


<<< END FILE: ./cl_seg_mesh_peer_256.h

>>> START FILE: ./cl_seg_nic_512.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: NIC (512B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_nic_512.h
 * ============================================================================
 *
 * Record = 8 Cachelines.
 * Maximalmodell:
 * - Ports/Queues/Caps possible/effective/state
 * - DOM/SFP inventory strings (vendor/part/serial) + thresholds
 * - Loss/Jitter/Burst + reasons
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) rx_bps;
        _Atomic(uint64_t) tx_bps;

        _Atomic(uint32_t) local_seq;
        _Atomic(uint32_t) link_speed_mbps;

        _Atomic(uint16_t) mtu_effective;
        _Atomic(uint16_t) mtu_max;
        _Atomic(uint16_t) mtu_min;
        _Atomic(uint16_t) ports_count;

        _Atomic(uint32_t) queues_count;
        _Atomic(uint32_t) reason_code;

        _Atomic(uint32_t) constraint_flags;
        _Atomic(uint32_t) reserved0;
    };
    uint8_t raw[64];
} cl_nic_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_nic_hot_64_t)==64, "nic hot 64");

/* WARM A 64 (queues/drops) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) rx_queue_fill_permille;
        _Atomic(uint32_t) tx_queue_fill_permille;
        _Atomic(uint32_t) rx_dropped;
        _Atomic(uint32_t) tx_dropped;
        _Atomic(uint32_t) rx_overruns;
        _Atomic(uint32_t) tx_overruns;
        _Atomic(uint32_t) reorder_events;
        _Atomic(uint32_t) burst_max;          /* max consecutive losses (warm) */

        _Atomic(uint32_t) crc_fail_1s;        /* atoms/packets */
        _Atomic(uint32_t) crc_fail_total;

        _Atomic(uint32_t) fec_recover_1s;
        _Atomic(uint32_t) fec_recover_total;
    };
    uint8_t raw[64];
} cl_nic_warm_64a_t;

CL_STATIC_ASSERT(sizeof(cl_nic_warm_64a_t)==64, "nic warm a 64");

/* WARM B 64 (DOM/thermal) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) dom_temp_c_x10;
        _Atomic(uint32_t) dom_warn_c_x10;
        _Atomic(uint32_t) dom_crit_c_x10;
        _Atomic(uint32_t) dom_alarm_bits;

        _Atomic(uint32_t) thermal_state;        /* cl_thermal_state_t */
        _Atomic(uint32_t) pacing_scale_permille;/* 1000/950/700/0 */

        _Atomic(uint16_t) dom_state;            /* cl_feature_state_t */
        _Atomic(uint16_t) reserved0;
        _Atomic(uint32_t) reserved1;

        _Atomic(uint32_t) loss_ppm;
        _Atomic(uint32_t) jitter_p99_us;
    };
    uint8_t raw[64];
} cl_nic_warm_64b_t;

CL_STATIC_ASSERT(sizeof(cl_nic_warm_64b_t)==64, "nic warm b 64");

/* WARM C 64 (aggregation + backend/profile) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) group_id;
        _Atomic(uint32_t) active_ports_mask;

        _Atomic(uint32_t) backend_state;
        _Atomic(uint32_t) backend_active;

        _Atomic(uint32_t) profile_effective;
        _Atomic(uint32_t) constraint_flags;

        _Atomic(uint32_t) reason_code;
        _Atomic(uint32_t) reserved0;

        _Atomic(uint64_t) link_down_events;
        _Atomic(uint64_t) mtu_reneg_events;
    };
    uint8_t raw[64];
} cl_nic_warm_64c_t;

CL_STATIC_ASSERT(sizeof(cl_nic_warm_64c_t)==64, "nic warm c 64");

/* COLD A 64 (PCI identity + names) */
typedef union CL_ALIGNAS(8) {
    struct {
        uint16_t pci_vendor_id;
        uint16_t pci_device_id;
        uint16_t pci_domain;
        uint16_t reserved0;

        uint8_t pci_bus;
        uint8_t pci_dev;
        uint8_t pci_func;
        uint8_t reserved1;

        char iface_name[16];
        char driver_name[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved2;

        uint32_t reserved3;
        uint64_t reserved4;
    };
    uint8_t raw[64];
} cl_nic_cold_64a_t;

CL_STATIC_ASSERT(sizeof(cl_nic_cold_64a_t)==64, "nic cold a 64");

/* COLD B 64 (caps/state) */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) caps_zerocopy;
        _Atomic(uint32_t) caps_rdma;

        _Atomic(uint16_t) bypass_state;   /* cl_feature_state_t */
        _Atomic(uint16_t) rdma_state;     /* cl_feature_state_t */
        _Atomic(uint16_t) rss_state;      /* cl_feature_state_t */
        _Atomic(uint16_t) flow_dir_state; /* cl_feature_state_t */

        _Atomic(uint32_t) backend_possible_mask; /* bitmask cl_backend_active_t */
        _Atomic(uint32_t) reserved0;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;

        uint32_t reserved2;
        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_nic_cold_64b_t;

CL_STATIC_ASSERT(sizeof(cl_nic_cold_64b_t)==64, "nic cold b 64");

/* COLD C 64 (SFP strings) */
typedef union CL_ALIGNAS(8) {
    struct {
        char sfp_vendor[16];
        char sfp_part[16];
        char sfp_serial[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;

        uint32_t reserved1;
        uint64_t reserved2;
    };
    uint8_t raw[64];
} cl_nic_cold_64c_t;

CL_STATIC_ASSERT(sizeof(cl_nic_cold_64c_t)==64, "nic cold c 64");

/* Record 512 */
typedef struct CL_ALIGNAS(512) {
    cl_nic_hot_64_t    hot;
    cl_nic_warm_64a_t  warm_a;
    cl_nic_warm_64b_t  warm_b;
    cl_nic_warm_64c_t  warm_c;
    cl_nic_cold_64a_t  cold_a;
    cl_nic_cold_64b_t  cold_b;
    cl_nic_cold_64c_t  cold_c;
    /* reserved line for future */
    uint8_t            rsv[64];
} cl_nic_seg_512_t;

CL_STATIC_ASSERT(sizeof(cl_nic_seg_512_t)==512, "nic seg 512");


<<< END FILE: ./cl_seg_nic_512.h

>>> START FILE: ./cl_seg_oracle_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Oracle Suggest (256B) – FINAL (Oracle Mode)
 * Datei: include/cl_runtime/cl_seg_oracle_256.h
 * ============================================================================
 *
 * SSOT:
 * - ORACLE ist optional (Mode).
 * - ORACLE schreibt keine Wahrheit, keine Gates, keine Redirects.
 * - ORACLE liefert ausschließlich Hints/Clamps + Top-5 Reasons (P4/P5).
 * - Abwesenheit: oracle_epoch==0 => OFF.
 *
 * Writer: ORACLE
 * Readers: Monitor (immer), CORE/FLOW (nur Hint an Cut-Points)
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64: state + freshness + confidence */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) oracle_epoch;      /* 0 => OFF */
        _Atomic(uint32_t) oracle_age_ms;     /* Anzeige: time since last update */

        _Atomic(uint8_t)  oracle_quality;   /* cl_quality_t */
        _Atomic(uint8_t)  oracle_confidence;/* 0..100 */
        uint8_t reserved0[2];

        _Atomic(uint32_t) suggest_mask;     /* bitmask: thermal/loss/mtu/budget... */

        /* bounded ceilings (never authority) */
        _Atomic(uint32_t) max_streams;      /* ceiling */
        _Atomic(uint32_t) max_lz4_rung;     /* ceiling */
        _Atomic(uint32_t) max_fec_rung;     /* ceiling */
        _Atomic(uint32_t) max_send_rate_frac_permille; /* 0..1000 */

        _Atomic(uint32_t) defer_mtu_probe;  /* 0/1 */
        _Atomic(uint32_t) reserved1;
    };
    uint8_t raw[64];
} cl_oracle_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_oracle_hot_64_t) == 64, "oracle hot 64");

/* WARM 128: Top-5 reasons + quantized scores */
typedef union CL_ALIGNAS(8) {
    struct {
        /* Top-5 reasons (P4/P5 only), strongest first */
        _Atomic(uint32_t) reason_code[5];
        _Atomic(uint16_t) reason_strength[5]; /* 0..65535 */
        uint16_t reserved0;

        /* Quantized scores for display (optional) */
        _Atomic(int16_t) thermal_slope_q8;       /* e.g. C/min * 256 */
        _Atomic(uint16_t) loss_burst_score;      /* 0..65535 */
        _Atomic(uint16_t) peer_jitter_score;     /* 0..65535 */
        _Atomic(uint16_t) budget_pressure_score; /* 0..65535 */

        _Atomic(uint16_t) reserved1;
        _Atomic(uint32_t) reserved2;
        _Atomic(uint64_t) reserved3;
        _Atomic(uint64_t) reserved4;
        _Atomic(uint64_t) reserved5;
        _Atomic(uint64_t) reserved6;
        _Atomic(uint64_t) reserved7;
    };
    uint8_t raw[128];
} cl_oracle_warm_128_t;

CL_STATIC_ASSERT(sizeof(cl_oracle_warm_128_t) == 128, "oracle warm 128");

/* COLD 64: caps (immutable after genesis) */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t oracle_tick_ms;     /* suggestion update interval */
        uint32_t reserved0;

        uint32_t backend_allowed_mask_u32;
        uint32_t comp_allowed_mask_u32;
        uint32_t crc_allowed_mask_u32;
        uint32_t fec_allowed_mask_u32;

        uint64_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_oracle_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_oracle_cold_64_t) == 64, "oracle cold 64");

/* SEG 256 */
typedef union CL_ALIGNAS(64) {
    struct {
        cl_oracle_hot_64_t  hot;
        cl_oracle_warm_128_t warm;
        cl_oracle_cold_64_t cold;
    };
    uint8_t raw[256];
} cl_oracle_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_oracle_seg_256_t) == 256, "oracle seg 256");


<<< END FILE: ./cl_seg_oracle_256.h

>>> START FILE: ./cl_seg_overlay_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Overlay (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_overlay_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - Overlay ist Truth für Monitor: IP, ifname, prefix, state, routes, collision.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) overlay_state;     /* cl_feature_state_t */
        _Atomic(uint32_t) route_state;       /* cl_feature_state_t (global) */

        _Atomic(uint32_t) overlay_ip_host_u32;
        _Atomic(uint32_t) prefixlen;

        _Atomic(uint32_t) mtu_effective;
        _Atomic(uint32_t) active_routes;

        _Atomic(uint32_t) collision_offset;
        _Atomic(uint32_t) failopen_events;

        _Atomic(uint64_t) last_update_ns;
    };
    uint8_t raw[64];
} cl_overlay_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_overlay_hot_64_t) == 64, "overlay hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) routes_added_total;
        _Atomic(uint32_t) routes_removed_total;
        _Atomic(uint32_t) orphan_routes_total;
        _Atomic(uint32_t) collision_events_total;

        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
    };
    uint8_t raw[64];
} cl_overlay_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_overlay_warm_64_t) == 64, "overlay warm 64");

/* COLD 64 (if name) */
typedef union CL_ALIGNAS(8) {
    struct {
        char if_name[16];

        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;

        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_overlay_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_overlay_cold_64_t) == 64, "overlay cold 64");

typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_overlay_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_overlay_hot_64_t  hot;
    cl_overlay_warm_64_t warm;
    cl_overlay_cold_64_t cold;
    cl_overlay_rsv_64_t  rsv;
} cl_overlay_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_overlay_seg_256_t) == 256, "overlay seg 256");


<<< END FILE: ./cl_seg_overlay_256.h

>>> START FILE: ./cl_seg_pcie_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: PCIe Summary (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_pcie_256.h
 * ============================================================================
 *
 * Maximalmodell:
 * - throughput + error counters
 * - vendor/device + human label (best-effort)
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) tx_bps;
        _Atomic(uint64_t) rx_bps;

        _Atomic(uint32_t) lcrc_err;
        _Atomic(uint32_t) tlp_retry;

        _Atomic(uint32_t) reason_code;
        _Atomic(uint32_t) constraint_flags;

        _Atomic(uint64_t) last_update_ns;
    };
    uint8_t raw[64];
} cl_pcie_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_pcie_hot_64_t)==64, "pcie hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) eye_margin_db_x100;
        _Atomic(uint32_t) lane_state; /* cl_feature_state_t */
        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;
        _Atomic(uint64_t) reserved2;
        _Atomic(uint64_t) reserved3;
        _Atomic(uint64_t) reserved4;
        _Atomic(uint64_t) reserved5;
    };
    uint8_t raw[64];
} cl_pcie_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_pcie_warm_64_t)==64, "pcie warm 64");

/* COLD 64 (IDs + name) */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t vendor_id;
        uint32_t device_id;

        uint16_t domain;
        uint8_t bus;
        uint8_t dev;
        uint8_t func;
        uint8_t reserved0[3];

        char name[32]; /* best-effort short label */

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
    };
    uint8_t raw[64];
} cl_pcie_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_pcie_cold_64_t)==64, "pcie cold 64");

/* RSV 64 */
typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_pcie_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_pcie_hot_64_t  hot;
    cl_pcie_warm_64_t warm;
    cl_pcie_cold_64_t cold;
    cl_pcie_rsv_64_t  rsv;
} cl_pcie_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_pcie_seg_256_t)==256, "pcie seg 256");


<<< END FILE: ./cl_seg_pcie_256.h

>>> START FILE: ./cl_seg_time_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Timebase (256B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_time_256.h
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "cl_quality.h"

/* HOT 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) mono_now_ns;
        _Atomic(uint64_t) wall_now_ns;
        _Atomic(uint64_t) boot_id_ns;
        uint64_t reserved0;
        uint64_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
    };
    uint8_t raw[64];
} cl_time_hot_64_t;

CL_STATIC_ASSERT(sizeof(cl_time_hot_64_t) == 64, "time hot 64");

/* WARM 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(int64_t)  clock_offset_ns;
        _Atomic(uint32_t) time_quality_ppb;
        uint32_t reserved0;
        uint64_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_time_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_time_warm_64_t) == 64, "time warm 64");

/* COLD 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint8_t src;
        uint8_t qual;
        uint16_t reserved0;
        uint32_t reserved1;
        uint64_t reserved2;
        uint64_t reserved3;
        uint64_t reserved4;
        uint64_t reserved5;
    };
    uint8_t raw[64];
} cl_time_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_time_cold_64_t) == 64, "time cold 64");

typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_time_rsv_64_t;

typedef struct CL_ALIGNAS(256) {
    cl_time_hot_64_t  hot;
    cl_time_warm_64_t warm;
    cl_time_cold_64_t cold;
    cl_time_rsv_64_t  rsv;
} cl_time_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_time_seg_256_t) == 256, "time seg 256");


<<< END FILE: ./cl_seg_time_256.h

>>> START FILE: ./cl_seg_watchdog_256.h
#pragma once
/*
 * ============================================================================
 * CommanderLink – WATCHDOG Segment (256B)
 * Datei: include/cl_runtime/cl_seg_watchdog_256.h
 * ============================================================================
 *
 * ZWECK
 *   - Selbstheilung: erkennt Stall/Panic und löst CL-Restart aus.
 *   - OS bleibt stabil (Fail-open): non-persistent Overlay, keine Default-Route.
 *
 * PHYSIK / ABI
 *   - Segment ist exakt 256B.
 *   - 4 Cacheline-Normflächen (64B) -> HOT_A, HOT_B, WARM, COLD.
 *   - Keine packed-Strukturen im SHM.
 *
 * OWNERSHIP
 *   - Writer: CORE aggregiert Zustände; Module schreiben nur ihre Tickmarker.
 *   - Reader: Monitor2 / Oracle.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "cl_quality.h"

/* -------------------------------------------------------------------------- */
/* Module IDs (für Stall/Restart Reason) – append-only                         */
/* -------------------------------------------------------------------------- */
typedef enum {
    CL_WD_MOD_NONE   = 0,
    CL_WD_MOD_HAL    = 1,
    CL_WD_MOD_CORE   = 2,
    CL_WD_MOD_FLOW   = 3,
    CL_WD_MOD_LINK   = 4,
    CL_WD_MOD_ORACLE = 5
} cl_wd_module_t;

/* -------------------------------------------------------------------------- */
/* Watchdog State                                                             */
/* -------------------------------------------------------------------------- */
typedef enum {
    CL_WD_OK    = 0,
    CL_WD_WARN  = 1,
    CL_WD_STALL = 2,
    CL_WD_PANIC = 3
} cl_wd_state_t;

/* -------------------------------------------------------------------------- */
/* Watchdog Reason Codes (append-only)                                        */
/* -------------------------------------------------------------------------- */
typedef enum {
    CL_WD_R_NONE = 0,

    /* Zeitbasierter Stall */
    CL_WD_R_STALL_HAL,
    CL_WD_R_STALL_CORE,
    CL_WD_R_STALL_FLOW,
    CL_WD_R_STALL_LINK,
    CL_WD_R_STALL_ORACLE,

    /* Integritäts-/Konsistenzverletzung (harte Gründe) */
    CL_WD_R_EPOCH_REGRESSION,
    CL_WD_R_GRANT_REPLAY,
    CL_WD_R_CREDITS_NEGATIVE,
    CL_WD_R_BACKEND_PANIC,
    CL_WD_R_INVARIANT_BREACH
} cl_wd_reason_t;

/* ============================================================================
 * HOT_A 64B: Liveness Marker (letztes Lebenszeichen je Modul)
 * ============================================================================
 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) hal_tick_ns;
        _Atomic(uint64_t) core_tick_ns;
        _Atomic(uint64_t) flow_tick_ns;
        _Atomic(uint64_t) link_tick_ns;
        _Atomic(uint64_t) oracle_tick_ns;

        uint8_t  src;
        uint8_t  qual;
        uint16_t reserved0;
        uint32_t reserved1;
    };
    uint8_t raw[64];
} cl_wd_hot_64a_t;

CL_STATIC_ASSERT(sizeof(cl_wd_hot_64a_t) == 64, "watchdog hot_a 64");

/* ============================================================================
 * HOT_B 64B: Progress Marker (Fortschritt, nicht nur Liveness)
 * ============================================================================
 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_progress_ns;      /* monotonic ns */
        _Atomic(uint64_t) last_commit_epoch;     /* Link commit epoch */
        _Atomic(uint64_t) last_root_seq_cnt;     /* Root seq snapshot */

        _Atomic(uint32_t) wd_state;              /* cl_wd_state_t */
        _Atomic(uint32_t) wd_reason;             /* cl_wd_reason_t */

        _Atomic(uint32_t) restart_count_total;   /* seit Boot */
        _Atomic(uint32_t) last_stall_module;     /* cl_wd_module_t */

        uint8_t  src;
        uint8_t  qual;
        uint16_t reserved0;
        uint32_t reserved1;
    };
    uint8_t raw[64];
} cl_wd_hot_64b_t;

CL_STATIC_ASSERT(sizeof(cl_wd_hot_64b_t) == 64, "watchdog hot_b 64");

/* ============================================================================
 * WARM 64B: Restart Summary (persistente Liste kommt über Log + Forensics)
 * ============================================================================
 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) last_restart_ns;
        _Atomic(uint32_t) last_restart_reason;     /* cl_wd_reason_t */
        _Atomic(uint32_t) last_restart_module;     /* cl_wd_module_t */

        _Atomic(uint64_t) last_restart_commit_epoch;

        _Atomic(uint64_t) reserved0;
        _Atomic(uint64_t) reserved1;

        uint8_t  src;
        uint8_t  qual;
        uint16_t reserved2;
        uint32_t reserved3;
    };
    uint8_t raw[64];
} cl_wd_warm_64_t;

CL_STATIC_ASSERT(sizeof(cl_wd_warm_64_t) == 64, "watchdog warm 64");

/* ============================================================================
 * COLD 64B: Policy/Thresholds (sichtbar, konservativ)
 * ============================================================================
 */
typedef union CL_ALIGNAS(8) {
    struct {
        uint32_t stall_ns_threshold;   /* z.B. 2_000_000_000 (2s) */
        uint32_t warn_ns_threshold;    /* z.B. 250_000_000 (250ms) */

        uint32_t max_restart_per_min;  /* Rate limit */
        uint32_t cooldown_s;           /* Sperrzeit nach Restart */

        uint32_t log_enabled;          /* 1=watchdog log schreiben */
        uint32_t reserved0;

        uint8_t  src;
        uint8_t  qual;
        uint16_t reserved1;
        uint32_t reserved2;

        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_wd_cold_64_t;

CL_STATIC_ASSERT(sizeof(cl_wd_cold_64_t) == 64, "watchdog cold 64");

/* ============================================================================
 * Segment 256B
 * ============================================================================
 */
typedef struct CL_ALIGNAS(256) {
    cl_wd_hot_64a_t hot_a;
    cl_wd_hot_64b_t hot_b;
    cl_wd_warm_64_t warm;
    cl_wd_cold_64_t cold;
} cl_watchdog_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_watchdog_seg_256_t) == 256, "watchdog seg 256");


<<< END FILE: ./cl_seg_watchdog_256.h

>>> START FILE: ./cl_seg_zfs_4096.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: ZFS Meta (4096B) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_seg_zfs_4096.h
 * ============================================================================
 *
 * Zweck:
 *   - ZFS Presence/Health + ARC Summary + Bulk-Offsets zu Pools/VDEVs/Datasets.
 *
 * Maximalmodell:
 *   - Wenn ZFS nicht verfügbar: zfs_present=0, state=UNSUPPORTED/UNKNOWN.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_quality.h"

#define CL_ZFS_H_OK        (1u << 0)
#define CL_ZFS_H_DEGRADED  (1u << 1)
#define CL_ZFS_H_FAULTED   (1u << 2)
#define CL_ZFS_H_SCRUBBING (1u << 3)

/* Header 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint32_t) zfs_present;
        _Atomic(uint32_t) zfs_health_bits;

        _Atomic(uint16_t) zfs_state;           /* cl_feature_state_t */
        _Atomic(uint16_t) snapshots_enabled;   /* 0/1 */
        _Atomic(uint32_t) reserved0;

        _Atomic(uint32_t) pools_count;
        _Atomic(uint32_t) vdevs_count;

        _Atomic(uint32_t) datasets_count;
        _Atomic(uint32_t) zvols_count;

        uint8_t src;
        uint8_t qual;
        uint16_t reserved1;
        uint32_t reserved2;

        uint64_t reserved3;
    };
    uint8_t raw[64];
} cl_zfs_hdr_64_t;

CL_STATIC_ASSERT(sizeof(cl_zfs_hdr_64_t)==64, "zfs hdr 64");

/* ARC 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) arc_size;
        _Atomic(uint64_t) arc_max;
        _Atomic(uint64_t) arc_hits;
        _Atomic(uint64_t) arc_misses;
        _Atomic(uint64_t) l2_size;
        _Atomic(uint64_t) l2_hits;
        _Atomic(uint64_t) l2_misses;
        _Atomic(uint64_t) reserved0;
    };
    uint8_t raw[64];
} cl_zfs_arc_64_t;

CL_STATIC_ASSERT(sizeof(cl_zfs_arc_64_t)==64, "zfs arc 64");

/* Bulk offsets 64 */
typedef union CL_ALIGNAS(8) {
    struct {
        _Atomic(uint64_t) off_pools;
        _Atomic(uint64_t) off_vdevs;
        _Atomic(uint64_t) off_datasets;
        _Atomic(uint64_t) off_zvols;

        _Atomic(uint64_t) size_pools_bytes;
        _Atomic(uint64_t) size_vdevs_bytes;
        _Atomic(uint64_t) size_datasets_bytes;
        _Atomic(uint64_t) size_zvols_bytes;
    };
    uint8_t raw[64];
} cl_zfs_bulk_64_t;

CL_STATIC_ASSERT(sizeof(cl_zfs_bulk_64_t)==64, "zfs bulk 64");

typedef union CL_ALIGNAS(8) { struct { uint64_t r[8]; }; uint8_t raw[64]; } cl_zfs_rsv_64_t;

typedef struct CL_ALIGNAS(4096) {
    cl_zfs_hdr_64_t  hdr;
    cl_zfs_arc_64_t  arc;
    cl_zfs_bulk_64_t bulk;
    cl_zfs_rsv_64_t  rsv[61];
} cl_zfs_seg_4096_t;

CL_STATIC_ASSERT(sizeof(cl_zfs_seg_4096_t)==4096, "zfs seg 4096");


<<< END FILE: ./cl_seg_zfs_4096.h

>>> START FILE: ./cl_service_seg_256.h
#pragma once
/* ============================================================================
 * CommanderLink – Segment: Service-State (256B) – FINAL
 * Datei: include/cl_runtime/cl_service_seg_256.h
 * ============================================================================
 *
 * Zweck:
 *   SSOT für Boot-/Supervisor-Zustand.
 *   ZERO-konform: keine Telemetrie, keine Policy – nur Prozessstatus.
 *
 * Writer:
 *   - clboot / später cld: expected/running/pid/crash/exit/signal
 *   - jeder Prozess (core0/hal0/link0/flow0/oracle0): heartbeat_ns
 *
 * Layout:
 *   256B = 4 Cachelines à 64B
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"

/* Service IDs (Slot-Index; SSOT) */
typedef enum cl_service_id {
    CL_SVC_CORE0   = 0,
    CL_SVC_HAL0    = 1,
    CL_SVC_LINK0   = 2,
    CL_SVC_FLOW0   = 3,
    CL_SVC_ORACLE0 = 4,
    CL_SVC_MONITOR = 5, /* optional */
    CL_SVC_MAX     = 6
} cl_service_id_t;

/* 32B Slot: bewusst klein, deterministisch */
typedef struct CL_ALIGNAS(8) cl_service_slot_32 {
    _Atomic(uint32_t) expected;          /* 0/1 */
    _Atomic(uint32_t) running;           /* 0/1 */
    _Atomic(uint32_t) pid;               /* Prozess-ID */
    _Atomic(uint32_t) crash_count;       /* Restart-Zähler */

    _Atomic(uint64_t) last_heartbeat_ns; /* Prozess schreibt (MONOTONIC ns) */

    _Atomic(int32_t)  last_exit_code;    /* Supervisor schreibt */
    _Atomic(int32_t)  last_signal;       /* Supervisor schreibt */
} cl_service_slot_32_t;

CL_STATIC_ASSERT(sizeof(cl_service_slot_32_t) == 32, "service slot muss 32B sein");

/* CL0: Globaler Boot/Redirect-Status */
typedef union CL_ALIGNAS(8) {
struct {
    _Atomic(uint64_t) boot_epoch;
    _Atomic(uint64_t) boot_id_ns;

    _Atomic(uint32_t) desired_profile;      /* Default: ACCELERATE */
    _Atomic(uint32_t) desired_redirect;     /* Wunsch: 0/1 (nur REDIRECT scope) */
    _Atomic(uint32_t) effective_redirect;   /* LINK setzt effektiv */

    _Atomic(uint32_t) redirect_allowed;   /* CORE truth: 0/1 */
    _Atomic(uint32_t) reserved_redirect0;

    _Atomic(uint32_t) last_error_code;
    _Atomic(uint32_t) service_count;

    _Atomic(uint64_t) reserved0;            /* future */
};

    uint8_t raw[64];
} cl_service_global_64_t;

CL_STATIC_ASSERT(sizeof(cl_service_global_64_t) == 64, "service global muss 64B sein");

/* CL1: Slots 0–1 */
typedef union CL_ALIGNAS(8) {
    struct { cl_service_slot_32_t s0; cl_service_slot_32_t s1; };
    uint8_t raw[64];
} cl_service_slots01_64_t;

CL_STATIC_ASSERT(sizeof(cl_service_slots01_64_t) == 64, "service slots01 muss 64B sein");

/* CL2: Slots 2–3 */
typedef union CL_ALIGNAS(8) {
    struct { cl_service_slot_32_t s2; cl_service_slot_32_t s3; };
    uint8_t raw[64];
} cl_service_slots23_64_t;

CL_STATIC_ASSERT(sizeof(cl_service_slots23_64_t) == 64, "service slots23 muss 64B sein");

/* CL3: Slots 4–5 */
typedef union CL_ALIGNAS(8) {
    struct { cl_service_slot_32_t s4; cl_service_slot_32_t s5; };
    uint8_t raw[64];
} cl_service_slots45_64_t;

CL_STATIC_ASSERT(sizeof(cl_service_slots45_64_t) == 64, "service slots45 muss 64B sein");

/* Segment 256B */
typedef struct CL_ALIGNAS(256) cl_service_seg_256 {
    cl_service_global_64_t  g0;
    cl_service_slots01_64_t g1;
    cl_service_slots23_64_t g2;
    cl_service_slots45_64_t g3;
} cl_service_seg_256_t;

CL_STATIC_ASSERT(sizeof(cl_service_seg_256_t) == 256, "service seg muss 256B sein");


<<< END FILE: ./cl_service_seg_256.h

>>> START FILE: ./cl_shm_layout.h
#pragma once
/* ============================================================================
 * CommanderLink – Core SHM Root Layout (Runtime) – FINAL
 * Datei: include/cl_runtime/cl_shm_layout.h
 * ============================================================================
 *
 * Ziel:
 *   Root ist die Notfall-Wahrheit: minimal, deterministisch, 4096B.
 *
 * Maschinenregel:
 *   - raw[4096] Normfläche.
 *   - Host-Order.
 *   - 64-bit-first Feldreihenfolge.
 * ============================================================================
 */

#include <stdint.h>
#include <stdatomic.h>

#include "../cl_common/cl_align.h"
#include "../cl_manifest/cl_ids.h"
#include "../cl_manifest/cl_enums.h"
#include "cl_schema.h"

#define CL_CORE_SHM_NAME   "/cl_core_root"
#define CL_BULK_SHM_NAME   "/cl_bulk"

#define CL_ROOT_MAGIC_U32          0x54524C43u /* "CLRT" in Host-Order */
#define CL_ROOT_FLAG_FAILFAST_ABI  (1u << 0)


typedef union CL_ALIGNAS(CL_SHM_PAGE_BYTES) {
    struct {
        /* 64-bit first */
        uint64_t abi_layout_checksum;

        _Atomic(uint64_t) seq_cnt;
        _Atomic(uint64_t) uptime_ns;
        _Atomic(uint64_t) bulk_epoch;

        uint64_t boot_id_ns;

        uint64_t toc_offset;
        uint64_t toc_size;

		/* 32-bit */
        uint32_t root_magic;      /* CL_ROOT_MAGIC_U32 */
        uint32_t root_flags;      /* CL_ROOT_FLAG_*    */

        uint32_t schema_version;
        uint32_t endian_magic;

        _Atomic(uint32_t) global_health;
        _Atomic(uint32_t) budget_state;

        _Atomic(uint32_t) path_state;
        _Atomic(uint32_t) backend_active;
        _Atomic(uint32_t) mode_active;
        _Atomic(uint32_t) profile_active;

        _Atomic(uint32_t) rx_gate;
        _Atomic(uint32_t) tx_gate;

        _Atomic(uint32_t) constraint_flags;
        _Atomic(uint32_t) reason_code;

        _Atomic(uint32_t) bulk_present;

        uint32_t overlay_ip_host_u32;
        uint32_t overlay_failopen_events;
        uint16_t overlay_routes;
        uint16_t mtu_effective;

        /* 8-bit */
        _Atomic(uint8_t) active_index;
        uint8_t overlay_prefixlen;
        uint8_t overlay_enabled;
        uint8_t reserved_u8;

        /* Trust quick view */
        _Atomic(uint32_t) trust_policy_required;
        _Atomic(uint32_t) trusted_peer_count;
    };
    uint8_t raw[CL_SHM_PAGE_BYTES];
} cl_root_4096_t;

CL_STATIC_ASSERT(sizeof(cl_root_4096_t) == CL_SHM_PAGE_BYTES, "root must be 4096B");

/* Back-compat */
typedef cl_root_4096_t cl_root_t;


<<< END FILE: ./cl_shm_layout.h

>>> START FILE: ./cl_toc.h
#pragma once
/* ============================================================================
 * CommanderLink – Runtime TOC (Table of Contents) – FINAL Endausbau
 * Datei: include/cl_runtime/cl_toc.h
 * ============================================================================
 *
 * Vertrag:
 *   - TOC ist die physikalische Verkabelung der Runtime-SHM.
 *   - TOC ist rein beschreibend (keine Policy, keine Logik).
 *
 * Layout:
 *   - cl_toc_header_t: exakt 64B (1 Cacheline)
 *   - cl_toc_entry_t : exakt 64B (1 Cacheline)
 *   - cl_toc_t       : Header + entries[CL_TOC_MAX_ENTRIES]
 *
 * Semantik:
 *   - Segment-ID: CL_<NAME>_SEG_<stride>
 *   - Segmentgröße steht im TOC (stride_bytes), nicht im Segment-ID-Namen.
 *     (Der Name trägt den stride nur als symbolische Eindeutigkeit.)
 * ============================================================================
 */

#include <stdint.h>

#include "cl_gates.h"

/* --------------------------------------------------------------------------
 * Architekturannahme
 * -------------------------------------------------------------------------- */
#if !defined(__x86_64__) && !defined(_M_X64)
#error "CommanderLink TOC ist x86_64-first"
#endif

/* --------------------------------------------------------------------------
 * TOC Version / Limits
 * -------------------------------------------------------------------------- */
#define CL_TOC_VERSION      1u
#define CL_TOC_MAX_ENTRIES  128u

/* --------------------------------------------------------------------------
 * Segment-IDs (SSOT für TOC type)
 *
 * Hinweis:
 *   Diese IDs sind für TOC/Tools/Monitor.
 *   Die semantische Rolle bleibt wichtiger als die Zahl selbst.
 * -------------------------------------------------------------------------- */
typedef enum cl_seg_type {

    /* 256 */
    CL_LINK_SEG_256            = 0x0100,
    CL_BUDGET_SEG_256          = 0x0101,
    CL_MEM_SEG_256             = 0x0102,
    CL_OVERLAY_SEG_256         = 0x0103,
    CL_WATCHDOG_SEG_256        = 0x0104,
    CL_PCIE_SEG_256            = 0x0105,
    CL_TIME_SEG_256            = 0x0106,
    CL_MESH_NEIGHBOR_SEG_256   = 0x0107,
    CL_MESH_PEER_SEG_256       = 0x0108,
    CL_ORACLE_SEG_256          = 0x0109,
    CL_SERVICE_SEG_256         = 0x010A,
    CL_IDENTITY_SEG_256        = 0x010B,
    CL_FLOW_CMD_SEG_256        = 0x010C,

    /* 512 */
    CL_NIC_SEG_512             = 0x0200,
    CL_BOARD_SEG_512           = 0x0201,

    /* 1024 */
    CL_CPU_SEG_1024            = 0x0300,

    /* 4096 */
    CL_DMA_SEG_4096            = 0x0400,
    CL_HISTORY_SEG_4096        = 0x0401,
    CL_FORENSICS_SEG_4096      = 0x0402,
    CL_ZFS_SEG_4096            = 0x0403
} cl_seg_type_t;

/* --------------------------------------------------------------------------
 * TOC Flags (physikalische Eigenschaften, keine Policy)
 * -------------------------------------------------------------------------- */
typedef uint32_t cl_toc_flags_t;

/* Speicherklasse */
#define CL_TOC_FLAG_RESIDENT        (1u << 0)  /* Core-SHM                         */
#define CL_TOC_FLAG_RECLAIMABLE     (1u << 1)  /* Bulk-SHM                         */

/* Bedeutung */
#define CL_TOC_FLAG_CRITICAL        (1u << 2)
#define CL_TOC_FLAG_OBSERVABLE      (1u << 3)

/* Änderungsfrequenz */
#define CL_TOC_FLAG_HOT             (1u << 4)
#define CL_TOC_FLAG_WARM            (1u << 5)
#define CL_TOC_FLAG_COLD            (1u << 6)

/* Instanzierung */
#define CL_TOC_FLAG_FIXED_COUNT     (1u << 7)
#define CL_TOC_FLAG_VARIABLE_COUNT  (1u << 8)

/* Rolle */
#define CL_TOC_FLAG_DATA            (1u << 9)
#define CL_TOC_FLAG_CONTROL         (1u << 10)
#define CL_TOC_FLAG_FORENSICS       (1u << 11)

/* --------------------------------------------------------------------------
 * Source/Access/Presence/Layout
 * -------------------------------------------------------------------------- */
typedef uint16_t cl_toc_source_t;
#define CL_TOC_SOURCE_DIRECT        (1u << 0)
#define CL_TOC_SOURCE_BEST_EFFORT   (1u << 1)
#define CL_TOC_SOURCE_ESTIMATED     (1u << 2)
#define CL_TOC_SOURCE_UNSUPPORTED   (1u << 3)

typedef uint16_t cl_toc_access_t;
#define CL_TOC_ACCESS_READ          (1u << 0)
#define CL_TOC_ACCESS_WRITE         (1u << 1)
#define CL_TOC_ACCESS_ATOMIC        (1u << 2)

typedef uint16_t cl_toc_presence_t;
#define CL_TOC_PRESENT              (1u << 0)
#define CL_TOC_RECLAIMED            (1u << 1)
#define CL_TOC_PARTIAL              (1u << 2)

typedef uint16_t cl_toc_layout_t;
#define CL_TOC_LAYOUT_CACHELINE     (1u << 0)
#define CL_TOC_LAYOUT_ARRAY         (1u << 1)

/* --------------------------------------------------------------------------
 * TOC Entry – exakt 64B
 * -------------------------------------------------------------------------- */
typedef struct cl_toc_entry {

    uint16_t       type;           /* cl_seg_type_t */
    uint16_t       version;        /* Segment-spezifische Version */
    uint32_t       flags;          /* cl_toc_flags_t */

    uint32_t       stride_bytes;   /* 256/512/1024/4096 */
    uint32_t       count;          /* Instanzen */

/* offset_bytes:
 *   SSOT-Regel (bitgenau, projektweit):
 *   - Wenn (flags & CL_TOC_FLAG_RECLAIMABLE) == 0:
 *       offset_bytes ist relativ zur Core-SHM Base (CL_CORE_SHM_NAME mapping).
 *   - Wenn (flags & CL_TOC_FLAG_RECLAIMABLE) != 0:
 *       offset_bytes ist relativ zur Bulk-SHM Base (CL_BULK_SHM_NAME mapping).
 *
 *   Consumer (Monitor/Tools/HAL/CORE/LINK/FLOW) dürfen dies niemals raten,
 *   sondern müssen die Base ausschließlich über das RECLAIMABLE-Flag wählen.
 */

    uint64_t       offset_bytes;   /* Offset relativ zum jeweiligen SHM-Beginn */

    uint16_t       source_flags;   /* cl_toc_source_t  */
    uint16_t       access_flags;   /* cl_toc_access_t  */
    uint16_t       presence_flags; /* cl_toc_presence_t */
    uint16_t       layout_flags;   /* cl_toc_layout_t */

    cl_gate_mask_t gates_possible;
    cl_gate_mask_t gates_effective;

    uint64_t       epoch;

    uint64_t       reserved0;      /* macht 64B exakt */

} cl_toc_entry_t;

_Static_assert(sizeof(cl_toc_entry_t) == 64, "cl_toc_entry_t muss exakt 64B sein");

/* --------------------------------------------------------------------------
 * TOC Header – exakt 64B
 * -------------------------------------------------------------------------- */
typedef struct cl_toc_header {

    uint32_t version;        /* CL_TOC_VERSION */
    uint32_t entry_count;    /* Anzahl gültiger Entries */

    uint64_t total_bytes;    /* Core oder Core+Bulk (konkret, nicht geraten) */
    uint64_t build_id;       /* ABI-/Build-Fingerprint */
    uint64_t epoch;          /* TOC epoch */

    uint64_t reserved[4];    /* macht 64B exakt */

} cl_toc_header_t;

_Static_assert(sizeof(cl_toc_header_t) == 64, "cl_toc_header_t muss exakt 64B sein");

/* --------------------------------------------------------------------------
 * Gesamter TOC
 * -------------------------------------------------------------------------- */
typedef struct cl_toc {

    cl_toc_header_t header;
    cl_toc_entry_t  entries[CL_TOC_MAX_ENTRIES];

} cl_toc_t;


<<< END FILE: ./cl_toc.h

========================================
 PROJECT STRUCTURE TREE
========================================
.
├── cl_gates.h
├── cl_identity_seg_256.h
├── cl_quality.h
├── cl_runtime.h
├── cl_schema.h
├── cl_seg_board_512.h
├── cl_seg_budget_256.h
├── cl_seg_cpu_1024.h
├── cl_seg_dma_4096.h
├── cl_seg_flow_cmd_256.h
├── cl_seg_forensics_4096.h
├── cl_seg_history_4096.h
├── cl_seg_link_256.h
├── cl_seg_mem_256.h
├── cl_seg_mesh_neighbor_256.h
├── cl_seg_mesh_peer_256.h
├── cl_seg_nic_512.h
├── cl_seg_oracle_256.h
├── cl_seg_overlay_256.h
├── cl_seg_pcie_256.h
├── cl_seg_time_256.h
├── cl_seg_watchdog_256.h
├── cl_seg_zfs_4096.h
├── cl_service_seg_256.h
├── cl_shm_layout.h
├── cl_toc.h
└── single_dump.sh

1 directory, 27 files
